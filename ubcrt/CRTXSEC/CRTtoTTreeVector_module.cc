////////////////////////////////////////////////////////////////////////
// Class:       CRTtoTTree
// Module Type: analyzer
// File:        CRTtoTTreeVector_module.cc
// Description: Takes CRT Hits, CRT tracks, PMT flashes, and put them in vectors per event in a tree
//
// Generated at Mon Nov 19 03:49:01 2018 by Thomas Mettler using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

#include "ubcrt/CRTXSEC/CRTAnaFun.hh"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h"                                                               
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"

//#include "Event_Tree.h"


#include "Pandora/PdgTable.h"

#include "TTree.h"
#include "TBenchmark.h"
#include "TRandom.h"
#include "TSystem.h"
#include "TClonesArray.h"
#include "TObject.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>

#define LIGHTSPEED 299792458.0 // m/s
#define MASS_MU 105.6583745 // MeV

//namespace lar_pandora
//{
namespace crt {
  class CRTtoTTree;

  class CRTtoTTree : public art::EDAnalyzer {
  public:
    explicit CRTtoTTree(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTtoTTree(CRTtoTTree const &) = delete;
    CRTtoTTree(CRTtoTTree &&) = delete;
    CRTtoTTree & operator = (CRTtoTTree const &) = delete;
    CRTtoTTree & operator = (CRTtoTTree &&) = delete;



    // Required functions.
    void analyze(art::Event const & e) override;

    // Selected optional functions.
    void beginJob() override;
    void endJob() override;


  private:

    // Declare member data here.
    art::ServiceHandle<art::TFileService> tfs;

    //tree variables for PFParticles///////////////////
    TTree* t_pandora;
    int nPFPcosmic = -9999;
    int nPFPnu = -9999;
    int nPFPnuTrack = -9999;
    int nPFPnuShower = -9999;

    // tree with vectors for event
    TTree* my_event_;
    crt::CRTHit mycrthit;
    std::vector<crt::CRTHit> crthit_vec;
    std::vector<crt::CRTTrack> crttrack_vec;
    std::vector<recob::OpFlash> beam_flash_vec;
    std::vector<recob::OpFlash> flash_vec;
    std::vector<recob::Track> nutrack_vec;
    std::vector<recob::Shower> nushower_vec;  
    std::vector<recob::Track> tpctrack_vec;
    
    //raw::DAQHeaderTimeUBooNE myDAQheader;
    //art::Timestamp myTime;
    
    uint32_t fEvtNum; //Number of current event                       
    uint32_t frunNum;                //Run Number taken from event  
    uint32_t fsubRunNum;             //Subrun Number taken from event 
    
    double evt_timeGPS_sec;
    double evt_timeGPS_nsec;

    // data lables from fcl file/////////////////////////////////////////////////////////
    std::string m_pandoraLabel;         ///< The label for the pandora producer
    std::string m_trackLabel;           ///< The label for the track producer from PFParticles
    std::string m_showerLabel;          ///< The label for the shower producer from PFParticles
    int verbose_;
    //int numberOfevents_;
    std::string data_label_hits_;
    std::string data_label_tracks_;   
    int saveTTree_;
    std::string  data_label_flash_;
    std::string  data_label_flash_beam_;
    std::string  data_label_DAQHeader_;
    std::string  data_label_TPCTrack_;
    std::string  data_label_T0reco_;
    std::string  data_label_Calorimetry_;
    int fHardDelay_;
    int fCRTT0off_;
    double fvdrift_;

    // functions ////////////////////////////////////////////////////////////////////////////////////////

    void initialize_tpandora();
    //void initialize_tcrthits();
    //void initialize_tcrttracks();
    //void initialize_tflash();
    void initialize_tmyevent();
    //void fill_tcrthit( crt::CRTHit my_CRTHit );
    //void fill_tcrttrack( crt::CRTTrack my_CRTTrack );
  };

  //}

  //namespace lar_pandora
  //{
  CRTtoTTree::CRTtoTTree(fhicl::ParameterSet const & pset)
    :
    EDAnalyzer(pset)  // ,
   // More initializers here.

  {
    m_pandoraLabel = pset.get<std::string>("PandoraLabel");
    m_trackLabel = pset.get<std::string>("TrackLabel");
    m_showerLabel = pset.get<std::string>("ShowerLabel");
    //m_printOutScores = pset.get<bool>("PrintOutScores",true);
    verbose_ = pset.get<int>("verbose");
    //numberOfevents_ = pset.get<int>("Number_of_Events");
    data_label_hits_ = pset.get<std::string>("data_label_hits");
    data_label_tracks_ = pset.get<std::string>("data_label_tracks");

    data_label_flash_ = pset.get<std::string>("data_label_flash");
    data_label_flash_beam_ = pset.get<std::string>("data_label_flash_beam");
    data_label_DAQHeader_ = pset.get<std::string>("data_label_DAQHeader");
    data_label_TPCTrack_ = pset.get<std::string>("data_label_TPCTrack");
    data_label_T0reco_ = pset.get<std::string>("data_label_T0reco");
    data_label_Calorimetry_ = pset.get<std::string>("data_label_Calorimetry");
    fHardDelay_ = pset.get<int>("fHardDelay",40000);
    fCRTT0off_ = pset.get<int>("fCRTT0off",69000);
    fvdrift_ = pset.get<double>("fvdrift",0.111436);

    saveTTree_ = pset.get<int>("saveTTree");
  }

  void CRTtoTTree::analyze(art::Event const & evt)
  {
    // Implementation of required member function here.
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun() << std::endl;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get PFParticle information////////////////////////////////////////////////////////////////////////////////////
    crtana::PFParticleHandle pfParticleHandle;
    evt.getByLabel(m_pandoraLabel, pfParticleHandle);

    if (!pfParticleHandle.isValid())
    {
        mf::LogDebug("ConsolidatedPFParticleAnalysisTemplate") << "  Failed to find the PFParticles." << std::endl;
        return;
    }

    // Produce a map of the PFParticle IDs for fast navigation through the hierarchy
    crtana::PFParticleIdMap pfParticleMap;
    crtana::auxfunc::GetPFParticleIdMap(pfParticleHandle, pfParticleMap);

    // Produce two PFParticle vectors containing final-state particles:
    // 1. Particles identified as cosmic-rays - recontructed under cosmic-hypothesis
    // 2. Daughters of the neutrino PFParticle - reconstructed under the neutrino hypothesis
    std::vector< art::Ptr<recob::PFParticle> > crParticles;
    std::vector< art::Ptr<recob::PFParticle> > nuParticles;
    crtana::auxfunc::GetFinalStatePFParticleVectors(pfParticleMap, crParticles, nuParticles);

    // Use as required!
    // -----------------------------
    //   What follows is an example showing how one might access the reconstructed neutrino final-state tracks and showers

    // These are the vectors to hold the tracks and showers for the final-states of the reconstructed neutrino
    std::vector< art::Ptr<recob::Track> > tracks;
    std::vector< art::Ptr<recob::Shower> > showers;
    crtana::auxfunc::CollectTracksAndShowers(nuParticles, pfParticleHandle, evt, tracks, showers, m_trackLabel, m_showerLabel);

    // Print a summary of the consolidated event
    std::cout << "Consolidated event summary:" << std::endl;
    std::cout << "  - Number of primary cosmic-ray PFParticles   : " << crParticles.size() << std::endl;
    std::cout << "  - Number of neutrino final-state PFParticles : " << nuParticles.size() << std::endl;
    std::cout << "    ... of which are track-like   : " << tracks.size() << std::endl;
    std::cout << "    ... of which are showers-like : " << showers.size() << std::endl;
    
    // Fill pandora tree:
    nPFPcosmic = crParticles.size();
    nPFPnu = nuParticles.size();
    nPFPnuTrack = tracks.size();
    nPFPnuShower = showers.size();
    t_pandora->Fill();
    
    recob::Track my_track;
    recob::Shower my_shower;
    
    for(std::vector<int>::size_type i = 0; i != tracks.size(); i++) {//A 
      my_track = *tracks.at(i).get();
      nutrack_vec.push_back(my_track);
    }//A
    for(std::vector<int>::size_type i = 0; i != showers.size(); i++) {//A 
      my_shower = *showers.at(i).get();
      nushower_vec.push_back(my_shower);
    }//A
    
    if(tracks.size()>0 && showers.size()>0){
      //recob::Track my_track = *tracks.at(0).get();
      //recob::Shower my_shower = *showers.at(0).get();

      std::cout << "Size of track: " << sizeof(my_track) << std::endl;
      std::cout << "Size of shower: " << sizeof(my_shower) << std::endl;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get PFParticle information////////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get CRT hit information /////////////////////////////////////////////////////////////////////////////////////
    art::Handle< std::vector<crt::CRTHit> > rawHandle_hits;
    evt.getByLabel(data_label_hits_, rawHandle_hits); //what is the product instance name? no BernZMQ
    int hits_valid=1;
    //check to make sure the data we asked for is valid                                                                                                      
    if(!rawHandle_hits.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[31m" << "zero" << "\033[0m"
                << " CRTHits " << " in module " << data_label_hits_ << std::endl;
      std::cout << std::endl;
      hits_valid=0;
      //return;
    }
    if(hits_valid!=0){
      //get better access to the data               
      std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_hits);
      if(rawHandle_hits.isValid()){
        std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                  << ", event " << evt.event() << " has " << "\033[32m" << CRTHitCollection.size() << "\033[0m"
                  << " CRTHits " << " in module " << data_label_hits_ << std::endl;
       //return;
      }
      std::cout << "Time first event: " << CRTHitCollection[0].ts0_s << std::endl;
      crthit_vec = CRTHitCollection;
      if(verbose_ != 0){
        for(std::vector<int>::size_type i = 0; i != CRTHitCollection.size(); i++) {//A 
          //printf("Processing %ld hit\n", i);
          //std::cout << "Time event: " << CRTHitCollection[i].ts0_s <<" , ns+ " << CRTHitCollection[i].ts0_ns << std::endl;
          //std::cout << "Position event: " << CRTHitCollection[i].x_pos <<" , " << CRTHitCollection[i].y_pos << std::endl;
        }//A
      }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get CRT hit information /////////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get CRT track information ///////////////////////////////////////////////////////////////////////////////////
    art::Handle< std::vector<crt::CRTTrack> > rawHandle_tracks;
    evt.getByLabel(data_label_tracks_, rawHandle_tracks); //what is the product instance name? no BernZMQ
    int tracks_valid=1;
    //check to make sure the data we asked for is valid                                                                                                      
    if(!rawHandle_tracks.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[31m" << "zero" << "\033[0m"
                << " CRTTracks " << " in module " << data_label_tracks_ << std::endl;
      std::cout << std::endl;
      tracks_valid=0;
      //return;
    }
    //get better access to the data   
    if(tracks_valid!=0){
      std::vector<crt::CRTTrack> const& CRTTrackCollection(*rawHandle_tracks);
      if(rawHandle_tracks.isValid()){
        std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                  << ", event " << evt.event() << " has " << "\033[32m" << CRTTrackCollection.size() << "\033[0m"
                  << " CRTTracks " << " in module " << data_label_tracks_ << std::endl;
      }
      crttrack_vec = CRTTrackCollection;
      //std::cout << "Size of CRT track: " << sizeof(my_CRTHit) << std::endl;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get CRT track information ///////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get PMT flash information ///////////////////////////////////////////////////////////////////////////////////
    frunNum    = evt.run();
    fsubRunNum = evt.subRun();
    fEvtNum = evt.event();

    //get DAQ Header
    art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;
    evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
    if(!rawHandle_DAQHeader.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has zero"
                << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;
      return;
    }  
    
    raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);

    art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();  
    evt_timeGPS_sec = evtTimeGPS.timeHigh();
    evt_timeGPS_nsec = evtTimeGPS.timeLow();

    //std::cout << "Size of DAQ header: " << sizeof(my_DAQHeader) << std::endl;
    //std::cout << "Size of time header: " << sizeof(evtTimeGPS) << std::endl;

    //get Optical Flash
    art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlash;
    evt.getByLabel(data_label_flash_, rawHandle_OpFlash);
    std::vector<recob::OpFlash> const& OpFlashCollection(*rawHandle_OpFlash);   
    //get Optical Flash
    //NrFlash = OpFlashCollection.size();
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has " << "\033[32m" << OpFlashCollection.size() << "\033[0m"
              << " TPCFlashes " << " in module " << data_label_flash_ << std::endl;  
    flash_vec = OpFlashCollection;
    
    //get Optical Flash
    art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlashBeam;
    evt.getByLabel(data_label_flash_beam_, rawHandle_OpFlashBeam);
    std::vector<recob::OpFlash> const& OpFlashBeamCollection(*rawHandle_OpFlashBeam);   
    //get Optical Flash
    //NrFlash = OpFlashCollection.size();
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has " << "\033[32m" << OpFlashBeamCollection.size() << "\033[0m"
              << " TPCFlashes " << " in module " << data_label_flash_beam_ << std::endl;  
    beam_flash_vec = OpFlashBeamCollection;
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get PMT flash information ///////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get TPC track information ///////////////////////////////////////////////////////////////////////////////////
    art::Handle< std::vector<recob::Track> > rawHandle_Track;
    evt.getByLabel(data_label_TPCTrack_, rawHandle_Track);

    std::vector<recob::Track> const& TPCTrackCollection(*rawHandle_Track);
    
    tpctrack_vec = TPCTrackCollection;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get TPC track information ///////////////////////////////////////////////////////////////////////////////


    my_event_->Fill();
    nutrack_vec.clear();
    nushower_vec.clear();
    
    int testana = crtana::auxfunc::test(3);
    std::cout<< "Test ana aux: " << testana << std::endl;
  }

  void CRTtoTTree::initialize_tpandora()
  {
    // Implementation of optional member function here.
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for pandora consolidated output" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    t_pandora = tfs->make<TTree>("t_pandora","t_pandora");
    t_pandora->Branch("nPFPcosmic", &nPFPcosmic, "Number of Cosmic PFparticles/I");
    t_pandora->Branch("nPFPnu", &nPFPnu, "Number of nu PFparticles/I");
    t_pandora->Branch("nPFPnuTrack", &nPFPnuTrack, "Number of track like nu PFparticles/I");
    t_pandora->Branch("nPFPnuShower", &nPFPnuShower, "Number of Shower like nu PFparticles/I");

  }

  void CRTtoTTree::initialize_tmyevent()
  {
    // Implementation of optional member function here.
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for flash output" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    my_event_ = tfs->make<TTree>("my_event","my_event");
    
    //int bufsize    = 16000;
    //int splitlevel = 99;
    //_tree1->Branch("ubxsec_event_split", &ubxsec_event, bufsize, splitlevel);
    
    int bufsize_crthit = 128*5000;
    int bufsize_flash = 152*5000;
    int bufsize_crttrack = 184*5000;
    int bufsize_track = 368*500;
    int bufsize_shower = 336*500;
    //int bufsize_daqheader = 48;
    
    int splitlevel = 99;
    my_event_->Branch("crthits", &crthit_vec, bufsize_crthit, splitlevel);
    my_event_->Branch("crttracks", &crttrack_vec, bufsize_crttrack, splitlevel);
    my_event_->Branch("flashes", &flash_vec, bufsize_flash, splitlevel);
    my_event_->Branch("beamflashes", &beam_flash_vec, bufsize_flash, splitlevel);
    my_event_->Branch("nutracks", &nutrack_vec, bufsize_track, splitlevel);
    my_event_->Branch("nushowers", &nushower_vec, bufsize_shower, splitlevel);
    my_event_->Branch("tpctracks", &tpctrack_vec, bufsize_track*10, splitlevel);
    
    
    //my_event_->Branch("daqheader", &myTime, bufsize_daqheader, splitlevel);
    my_event_->Branch("evt_timeGPS_sec", &evt_timeGPS_sec, "Eventtime sec/D");
    my_event_->Branch("evt_timeGPS_nsec", &evt_timeGPS_nsec, "Eventtime ns/D");
    
    my_event_->Branch("frunNum", &frunNum, "Run Number/i");
    my_event_->Branch("fsubRunNum", &fsubRunNum, "SubRun Number/i");
    my_event_->Branch("fEvtNum", &fEvtNum, "Event Number/i");

  }

  void CRTtoTTree::beginJob()
  {
    // Implementation of optional member function here.
    initialize_tpandora();
    initialize_tmyevent();

  }
  void CRTtoTTree::endJob()
  {
    // Implementation of optional member function here.
  }
  
  
  
  DEFINE_ART_MODULE(CRTtoTTree)
}