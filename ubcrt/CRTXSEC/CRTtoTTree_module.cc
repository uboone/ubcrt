////////////////////////////////////////////////////////////////////////
// Class:       CRTtoTTree
// Module Type: analyzer
// File:        CRTtoTTree_module.cc
//
// Generated at Mon Nov 19 03:49:01 2018 by Thomas Mettler using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h"                                                               
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"


#include "Pandora/PdgTable.h"

#include "TTree.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>

#define LIGHTSPEED 299792458.0 // m/s
#define MASS_MU 105.6583745 // MeV

//namespace lar_pandora
//{
namespace crt {
  class CRTtoTTree;


  typedef art::Handle< std::vector<recob::PFParticle> > PFParticleHandle;
  typedef std::map< size_t, art::Ptr<recob::PFParticle> > PFParticleIdMap;
  typedef std::vector< art::Ptr<recob::PFParticle> > PFParticleVector;
  typedef std::vector< art::Ptr<recob::Track> > TrackVector;
  typedef std::vector< art::Ptr<recob::Shower> > ShowerVector;

  class CRTtoTTree : public art::EDAnalyzer {
  public:
    explicit CRTtoTTree(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTtoTTree(CRTtoTTree const &) = delete;
    CRTtoTTree(CRTtoTTree &&) = delete;
    CRTtoTTree & operator = (CRTtoTTree const &) = delete;
    CRTtoTTree & operator = (CRTtoTTree &&) = delete;



    // Required functions.
    void analyze(art::Event const & e) override;

    // Selected optional functions.
    void beginJob() override;
    void endJob() override;


  private:

    // Declare member data here.
    art::ServiceHandle<art::TFileService> tfs;

    //tree variables for PFParticles///////////////////
    TTree* t_pandora;
    int nPFPcosmic = -9999;
    int nPFPnu = -9999;
    int nPFPnuTrack = -9999;
    int nPFPnuShower = -9999;

    //quallity plots for CRT hits//////////////////////
    TH2F* HitDistBot;
    TH2F* HitDistFT;
    TH2F* HitDistPipe;
    TH2F* HitDistTop;

    TH1F* hxtot;
    TH1F* hytot;
    TH1F* hztot;

    TH1F* BeamTime;
    TH2F* FEBvsFEB;

    TH1F* hPEShit;
    //tree variables for CRT hits///////////////////
    TTree*       my_hits_;
    double xtot=-10000., ytot=-10000., ztot=-10000.;
    double xerr=-10000., yerr=-10000., zerr=-10000.;
    double hit_time_ns = -1e18;
    double hit_time_ns_err = -1e18;
    double hit_time_s = -1e18;
    double hit_time_s_err = -1e18;
    double beam_time_ns = -1e18;
    double beam_time_ns_err = -1e18;
    int plane = -1;
    std::vector<uint8_t> feb_id;
    double peshit = -1e19;
    int feb_id1=0;
    int feb_id2=0;
    uint16_t event_flag;
    uint16_t lostcpu1;
    uint16_t lostcpu2;
    uint16_t lostfpga1;
    uint16_t lostfpga2;


    //quallity plots for CRT tracks//////////////////////
    TH2F* hplavspla;
    TH1F* hTlength;
    TH1F* hTtime;
    TH2F* hTlengthvsTime;
    TH2F* hTlengthvsTimeAbs;
    TProfile* hTlengthvsTimeAbs_prof;
    TH1F* htheta;
    TH1F* hphi;
    TH1F* hts0_ns;
    TH2F* hTvsH;

    TH2F* TrackDistBot;
    TH2F* TrackDistFT;
    TH2F* TrackDistPipe;
    TH2F* TrackDistTop;

    //tree variables for CRT tracks///////////////////
    TTree* my_tracks_;
    int feb_id01=0;
    int feb_id02=0;
    int feb_id03=0;
    int feb_id04=0;
    double track_time_ns = -1e18;
    double track_time_1ns = -1e18;
    double track_time_1ns_err = -1e18;
    double track_time_2ns = -1e18;
    double track_time_2ns_err = -1e18;
    double track_time_s = -1e18;
    double track_time_ns_err = -1e18;
    double track_time_s_err = -1e18;
    double track_beam_ns = -1e18;
    double track_beam_ns_err = -1e18;
    double time_diff = 1e24;
    double length = -1e18;
    double theta = -1e18;
    double phi = -1e18;
    double x1 = -1e18;
    double y1 = -1e18;
    double z1 = -1e18;
    double x2 = -1e18;
    double y2 = -1e18;
    double z2 = -1e18;
    double x1_err = -1e18;
    double y1_err = -1e18;
    double z1_err = -1e18;
    double x2_err = -1e18;
    double y2_err = -1e18;
    double z2_err = -1e18;
    double pestrack;
    int plane1=-1;
    int plane2=-1;
    
    // tree variables for flash
    TTree * t_flash;
    uint32_t fTriTim_sec;
    uint32_t fTriTim_nsec;
    double fY;
    double fZ;
    double fPEflash;
    double fTimFla;
    double fAbsTimFla;
    int fbeam;
    int NrFlash;
    
    uint32_t fEvtNum; //Number of current event                       
    uint32_t frunNum;                //Run Number taken from event  
    uint32_t fsubRunNum;             //Subrun Number taken from event 

    // data lables from fcl file/////////////////////////////////////////////////////////
    std::string m_pandoraLabel;         ///< The label for the pandora producer
    std::string m_trackLabel;           ///< The label for the track producer from PFParticles
    std::string m_showerLabel;          ///< The label for the shower producer from PFParticles

    int verbose_;
    //int numberOfevents_;
    std::string data_label_hits_;
    std::string data_label_tracks_;
    
    int saveTTree_;
  
    //std::string  data_labelCRTtrack_;
    //std::string  data_labelCRThit_;
    std::string  data_label_flash_;
    std::string  data_label_DAQHeader_;
    std::string  data_label_TPCTrack_;
    std::string  data_label_T0reco_;
    std::string  data_label_Calorimetry_;
    int fHardDelay_;
    int fCRTT0off_;
    double fvdrift_;

    // functions ////////////////////////////////////////////////////////////////////////////////////////

    void GetPFParticleIdMap(const PFParticleHandle &pfParticleHandle, PFParticleIdMap &pfParticleMap);
    void GetFinalStatePFParticleVectors(const PFParticleIdMap &pfParticleMap, PFParticleVector &crParticles, PFParticleVector &nuParticles);
    void CollectTracksAndShowers(const PFParticleVector &particles, const PFParticleHandle &pfParticleHandle, const art::Event &evt, TrackVector &tracks, ShowerVector &showers);

    void initialize_tpandora();
    void initialize_tcrthits();
    void initialize_tcrttracks();
    void initialize_tflash();
    void fill_tcrthit( crt::CRTHit my_CRTHit );
    void fill_tcrttrack( crt::CRTTrack my_CRTTrack );
  };

  //}

  //namespace lar_pandora
  //{
  CRTtoTTree::CRTtoTTree(fhicl::ParameterSet const & pset)
    :
    EDAnalyzer(pset)  // ,
   // More initializers here.

  {
    m_pandoraLabel = pset.get<std::string>("PandoraLabel");
    m_trackLabel = pset.get<std::string>("TrackLabel");
    m_showerLabel = pset.get<std::string>("ShowerLabel");
    //m_printOutScores = pset.get<bool>("PrintOutScores",true);
    verbose_ = pset.get<int>("verbose");
    //numberOfevents_ = pset.get<int>("Number_of_Events");
    data_label_hits_ = pset.get<std::string>("data_label_hits");
    data_label_tracks_ = pset.get<std::string>("data_label_tracks");

    data_label_flash_ = pset.get<std::string>("data_label_flash");
    data_label_DAQHeader_ = pset.get<std::string>("data_label_DAQHeader");
    data_label_TPCTrack_ = pset.get<std::string>("data_label_TPCTrack");
    data_label_T0reco_ = pset.get<std::string>("data_label_T0reco");
    data_label_Calorimetry_ = pset.get<std::string>("data_label_Calorimetry");
    fHardDelay_ = pset.get<int>("fHardDelay",40000);
    fCRTT0off_ = pset.get<int>("fCRTT0off",69000);
    fvdrift_ = pset.get<double>("fvdrift",0.111436);

    saveTTree_ = pset.get<int>("saveTTree");
  }

  void CRTtoTTree::analyze(art::Event const & evt)
  {
    // Implementation of required member function here.
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun() << std::endl;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get PFParticle information////////////////////////////////////////////////////////////////////////////////////
    PFParticleHandle pfParticleHandle;
    evt.getByLabel(m_pandoraLabel, pfParticleHandle);

    if (!pfParticleHandle.isValid())
    {
        mf::LogDebug("ConsolidatedPFParticleAnalysisTemplate") << "  Failed to find the PFParticles." << std::endl;
        return;
    }

    // Produce a map of the PFParticle IDs for fast navigation through the hierarchy
    PFParticleIdMap pfParticleMap;
    this->GetPFParticleIdMap(pfParticleHandle, pfParticleMap);

    // Produce two PFParticle vectors containing final-state particles:
    // 1. Particles identified as cosmic-rays - recontructed under cosmic-hypothesis
    // 2. Daughters of the neutrino PFParticle - reconstructed under the neutrino hypothesis
    std::vector< art::Ptr<recob::PFParticle> > crParticles;
    std::vector< art::Ptr<recob::PFParticle> > nuParticles;
    this->GetFinalStatePFParticleVectors(pfParticleMap, crParticles, nuParticles);

    // Use as required!
    // -----------------------------
    //   What follows is an example showing how one might access the reconstructed neutrino final-state tracks and showers

    // These are the vectors to hold the tracks and showers for the final-states of the reconstructed neutrino
    std::vector< art::Ptr<recob::Track> > tracks;
    std::vector< art::Ptr<recob::Shower> > showers;
    this->CollectTracksAndShowers(nuParticles, pfParticleHandle, evt, tracks, showers);

    // Print a summary of the consolidated event
    std::cout << "Consolidated event summary:" << std::endl;
    std::cout << "  - Number of primary cosmic-ray PFParticles   : " << crParticles.size() << std::endl;
    std::cout << "  - Number of neutrino final-state PFParticles : " << nuParticles.size() << std::endl;
    std::cout << "    ... of which are track-like   : " << tracks.size() << std::endl;
    std::cout << "    ... of which are showers-like : " << showers.size() << std::endl;

    // Fill pandora tree:
    nPFPcosmic = crParticles.size();
    nPFPnu = nuParticles.size();
    nPFPnuTrack = tracks.size();
    nPFPnuShower = showers.size();
    t_pandora->Fill();
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get PFParticle information////////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get CRT hit information /////////////////////////////////////////////////////////////////////////////////////
    art::Handle< std::vector<crt::CRTHit> > rawHandle_hits;
    evt.getByLabel(data_label_hits_, rawHandle_hits); //what is the product instance name? no BernZMQ
    int hits_valid=1;
    //check to make sure the data we asked for is valid                                                                                                      
    if(!rawHandle_hits.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[31m" << "zero" << "\033[0m"
                << " CRTHits " << " in module " << data_label_hits_ << std::endl;
      std::cout << std::endl;
      hits_valid=0;
      //return;
    }
    if(hits_valid!=0){
      //get better access to the data               
      std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_hits);
      if(rawHandle_hits.isValid()){
        std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                  << ", event " << evt.event() << " has " << "\033[32m" << CRTHitCollection.size() << "\033[0m"
                  << " CRTHits " << " in module " << data_label_hits_ << std::endl;
       // std::cout << std::endl;
       //return;
      }
      for(std::vector<int>::size_type i = 0; i != CRTHitCollection.size(); i++) {//A 
        //printf("Processing %ld hit\n", i);
        crt::CRTHit my_CRTHit = CRTHitCollection[i];
        fill_tcrthit(my_CRTHit);
      }//A
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get CRT hit information /////////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get CRT track information ///////////////////////////////////////////////////////////////////////////////////
    art::Handle< std::vector<crt::CRTTrack> > rawHandle_tracks;
    evt.getByLabel(data_label_tracks_, rawHandle_tracks); //what is the product instance name? no BernZMQ
    int tracks_valid=1;
    //check to make sure the data we asked for is valid                                                                                                      
    if(!rawHandle_tracks.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[31m" << "zero" << "\033[0m"
                << " CRTTracks " << " in module " << data_label_tracks_ << std::endl;
      std::cout << std::endl;
      tracks_valid=0;
      //return;
    }
    //get better access to the data   
    if(tracks_valid!=0){
      std::vector<crt::CRTTrack> const& CRTTrackCollection(*rawHandle_tracks);
      if(rawHandle_tracks.isValid()){
        std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                  << ", event " << evt.event() << " has " << "\033[32m" << CRTTrackCollection.size() << "\033[0m"
                  << " CRTTracks " << " in module " << data_label_tracks_ << std::endl;
        //std::cout << std::endl;
        //return;
      }
      for(std::vector<int>::size_type i = 0; i != CRTTrackCollection.size(); i++) {//A 
        //printf("Processing %ld track\n", i);
        crt::CRTTrack my_CRTTrack = CRTTrackCollection[i];
        fill_tcrttrack(my_CRTTrack);
      }//A
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get CRT track information ///////////////////////////////////////////////////////////////////////////////
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get PMT flash information ///////////////////////////////////////////////////////////////////////////////////
    frunNum    = evt.run();
    fsubRunNum = evt.subRun();
    fEvtNum = evt.event();

    //art::Timestamp evtTime = evt.time();
    //auto evt_time_sec = evtTime.timeHigh();
    //auto evt_time_nsec = evtTime.timeLow();

    //get DAQ Header
    art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;
    evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
    if(!rawHandle_DAQHeader.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has zero"
                << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;
      return;
    }  
    
    raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);

    art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();  
    double evt_timeGPS_sec = evtTimeGPS.timeHigh();
    double evt_timeGPS_nsec = evtTimeGPS.timeLow();
    fTriTim_sec = evtTimeGPS.timeHigh();
    fTriTim_nsec = evtTimeGPS.timeLow();

    //art::Timestamp evtTimeNTP = my_DAQHeader.ntp_time();  
    //double evt_timeNTP_sec = evtTimeNTP.timeHigh();
    //double evt_timeNTP_nsec = evtTimeNTP.timeLow();

    //double timstp_diff = std::abs(evt_timeGPS_nsec - evt_timeNTP_nsec);
    //htmstp_diff->Fill(timstp_diff);
    //htmstp_diff_vs_event->Fill(fEvtNum,timstp_diff);
    
    //get Optical Flash
    art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlash;
    evt.getByLabel(data_label_flash_, rawHandle_OpFlash);

    std::vector<recob::OpFlash> const& OpFlashCollection(*rawHandle_OpFlash);
    
    //get Optical Flash
    NrFlash = OpFlashCollection.size();
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has " << "\033[32m" << OpFlashCollection.size() << "\033[0m"
              << " TPCFlashes " << " in module " << data_label_flash_ << std::endl;
    for(std::vector<int>::size_type iij = 0; iij != OpFlashCollection.size(); iij++) {//A

      recob::OpFlash my_OpFlash = OpFlashCollection[iij];

      auto Timeflash = my_OpFlash.Time(); //in us from trigger time
      //hFlashTimeDis->Fill(Timeflash);      

      fY = my_OpFlash.YCenter();
      fZ = my_OpFlash.ZCenter();
      fPEflash = my_OpFlash.TotalPE();
      fTimFla = my_OpFlash.Time();
      fAbsTimFla = (evt_timeGPS_sec*1e9) + evt_timeGPS_nsec + (Timeflash * 1000);
      fbeam = my_OpFlash.OnBeamTime();
      //std::cout << "Filling..." << fY << std::endl;
      //if(abs(hit_time_s*1e9+hit_time_ns-fAbsTimFla)<1e5) my_flashhits->Fill();
      if(saveTTree_ == 1) t_flash->Fill();
    }//A
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // end get PMT flash information ///////////////////////////////////////////////////////////////////////////////
    


  }

  void CRTtoTTree::GetPFParticleIdMap(const PFParticleHandle &pfParticleHandle, PFParticleIdMap &pfParticleMap)
  {
      for (unsigned int i = 0; i < pfParticleHandle->size(); ++i)
      {
          const art::Ptr<recob::PFParticle> pParticle(pfParticleHandle, i);
          if (!pfParticleMap.insert(PFParticleIdMap::value_type(pParticle->Self(), pParticle)).second)
          {
              throw cet::exception("crt_ana") << "  Unable to get PFParticle ID map, the input PFParticle collection has repeat IDs!";
          }
      }
  }


  void CRTtoTTree::GetFinalStatePFParticleVectors(const PFParticleIdMap &pfParticleMap, PFParticleVector &crParticles, PFParticleVector &nuParticles)
  {
      for (PFParticleIdMap::const_iterator it = pfParticleMap.begin(); it != pfParticleMap.end(); ++it)
      {
          const art::Ptr<recob::PFParticle> pParticle(it->second);

          // Only look for primary particles
          if (!pParticle->IsPrimary()) continue;

          // Check if this particle is identified as the neutrino
          const int pdg(pParticle->PdgCode());
          const bool isNeutrino(std::abs(pdg) == pandora::NU_E || std::abs(pdg) == pandora::NU_MU || std::abs(pdg) == pandora::NU_TAU);

          // All non-neutrino primary particles are reconstructed under the cosmic hypothesis
          if (!isNeutrino)
          {
              crParticles.push_back(pParticle);
              continue;
          }

          // ATTN. We are filling nuParticles under the assumption that there is only one reconstructed neutrino identified per event.
          //       If this is not the case please handle accordingly
          if (!nuParticles.empty())
          {
              throw cet::exception("crt_ana") << "  This event contains multiple reconstructed neutrinos!";
          }

          // Add the daughters of the neutrino PFParticle to the nuPFParticles vector
          for (const size_t daughterId : pParticle->Daughters())
          {
              if (pfParticleMap.find(daughterId) == pfParticleMap.end())
                  throw cet::exception("crt_ana") << "  Invalid PFParticle collection!";

              nuParticles.push_back(pfParticleMap.at(daughterId));
          }
      }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void CRTtoTTree::CollectTracksAndShowers(const PFParticleVector &particles, const PFParticleHandle &pfParticleHandle, const art::Event &evt, TrackVector &tracks, ShowerVector &showers)
  {
      // Get the associations between PFParticles and tracks/showers from the event

      //std::string m_trackLabel = "";           ///< The label for the track producer from PFParticles
      //std::string m_showerLabel = "";

      art::FindManyP< recob::Track > pfPartToTrackAssoc(pfParticleHandle, evt, m_trackLabel);
      art::FindManyP< recob::Shower > pfPartToShowerAssoc(pfParticleHandle, evt, m_showerLabel);

      for (const art::Ptr<recob::PFParticle> &pParticle : particles)
      {
          const std::vector< art::Ptr<recob::Track> > associatedTracks(pfPartToTrackAssoc.at(pParticle.key()));
          const std::vector< art::Ptr<recob::Shower> > associatedShowers(pfPartToShowerAssoc.at(pParticle.key()));
          const unsigned int nTracks(associatedTracks.size());
          const unsigned int nShowers(associatedShowers.size());

          // Check if the PFParticle has no associated tracks or showers
          if (nTracks == 0 && nShowers == 0)
          {
              mf::LogDebug("crt_ana") << "  No tracks or showers were associated to PFParticle " << pParticle->Self() << std::endl;
              continue;
          }

          // Check if there is an associated track
          if (nTracks == 1 && nShowers == 0)
          {
              tracks.push_back(associatedTracks.front());
              continue;
          }

          // Check if there is an associated shower
          if (nTracks == 0 && nShowers == 1)
          {
              showers.push_back(associatedShowers.front());
              continue;
          }

          throw cet::exception("crt_ana") << "  There were " << nTracks << " tracks and " << nShowers << " showers associated with PFParticle " << pParticle->Self();
      }
  }

  void CRTtoTTree::initialize_tcrthits()
  {
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for hits" << std::endl;
    //tree stuff for hits: //////////////////////////////////////////////////////////////////////////////////
    my_hits_ = tfs->make<TTree>("my_hits","CRT hit Tree");
    my_hits_->Branch("feb_id1",&feb_id1,"FEB Nr 1/I");
    my_hits_->Branch("feb_id2",&feb_id2,"FEB Nr 2/I");
    my_hits_->Branch("hit_time_s", &hit_time_s, "time (s)/D");
    my_hits_->Branch("hit_time_s_err", &hit_time_s_err, "time error (s)/D");
    my_hits_->Branch("hit_time_ns", &hit_time_ns, "time (ns)/D");
    my_hits_->Branch("hit_time_ns_err", &hit_time_ns_err, "time error (ns)/D");
    my_hits_->Branch("beam_time_ns", &beam_time_ns, "beam time (ns)/D");
    my_hits_->Branch("beam_time_ns_err", &beam_time_ns_err, "beam time error (ns)/D");
    my_hits_->Branch("CRTplane", &plane, "(0=Bot, 1=FT, 2=PS, 3=Top)/i");
    my_hits_->Branch("peshit", &peshit, "peshit/D");
    my_hits_->Branch("Xreco", &xtot, "Xreco (cm)/D");
    my_hits_->Branch("Yreco", &ytot, "Yreco (cm)/D");
    my_hits_->Branch("Zreco", &ztot, "Zreco (cm)/D");
    my_hits_->Branch("Xerr", &xerr, "Xerr (cm)/D");
    my_hits_->Branch("Yerr", &yerr, "Yerr (cm)/D");
    my_hits_->Branch("Zerr", &zerr, "Zerr (cm)/D");

    my_hits_->Branch("event_flag",&event_flag,"event_flag 1/I");
    my_hits_->Branch("lostcpu1",&lostcpu1,"lostcpu1/I");
    my_hits_->Branch("lostcpu2",&lostcpu2,"lostcpu2/I");
    my_hits_->Branch("lostfpga1",&lostfpga1,"lostfpga1/I");
    my_hits_->Branch("lostfpga2",&lostfpga2,"lostfpga2/I");
    //quality plots for hits:  /////////////////////////////////////////////////////////////////////////////////
     double inch =2.54; //inch in cm 
    HitDistBot = tfs->make<TH2F>("hBottom","Bottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
    HitDistBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    HitDistBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
    HitDistBot->GetZaxis()->SetTitle("Entries/bin");
    HitDistBot->SetOption("COLZ");

    HitDistFT = tfs->make<TH2F>("hFeedthroughSide","Feedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
    HitDistFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    HitDistFT->GetYaxis()->SetTitle("Height (cm)");
    HitDistFT->GetZaxis()->SetTitle("Entries/bin");
    HitDistFT->SetOption("COLZ");

    HitDistPipe = tfs->make<TH2F>("hPipeSide","Pipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
    HitDistPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    HitDistPipe->GetYaxis()->SetTitle("Height (cm)");
    HitDistPipe->GetZaxis()->SetTitle("Entries/bin");
    HitDistPipe->SetOption("COLZ");

    HitDistTop = tfs->make<TH2F>("hTop","Top",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
    HitDistTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    HitDistTop->GetYaxis()->SetTitle("Lenght along the drift (cm)"); 
    HitDistTop->GetZaxis()->SetTitle("Entries/bin"); 
    HitDistTop->SetOption("COLZ");

    FEBvsFEB = tfs->make<TH2F>("hFEBvsFEB","FEBvsFEB",130,0,130,130,0,130);
    FEBvsFEB->GetXaxis()->SetTitle("FEB ID");
    FEBvsFEB->GetYaxis()->SetTitle("FEB ID");
    FEBvsFEB->SetOption("COLZ");

    BeamTime = tfs->make<TH1F>("hBeamEvents","ts1 + offset",250,0,25000);
    BeamTime->GetXaxis()->SetTitle("Time after Beam (ns)");
    BeamTime->GetYaxis()->SetTitle("Entries/bin");

    hxtot = tfs->make<TH1F>("hxtot","xtot",70000,-200,500);
    hxtot->GetXaxis()->SetTitle("Reconstructed X (cm)");
    hxtot->GetYaxis()->SetTitle("Entries/bin");

    hytot = tfs->make<TH1F>("hytot","ytot",60000,-300,300);
    hytot->GetXaxis()->SetTitle("Reconstructed Y (cm)");
    hytot->GetYaxis()->SetTitle("Entries/bin");

    hztot = tfs->make<TH1F>("hztot","ztot",130000,-100,1200);
    hztot->GetXaxis()->SetTitle("Reconstructed Z (cm)");
    hztot->GetYaxis()->SetTitle("Entries/bin");

    hPEShit = tfs->make<TH1F>("hPEShit","PEShit",500,0,500);
    hPEShit->GetXaxis()->SetTitle(" peshit");
    hPEShit->GetYaxis()->SetTitle("Entries/bin");

    //hEvPerSec = tfs->make<TH2F>("hEvPerSec","Events per second",14400,0,14400,200,0,200);
    //hEvPerSec->GetXaxis()->SetTitle("Time [sec]");
    //hEvPerSec->GetYaxis()->SetTitle("FEB ID");
    //hEvPerSec->GetZaxis()->SetTitle("Entries/bin");
    //hEvPerSec->SetOption("COLZ");
    // hit stuff ends here ////////////////////////////////////////////////////////////////////////
  }

  void CRTtoTTree::initialize_tcrttracks()
  {
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for tracks" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    my_tracks_ = tfs->make<TTree>("my_tracks","CRT Tree");
    my_tracks_->Branch("x1", &x1, "x1 (cm)/D");
    my_tracks_->Branch("y1", &y1, "y1 (cm)/D");
    my_tracks_->Branch("z1", &z1, "z1 (cm)/D");
    my_tracks_->Branch("x2", &x2, "x2 (cm)/D");
    my_tracks_->Branch("y2", &y2, "y2 (cm)/D");
    my_tracks_->Branch("z2", &z2, "z2 (cm)/D");
    my_tracks_->Branch("x1_err", &x1_err, "x1_err (cm)/D");
    my_tracks_->Branch("y1_err", &y1_err, "y1_err (cm)/D");
    my_tracks_->Branch("z1_err", &z1_err, "z1_err (cm)/D");
    my_tracks_->Branch("x2_err", &x2_err, "x2_err (cm)/D");
    my_tracks_->Branch("y2_err", &y2_err, "y2_err (cm)/D");
    my_tracks_->Branch("z2_err", &z2_err, "z2_err (cm)/D");
    my_tracks_->Branch("plane1", &plane1, "plane1/I");
    my_tracks_->Branch("plane2", &plane2, "plane2/I");
    my_tracks_->Branch("track_time_s", &track_time_s, "time (s)/D");
    my_tracks_->Branch("track_time_ns", &track_time_ns, "time (ns)/D");
    my_tracks_->Branch("track_length", &length, "Track lenght (cm)/D");
    my_tracks_->Branch("track_timdiff", &time_diff, "Time_diff (ns)/D");
    my_tracks_->Branch("track_theta", &theta, "Theta_xy (º)/D");
    my_tracks_->Branch("track_phi", &phi, "Phi_xy (º)/D");

    my_tracks_->Branch("track_time_1ns", &track_time_1ns, "time1 (ns)/D");
    my_tracks_->Branch("track_time_1ns_err", &track_time_1ns_err, "time1 error (ns)/D");
    my_tracks_->Branch("track_time_2ns", &track_time_2ns, "time2 (ns)/D");
    my_tracks_->Branch("track_time_2ns_err", &track_time_2ns_err, "time2 error (ns)/D");

    hplavspla = tfs->make<TH2F>("hplavspla","PlanevsPlane",4,0,4,4,0,4);
    hplavspla->GetXaxis()->SetTitle("Plane (0=Bottom, 1=FT, 2=Pipe, 3=Top)");
    hplavspla->GetYaxis()->SetTitle("Plane (0=Bottom, 1=FT, 2=Pipe, 3=Top)");
    hplavspla->GetZaxis()->SetTitle("Entries/bin");
    hplavspla->SetOption("COLZ");

    hTvsH = tfs->make<TH2F>("hTvsH","Track_vs_Hits",500,0,500,500,0,500);
    hTvsH->GetXaxis()->SetTitle("Number of CRTHits per event");
    hTvsH->GetYaxis()->SetTitle("Number of CRTTracks per event");
    hTvsH->GetZaxis()->SetTitle("Entries/bin");
    hTvsH->SetOption("COLZ");

    hTlength = tfs->make<TH1F>("hTlength","Track_Length",1500,0,1500);
    hTlength->GetXaxis()->SetTitle("Track_Length (cm)");
    hTlength->GetYaxis()->SetTitle("Entries/bin");

    hTtime = tfs->make<TH1F>("hTtime","Track_time",120,-10,110);
    hTtime->GetXaxis()->SetTitle("Track_time (ns)");
    hTtime->GetYaxis()->SetTitle("Entries/bin");

    hTlengthvsTime = tfs->make<TH2F>("hTlengthvsTime","Track_LengthvsTime",1500,0,1500,200,-100,100);
    hTlengthvsTime->GetXaxis()->SetTitle("Track_Length (cm)");
    hTlengthvsTime->GetYaxis()->SetTitle("Track_time (ns)");
    hTlengthvsTime->GetZaxis()->SetTitle("Entries/bin");
    hTlengthvsTime->SetOption("COLZ");

    hTlengthvsTimeAbs = tfs->make<TH2F>("hTlengthvsTimeAbs","Track_LengthvsTimeAbs",1500,0,1500,110,-10,100);
    hTlengthvsTimeAbs->GetXaxis()->SetTitle("Track_Length (cm)");
    hTlengthvsTimeAbs->GetYaxis()->SetTitle("Track_time (ns)");
    hTlengthvsTimeAbs->GetZaxis()->SetTitle("Entries/bin");
    hTlengthvsTimeAbs->SetOption("COLZ");

    hTlengthvsTimeAbs_prof = tfs->make<TProfile>("hTlengthvsTimeAbs_prof","Track_LengthvsTimeAbs_prof",1500,0,1500,"s");
    hTlengthvsTimeAbs_prof->GetXaxis()->SetTitle("Track_Length (cm)");
    hTlengthvsTimeAbs_prof->GetYaxis()->SetTitle("Track_time (ns)");

    htheta = tfs->make<TH1F>("htheta","Track_theta",900,0,3.1415926);
    htheta->GetXaxis()->SetTitle("Theta_xy (º)");
    htheta->GetYaxis()->SetTitle("Entries/bin");

    hphi = tfs->make<TH1F>("hphi","Track_phi",900,0,3.1415926);
    hphi->GetXaxis()->SetTitle("Phi_zy (º)");
    hphi->GetYaxis()->SetTitle("Entries/bin");

    hts0_ns = tfs->make<TH1F>("hts0_ns","Track_time_ns",100000,0,1e9);
    hts0_ns->GetXaxis()->SetTitle("Track time (ns)");
    hts0_ns->GetYaxis()->SetTitle("Entries/bin");

    /*h_beta = tfs->make<TH1F>("h_beta","beta factor of tracks",1000,0,10);
    h_beta->GetXaxis()->SetTitle("Beta factor");
    h_beta->GetYaxis()->SetTitle("Entries/bin");

    hMumomentum = tfs->make<TH1F>("hMumomentum","muon momentum",1000,0,10000);
    hMumomentum->GetXaxis()->SetTitle("MeV");
    hMumomentum->GetYaxis()->SetTitle("Entries/bin");*/

    double inch =2.54; //inch in cm                                                                                                                          
    TrackDistBot = tfs->make<TH2F>("hTBottom","TBottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
    TrackDistBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    TrackDistBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
    TrackDistBot->GetZaxis()->SetTitle("Entries/bin");
    TrackDistBot->SetOption("COLZ");

    TrackDistFT = tfs->make<TH2F>("hTFeedthroughSide","TFeedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
    TrackDistFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    TrackDistFT->GetYaxis()->SetTitle("Height (cm)");
    TrackDistFT->GetZaxis()->SetTitle("Entries/bin");
    TrackDistFT->SetOption("COLZ");

    TrackDistPipe = tfs->make<TH2F>("hTPipeSide","TPipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
    TrackDistPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    TrackDistPipe->GetYaxis()->SetTitle("Height (cm)");
    TrackDistPipe->GetZaxis()->SetTitle("Entries/bin");
    TrackDistPipe->SetOption("COLZ");

    TrackDistTop = tfs->make<TH2F>("hTTop","TTop",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
    TrackDistTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
    TrackDistTop->GetYaxis()->SetTitle("Lenght along the drift (cm)");
    TrackDistTop->GetZaxis()->SetTitle("Entries/bin");
    TrackDistTop->SetOption("COLZ");

  }
  void CRTtoTTree::fill_tcrthit( crt::CRTHit my_CRTHit )
  {

        feb_id1=my_CRTHit.feb_id[0];
        feb_id2=my_CRTHit.feb_id[1];

        //if (first_sec < 1e6) first_sec = my_CRTHit.ts0_s;
        //event_flag=my_CRTHit.event_flag;

        //lostcpu1=my_CRTHit.lostcpu_map.find(my_CRTHit.feb_id[0])->second;
        //lostcpu2=my_CRTHit.lostcpu_map.find(my_CRTHit.feb_id[1])->second;
        //lostfpga1=my_CRTHit.lostfpga_map.find(my_CRTHit.feb_id[0])->second;
        //lostfpga2=my_CRTHit.lostfpga_map.find(my_CRTHit.feb_id[1])->second;

        hit_time_s = my_CRTHit.ts0_s;	
        //hit_time_s_err = my_CRTHit.ts0_s_err;

        hit_time_ns = my_CRTHit.ts0_ns;
        //hit_time_ns_err = my_CRTHit.ts0_ns_err;

        beam_time_ns = my_CRTHit.ts1_ns;
        //beam_time_ns_err = my_CRTHit.ts1_ns_err;

        plane = my_CRTHit.plane;
        peshit = my_CRTHit.peshit;

        xtot = my_CRTHit.x_pos;
        xerr = my_CRTHit.x_err;
        ytot = my_CRTHit.y_pos;
        yerr = my_CRTHit.y_err;
        ztot = my_CRTHit.z_pos;
        zerr = my_CRTHit.z_err;

        //hEvPerSec->Fill(hit_time_s-first_sec, feb_id1);
        //hEvPerSec->Fill(hit_time_s-first_sec, feb_id2);

        if(saveTTree_ == 1) my_hits_->Fill();

        hPEShit->Fill(peshit);
        FEBvsFEB->Fill(feb_id1,feb_id2);
        BeamTime->Fill(beam_time_ns);
        hxtot->Fill(xtot);
        hytot->Fill(ytot);
        hztot->Fill(ztot);
        if(plane==0){HitDistBot->Fill(ztot,xtot);}                                               
        if(plane==1){HitDistFT->Fill(ztot, ytot);}
        if(plane==2){HitDistPipe->Fill(ztot, ytot);}
        if(plane==3){HitDistTop->Fill(ztot,xtot);}     
  }
  void CRTtoTTree::fill_tcrttrack( crt::CRTTrack my_CRTTrack ){

        //std::cout << "length of feb id vector: " << my_CRTTrack.feb_id.size() <<std::endl;
        /*feb_id01 = my_CRTTrack.feb_id[0];
        feb_id02 = my_CRTTrack.feb_id[1];
        feb_id03 = my_CRTTrack.feb_id[2];
        feb_id04 = my_CRTTrack.feb_id[3];*/
        //printf("Read FEB id %ld track\n", i);
        track_time_ns = my_CRTTrack.ts0_ns;
        track_time_s = my_CRTTrack.ts0_s;
        track_time_ns_err = my_CRTTrack.ts0_ns_err;
        track_time_s_err = my_CRTTrack.ts0_s_err;
        track_beam_ns = my_CRTTrack.ts1_ns;
        //track_beam_ns_err = my_CRTTrack.ts1_ns_err;
        time_diff = my_CRTTrack.ts0_ns_h1 - my_CRTTrack.ts0_ns_h2;
        track_time_1ns =  my_CRTTrack.ts0_ns_h1;
        track_time_1ns_err =  my_CRTTrack.ts0_ns_err_h1;
        track_time_2ns =  my_CRTTrack.ts0_ns_h2;
        track_time_2ns_err =  my_CRTTrack.ts0_ns_err_h2;
        //printf("Read times %ld track\n", i);
        length = my_CRTTrack.length;
        theta = my_CRTTrack.thetaxy;
        phi = my_CRTTrack.phizy;
        x1 = my_CRTTrack.x1_pos;
        x1_err = my_CRTTrack.x1_err;;
        x2 = my_CRTTrack.x2_pos;
        x2_err = my_CRTTrack.x2_err;
        y1 = my_CRTTrack.y1_pos;
        y1_err = my_CRTTrack.y1_err;
        y2 = my_CRTTrack.y2_pos;
        y2_err = my_CRTTrack.y2_err;
        z1 = my_CRTTrack.z1_pos;
        z1_err = my_CRTTrack.z1_err;
        z2 = my_CRTTrack.z2_pos;
        z2_err = my_CRTTrack.z2_err;
        
        plane1 = my_CRTTrack.plane1;
        plane2 = my_CRTTrack.plane2;

        hplavspla->Fill(plane1,plane2);	
        hTlength->Fill(length);
        hTtime->Fill(std::abs(time_diff));
        hTlengthvsTimeAbs->Fill(length,std::abs(time_diff));
        hTlengthvsTimeAbs_prof->Fill(length,std::abs(time_diff));
        hTlengthvsTime->Fill(length,time_diff);
        htheta->Fill(theta);
        hphi->Fill(phi);
        hts0_ns->Fill(track_time_ns);
        //printf("Filled histos %ld track\n", i);
        if(plane1==0){
          TrackDistBot->Fill(z1,x1);
        }
        if(plane1==1){
          TrackDistFT->Fill(z1, y1);
        }
        if(plane1==2){
          TrackDistPipe->Fill(z1, y1);
        }
        if(plane1==3){
          TrackDistTop->Fill(z1,x1);
        }
        if(plane2==0){
          TrackDistBot->Fill(z2,x2);
        }
        if(plane2==1){
          TrackDistFT->Fill(z2, y2);
        }
        if(plane2==2){
          TrackDistPipe->Fill(z2, y2);
        }
        if(plane2==3){
          TrackDistTop->Fill(z2,x2);
        }
        //plane1;
        //plane2;
        pestrack = my_CRTTrack.peshit;

        if(saveTTree_ == 1) my_tracks_->Fill();
        //printf("End %ld track\n", i);
  }

  void CRTtoTTree::initialize_tpandora()
  {
    // Implementation of optional member function here.
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for pandora consolidated output" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    t_pandora = tfs->make<TTree>("t_pandora","t_pandora");
    t_pandora->Branch("nPFPcosmic", &nPFPcosmic, "Number of Cosmic PFparticles/I");
    t_pandora->Branch("nPFPnu", &nPFPnu, "Number of nu PFparticles/I");
    t_pandora->Branch("nPFPnuTrack", &nPFPnuTrack, "Number of track like nu PFparticles/I");
    t_pandora->Branch("nPFPnuShower", &nPFPnuShower, "Number of Shower like nu PFparticles/I");

  }
  
  void CRTtoTTree::initialize_tflash()
  {
    // Implementation of optional member function here.
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for flash output" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    t_flash = tfs->make<TTree>("flash_tree","Flash_Tree");
    t_flash->Branch("event", &fEvtNum, "event/I");
    t_flash->Branch("beam", &fbeam, "beam/I");
    t_flash->Branch("trigger_ts", &fTriTim_sec, "Time (s)/I");
    t_flash->Branch("trigger_tns", &fTriTim_nsec, "Time (ns)/I");
    t_flash->Branch("Y_reco", &fY, "Y (cm)/D");
    t_flash->Branch("Z_reco", &fZ, "Z (cm)/D");
    t_flash->Branch("N_PE", &fPEflash, "Photoelectrons/D");
    t_flash->Branch("T_flash", &fTimFla, "Flash time w.r.t trigger (us)/D");
    t_flash->Branch("Abs_T_flash", &fAbsTimFla, "Absolute flash time (ns)/D");

  }

  void CRTtoTTree::beginJob()
  {
    // Implementation of optional member function here.
    initialize_tpandora();
    initialize_tcrthits();
    initialize_tcrttracks();
    initialize_tflash();
    //initialize_tracks();

  }
  void CRTtoTTree::endJob()
  {
    // Implementation of optional member function here.
  }
  DEFINE_ART_MODULE(CRTtoTTree)
}