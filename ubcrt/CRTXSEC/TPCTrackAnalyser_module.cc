////////////////////////////////////////////////////////////////////////
// Class:       TPCTrackAnalyser
// Module Type: analyzer
// File:        TPCTrackAnalyser_module.cc
//
// Generated at Mon Nov 19 03:49:01 2018 by Thomas Mettler using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"

#include "art/Persistency/Common/PtrMaker.h"
//#include "PtrMaker.h"

//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTzero.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

#include "ubcrt/CRTXSEC/CRTAnaFun.hh"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h" 
#include "lardataobj/AnalysisBase/ParticleID.h" 
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"
#include "Pandora/PdgTable.h"

#include "TTree.h"
#include "TBenchmark.h"
#include "TRandom.h"
#include "TSystem.h"
#include "TClonesArray.h"
#include "TObject.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>

#define LIGHTSPEED 299792458.0 // m/s
#define MASS_MU 105.6583745 // MeV

//namespace lar_pandora
//{
namespace crt {

class TPCTrackAnalyser;

class TPCTrackAnalyser : public art::EDAnalyzer {
public:
  explicit TPCTrackAnalyser(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TPCTrackAnalyser(TPCTrackAnalyser const &) = delete;
  TPCTrackAnalyser(TPCTrackAnalyser &&) = delete;
  TPCTrackAnalyser & operator = (TPCTrackAnalyser const &) = delete;
  TPCTrackAnalyser & operator = (TPCTrackAnalyser &&) = delete;



  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;


private:

  // Declare member data here.
  art::ServiceHandle<art::TFileService> tfs;

  TTree * my_event_;
  TTree * my_hitasso_;
  std::vector<crt::CRTHit> crthit_vec;
  std::vector<crt::CRTTrack> crttrack_vec;
  std::vector<crt::CRTTzero> crtt0_vec;
  int crthit_counter;
  int crttrack_counter;
  int crtt0_counter;
  
  std::vector<anab::CosmicTag> cosmictag_vec;
  std::vector<anab::T0> t0_vec;
  std::vector<anab::ParticleID> particleid_vec;
  int cosmictag_counter = 0;
  int t0_counter = 0;
  int particleid_counter = 0;
  int track_counter = 0;
  int event_counter = 0;
  
  //crt::CRTHit crthit_match;
  //crt::CRTTrack crttrack_match;
  recob::Track tpctrack_match;
  double tpc_crthit_dist;
  double track_length;
  uint32_t fEvtNum; //Number of current event                       
  uint32_t frunNum;                //Run Number taken from event  
  uint32_t fsubRunNum;             //Subrun Number taken from event 
  
  double fTriTim_sec = 0;
  double fTriTim_nsec = 0;
  double fAbsTimFla = 0;
  
  double crthit_ts0 = 0;
  double crttrack_ts0 = 0;

  // data lables from fcl file/////////////////////////////////////////////////////////
  //std::string m_pandoraLabel;         ///< The label for the pandora producer
  //std::string m_trackLabel;           ///< The label for the track producer from PFParticles
  //std::string m_showerLabel;          ///< The label for the shower producer from PFParticles
  int verbose_;
  //int numberOfevents_;
  std::string data_label_assohits_;
  std::string data_label_assotracks_; 
  std::string data_label_assoCRTT0_;
  
  std::string data_label_assoT0_;
  std::string data_label_assoPID_;
  std::string data_label_assoCosmictag_;
  
  int saveTTree_;
  //std::string  data_label_flash_;
  //std::string  data_label_flash_beam_;
  //std::string  data_label_track_flash_;
  std::string  data_label_DAQHeader_;
  std::string  data_label_TPCTrack_;
  std::string  data_label_TPCTrack2_;
  std::string data_label_CRTtzero_;
  //std::string  data_label_T0reco_;
  //std::string  data_label_Calorimetry_;
  int fHardDelay_;
  int fCRTT0off_;
  double fvdrift_;
  double crthitmatch_;

  int match_counter = 0;

  // functions ////////////////////////////////////////////////////////////////////////////////////////
  //void initialize_tpandora();
  void initialize_tmyevent();
  //void initialize_tmy_hitasso();
};

//}

//namespace lar_pandora
//{
TPCTrackAnalyser::TPCTrackAnalyser(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset)  // ,
 // More initializers here.

{
  //m_pandoraLabel = pset.get<std::string>("PandoraLabel");
  //m_trackLabel = pset.get<std::string>("TrackLabel");
  //m_showerLabel = pset.get<std::string>("ShowerLabel");
  //m_printOutScores = pset.get<bool>("PrintOutScores",true);
  verbose_ = pset.get<int>("verbose");
  //numberOfevents_ = pset.get<int>("Number_of_Events");
  data_label_assohits_ = pset.get<std::string>("data_label_assohits");
  data_label_assoCRTT0_ = pset.get<std::string>("data_label_assoCRTT0");
  data_label_assotracks_ = pset.get<std::string>("data_label_assotracks");
    
  data_label_assoT0_ = pset.get<std::string>("data_label_assoT0");
  data_label_assoPID_ = pset.get<std::string>("data_label_assoPID");
  data_label_assoCosmictag_ = pset.get<std::string>("data_label_assoCosmictag");

  //data_label_flash_ = pset.get<std::string>("data_label_flash");
  //data_label_flash_beam_ = pset.get<std::string>("data_label_flash_beam");
  //data_label_track_flash_ = pset.get<std::string>("data_label_track_flash");
  data_label_DAQHeader_ = pset.get<std::string>("data_label_DAQHeader");
  data_label_TPCTrack_ = pset.get<std::string>("data_label_TPCTrack");
  data_label_TPCTrack2_ = pset.get<std::string>("data_label_TPCTrack2");
  data_label_CRTtzero_ = pset.get<std::string>("data_label_CRTtzero");
  //data_label_T0reco_ = pset.get<std::string>("data_label_T0reco");
  //data_label_Calorimetry_ = pset.get<std::string>("data_label_Calorimetry");

  fHardDelay_ = pset.get<int>("fHardDelay",40000);
  fCRTT0off_ = pset.get<int>("fCRTT0off",69000);
  fvdrift_ = pset.get<double>("fvdrift",0.111436);
  crthitmatch_ = pset.get<double>("crthitmatch",1.00);

  saveTTree_ = pset.get<int>("saveTTree");
}

void TPCTrackAnalyser::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  std::cout << "Prozessing event nr: " << event_counter << std::endl;
  if(verbose_!=0) std::cout << "Run " << evt.run() << ", subrun " << evt.subRun() << std::endl;
  frunNum    = evt.run();
  fsubRunNum = evt.subRun();
  fEvtNum = evt.event();
  event_counter++;
  
  art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;
  evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);

  //check to make sure the data we asked for is valid                                                                                          
  if(!rawHandle_DAQHeader.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;
    return;
  }  

  raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);

  art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();  
  double evt_timeGPS_sec = evtTimeGPS.timeHigh();
  double evt_timeGPS_nsec = evtTimeGPS.timeLow();
  fTriTim_sec = evtTimeGPS.timeHigh();
  fTriTim_nsec = evtTimeGPS.timeLow();
  
  
  /*crt::CRTTzero my_crtt0;
  anab::T0 my_t0;
  anab::CosmicTag my_cosmictag;
  anab::ParticleID my_particleid;
  std::cout << "Size of my_crtt0: " << sizeof(my_crtt0) << std::endl;
  std::cout << "Size of my_t0: " << sizeof(my_t0) << std::endl;
  std::cout << "Size of my_cosmictag: " << sizeof(my_cosmictag) << std::endl;
  std::cout << "Size of my_particleid: " << sizeof(my_particleid) << std::endl;*/

  art::Handle< std::vector<recob::Track> > rawHandle_TPCtrack;
  evt.getByLabel(data_label_TPCTrack_, rawHandle_TPCtrack);
  
  //check to make sure the data we asked for is valid                                                                                                     
  std::vector<recob::Track> const& TPCTrackCollection(*rawHandle_TPCtrack);    
  //std::cout<<"  TPCTrackCollection.size()  "<<TPCTrackCollection.size()<<std::endl;

  if(!rawHandle_TPCtrack.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " recob::Track " << " in module " << data_label_TPCTrack_ << std::endl;
    std::cout << std::endl;
    return;
  }
  // use only an additional raw handel if the data labe for tracks is different
  // depending which association (track - track // track - hit) is used
  art::Handle< std::vector<recob::Track> > rawHandle_TPCtrack2;
  evt.getByLabel(data_label_TPCTrack2_, rawHandle_TPCtrack2);

  art::Handle< std::vector<crt::CRTTzero> > rawHandle_CRTtzero;
  evt.getByLabel(data_label_CRTtzero_, rawHandle_CRTtzero);

  std::vector<crt::CRTTzero> const& CRTT0Collection(*rawHandle_CRTtzero);    
  //std::cout<<"  CRTT0Collection.size()  "<<CRTT0Collection.size()<<std::endl;
  // grab crt tracks objects associated with tracks   
  art::FindMany<crt::CRTTrack> trk_crttrack_assn_v(rawHandle_TPCtrack, evt, data_label_assotracks_);
  // to grab the crt hits associated to a tpc track we need to go over crt t0 objects
  // since the association is only between tpc tracks - crt t0 and crt t0 - crt hits
  art::FindMany<crt::CRTTzero> trk_crtT0_assn_v(rawHandle_TPCtrack, evt, data_label_assoCRTT0_);
  art::FindMany<crt::CRTHit> trk_crthit_assn_v(rawHandle_CRTtzero, evt, data_label_assohits_);
  
  art::FindMany<anab::ParticleID> trk_pid_assn_v(rawHandle_TPCtrack, evt, data_label_assoPID_);
  art::FindMany<anab::T0> trk_T0_assn_v(rawHandle_TPCtrack2, evt, data_label_assoT0_);
  art::FindMany<anab::CosmicTag> trk_cosmictag_assn_v(rawHandle_TPCtrack, evt, data_label_assoCosmictag_);
  

  for(std::vector<int>::size_type i = 0; i != TPCTrackCollection.size(); i++) {    //start loop over tpc tracks
    track_counter++;
    crthit_counter = 0;
    crttrack_counter = 0;
    crtt0_counter = 0;
    t0_counter = 0;
    cosmictag_counter = 0;
    particleid_counter = 0;
    crthit_ts0 = 0;
    crttrack_ts0 = 0;
    fAbsTimFla = 0;

    recob::Track my_TPCTrack = TPCTrackCollection[i]; 
    tpctrack_match = my_TPCTrack;
    track_length = tpctrack_match.Length();

    // get crt track associated to TPC track: //////////////////////////
    const std::vector<const crt::CRTTrack*>& CRTtrack_v = trk_crttrack_assn_v.at(i);
    if(CRTtrack_v.size()>0){
      auto crttrack_tmp = CRTtrack_v.at(0);
      if(verbose_!=0){
        std::cout << "found Track - CRT Track assoziation" << std::endl;
        std::cout << "Track time: " << crttrack_tmp->ts0_ns << std::endl;
        std::cout << "Track position 1: " << crttrack_tmp->x1_pos << ":" << crttrack_tmp->y1_pos << ":" << crttrack_tmp->z1_pos << std::endl;
        std::cout << "Track position 2: " << crttrack_tmp->x2_pos << ":" << crttrack_tmp->y2_pos << ":" << crttrack_tmp->z2_pos << std::endl;
      }
      //update the crt track tree variables
      crttrack_ts0 = crttrack_tmp->ts0_ns;
      crttrack_vec.push_back(*crttrack_tmp);
      crttrack_counter++;
    }

    // get crt hit associated to TPC track: ///////////////////////////
    // Since crt hits are associated to crt t0 objects and these are associated
    // to tpc tracks an additional step is needed
    const std::vector<const crt::CRTTzero*>& CRTtzero_v = trk_crtT0_assn_v.at(i);
    for(std::vector<int>::size_type j = 0; j != CRTtzero_v.size(); j++){
      if(verbose_!=0) std::cout << "found Track - CRT T0 assoziation" << std::endl;
      //get CRT t0 associated to tpc track and loop over all crt t0:
      auto crtT0_tmp = CRTtzero_v.at(j);
      crtt0_vec.push_back(*crtT0_tmp);
      crtt0_counter++;
      for(std::vector<int>::size_type i_t0 = 0; i_t0 != CRTT0Collection.size(); i_t0++){
        auto my_crtt0 = CRTT0Collection.at(i_t0);
        // take the crt t0 object from the event which is identical to the associated tpc track
        // and get the associated crt hits
        if( (crtT0_tmp->ts0_ns == my_crtt0.ts0_ns) && (crtT0_tmp->ts0_s == my_crtt0.ts0_s) ){
          //std::cout << "found rigth t0..." << std::endl;
          const std::vector<const crt::CRTHit*>& CRThit_v = trk_crthit_assn_v.at(i_t0);
          for(std::vector<int>::size_type i_hit = 0; i_hit != CRThit_v.size(); i_hit++){
            auto my_crthit = CRThit_v.at(i_hit);
            if(verbose_!=0){
              std::cout << "Hit time: " << my_crthit->ts0_ns << std::endl;
              std::cout << "Hit position: " << my_crthit->x_pos << ":" << my_crthit->y_pos << ":" << my_crthit->z_pos << std::endl;
            }
            //update the crt hit tree variables
            crthit_ts0 = my_crthit->ts0_ns;
            crthit_vec.push_back(*my_crthit);
            crthit_counter++;
          }
        }
      }
    }//end loop over crt t0
    // get the associated t0 objects
    const std::vector<const anab::T0*>& T0_v = trk_T0_assn_v.at(i);
    if(verbose_!=0) std::cout << "Size of t0: " << T0_v.size() << std::endl;
    for(std::vector<int>::size_type i_t0 = 0; i_t0 != T0_v.size(); i_t0++){
      auto my_t0 = T0_v.at(i_t0);
      if(verbose_!=0){
        //posible cout...
        //std::cout << "Hit time: " << my_crthit->ts0_ns << std::endl;
      }
      //update the crt hit tree variables
      auto Timeflash = my_t0->Time(); //in us from trigger time
      fAbsTimFla = (evt_timeGPS_sec*1e9) + evt_timeGPS_nsec + (Timeflash * 1000);
      t0_vec.push_back(*my_t0);
    }
    t0_counter = T0_v.size();
    
    // get the associated cosmictag object
    const std::vector<const anab::CosmicTag*>& CosmicTag_v = trk_cosmictag_assn_v.at(i);
    if(verbose_!=0) std::cout << "Size of cosmictag: " << CosmicTag_v.size() << std::endl;
    for(std::vector<int>::size_type i_cosmic = 0; i_cosmic != CosmicTag_v.size(); i_cosmic++){
      auto my_cosmictag = CosmicTag_v.at(i_cosmic);
      if(verbose_!=0){
        //posible cout...
        //std::cout << "Hit time: " << my_crthit->ts0_ns << std::endl;
      }
      //update the crt hit tree variables
      cosmictag_vec.push_back(*my_cosmictag);
    }
    cosmictag_counter = CosmicTag_v.size();
    
    // get the associated particle id object
    const std::vector<const anab::ParticleID*>& ParticleID_v = trk_pid_assn_v.at(i);
    if(verbose_!=0) std::cout << "Size of ParticleID: " << ParticleID_v.size() << std::endl;
    for(std::vector<int>::size_type i_pid = 0; i_pid != ParticleID_v.size(); i_pid++){
      auto my_pid = ParticleID_v.at(i_pid);
      if(verbose_!=0){
        //posible cout...
        //std::cout << "Hit time: " << my_crthit->ts0_ns << std::endl;
      }
      //update the crt hit tree variables
      particleid_vec.push_back(*my_pid);
    }
    particleid_counter = ParticleID_v.size();
    
    //fill the tree and reset the tree vectors
    my_event_->Fill();
    crthit_vec.clear();
    crttrack_vec.clear();
    crtt0_vec.clear();
    
    //tpctrack_match.clear();
    
    cosmictag_vec.clear();
    t0_vec.clear();
    particleid_vec.clear();
  }//end loop over tpc tracks

}

void TPCTrackAnalyser::initialize_tmyevent()
{
  // Implementation of optional member function here.
  std::cout << "Initialize variables and histograms for flash output" << std::endl;
  //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
  
  my_event_ = tfs->make<TTree>("my_event","my_event");
  int bufsize_crthit = 128*20;
  //int bufsize_flash = 152*1;
  int bufsize_crttrack = 184*5;
  int bufsize_track = 368*1;
  //int bufsize_shower = 336*1;
  //int bufsize_daqheader = 48;
  
  int bufsize_crtt0 = 72*10;
  int bufsize_t0 = 32*10;
  int bufsize_cosmictag = 56*10;//*10?
  int bufsize_particleid = 96*10;//*10?

  int splitlevel = 99;
  my_event_->Branch("crthits", &crthit_vec, bufsize_crthit, splitlevel);
  my_event_->Branch("crttracks", &crttrack_vec, bufsize_crttrack, splitlevel);
  my_event_->Branch("crtt0", &crtt0_vec, bufsize_crtt0, splitlevel);
  
  my_event_->Branch("cosmictag", &cosmictag_vec, bufsize_cosmictag, splitlevel);
  my_event_->Branch("t0", &t0_vec, bufsize_t0, splitlevel);
  my_event_->Branch("particleid", &particleid_vec, bufsize_particleid, splitlevel);
  
  my_event_->Branch("tpctracks", &tpctrack_match, bufsize_track, splitlevel);
  my_event_->Branch("distance", &tpc_crthit_dist, "distance cm/D");
  my_event_->Branch("track_length", &track_length, "track_length cm/D");
  
  my_event_->Branch("fTriTim_sec", &fTriTim_sec, "fTriTim_sec s/D");
  my_event_->Branch("fTriTim_nsec", &fTriTim_nsec, "fTriTim_nsec ns/D");
  my_event_->Branch("fAbsTimFla", &fAbsTimFla, "fAbsTimFla ns/D");
  
  my_event_->Branch("crttrack_ts0", &crttrack_ts0, "crttrack_ts0 ns/D");
  my_event_->Branch("crthit_ts0", &crthit_ts0, "crthit_ts0 ns/D");

  my_event_->Branch("nr_crthit", &crthit_counter, "nr crthit/I");
  my_event_->Branch("nr_crttrack", &crttrack_counter, "nr crttrack/I");
  my_event_->Branch("nr_crtt0", &crtt0_counter, "nr crtt0/I");
  my_event_->Branch("nr_t0", &t0_counter, "nr t0/I");
  my_event_->Branch("nr_cosmictag", &cosmictag_counter, "nr cosmictag/I");
  my_event_->Branch("nr_particleid", &particleid_counter, "nr particleid/I");
  
  my_event_->Branch("event_nr", &event_counter, "nr event/I");
  my_event_->Branch("track_nr", &track_counter, "nr track/I");

  my_event_->Branch("frunNum", &frunNum, "Run Number/i");
  my_event_->Branch("fsubRunNum", &fsubRunNum, "SubRun Number/i");
  my_event_->Branch("fEvtNum", &fEvtNum, "Event Number/i");

}

void TPCTrackAnalyser::beginJob()
{
  // Implementation of optional member function here.
  //initialize_tpandora();
  initialize_tmyevent();
  //initialize_tmy_hitasso();
  std::cout << "crthitmatch_ = " << crthitmatch_ << std::endl;

}
void TPCTrackAnalyser::endJob()
{
  // Implementation of optional member function here.
}



DEFINE_ART_MODULE(TPCTrackAnalyser)
  
}