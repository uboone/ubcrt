////////////////////////////////////////////////////////////////////////
// Class:       CRTEventAnalyser
// Module Type: analyzer
// File:        CRTEventAnalyser_module.cc
//
// Generated at Mon Nov 19 03:49:01 2018 by Thomas Mettler using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h"                                                               
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"


#include "Pandora/PdgTable.h"

#include "TTree.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>

#define LIGHTSPEED 299792458.0 // m/s
#define MASS_MU 105.6583745 // MeV

//namespace lar_pandora
//{
namespace crt {
class CRTEventAnalyser;


typedef art::Handle< std::vector<recob::PFParticle> > PFParticleHandle;
typedef std::map< size_t, art::Ptr<recob::PFParticle> > PFParticleIdMap;
typedef std::vector< art::Ptr<recob::PFParticle> > PFParticleVector;
typedef std::vector< art::Ptr<recob::Track> > TrackVector;
typedef std::vector< art::Ptr<recob::Shower> > ShowerVector;

class CRTEventAnalyser : public art::EDAnalyzer {
public:
  explicit CRTEventAnalyser(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTEventAnalyser(CRTEventAnalyser const &) = delete;
  CRTEventAnalyser(CRTEventAnalyser &&) = delete;
  CRTEventAnalyser & operator = (CRTEventAnalyser const &) = delete;
  CRTEventAnalyser & operator = (CRTEventAnalyser &&) = delete;
  
  

  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions.
  void beginJob() override;
  void endJob() override;


private:

  // Declare member data here.
  art::ServiceHandle<art::TFileService> tfs;
  TTree* t_pandora;
  int nPFPcosmic = -9999;
  int nPFPnu = -9999;
  int nPFPnuTrack = -9999;
  int nPFPnuShower = -9999;
  
  
  std::string m_pandoraLabel;         ///< The label for the pandora producer
  std::string m_trackLabel;           ///< The label for the track producer from PFParticles
  std::string m_showerLabel;          ///< The label for the shower producer from PFParticles
  
  int verbose_;
  //int numberOfevents_;
  std::string data_label_hits_;
  std::string data_label_tracks_;

  void GetPFParticleIdMap(const PFParticleHandle &pfParticleHandle, PFParticleIdMap &pfParticleMap);
  void GetFinalStatePFParticleVectors(const PFParticleIdMap &pfParticleMap, PFParticleVector &crParticles, PFParticleVector &nuParticles);
  void CollectTracksAndShowers(const PFParticleVector &particles, const PFParticleHandle &pfParticleHandle, const art::Event &evt, TrackVector &tracks, ShowerVector &showers);
  
  void initialize_tpandora();
};
  
//}

//namespace lar_pandora
//{
CRTEventAnalyser::CRTEventAnalyser(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset)  // ,
 // More initializers here.
  
{
  m_pandoraLabel = pset.get<std::string>("PandoraLabel");
  m_trackLabel = pset.get<std::string>("TrackLabel");
  m_showerLabel = pset.get<std::string>("ShowerLabel");
  //m_printOutScores = pset.get<bool>("PrintOutScores",true);
  verbose_ = pset.get<int>("verbose");
  //numberOfevents_ = pset.get<int>("Number_of_Events");
  data_label_hits_ = pset.get<std::string>("data_label_hits");
  data_label_tracks_ = pset.get<std::string>("data_label_tracks");
}

void CRTEventAnalyser::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  std::cout << "Run " << evt.run() << ", subrun " << evt.subRun() << std::endl;
  
  PFParticleHandle pfParticleHandle;
  evt.getByLabel(m_pandoraLabel, pfParticleHandle);

  if (!pfParticleHandle.isValid())
  {
      mf::LogDebug("ConsolidatedPFParticleAnalysisTemplate") << "  Failed to find the PFParticles." << std::endl;
      return;
  }

  // Produce a map of the PFParticle IDs for fast navigation through the hierarchy
  PFParticleIdMap pfParticleMap;
  this->GetPFParticleIdMap(pfParticleHandle, pfParticleMap);
  
  // Produce two PFParticle vectors containing final-state particles:
  // 1. Particles identified as cosmic-rays - recontructed under cosmic-hypothesis
  // 2. Daughters of the neutrino PFParticle - reconstructed under the neutrino hypothesis
  std::vector< art::Ptr<recob::PFParticle> > crParticles;
  std::vector< art::Ptr<recob::PFParticle> > nuParticles;
  this->GetFinalStatePFParticleVectors(pfParticleMap, crParticles, nuParticles);

  // Use as required!
  // -----------------------------
  //   What follows is an example showing how one might access the reconstructed neutrino final-state tracks and showers

  // These are the vectors to hold the tracks and showers for the final-states of the reconstructed neutrino
  std::vector< art::Ptr<recob::Track> > tracks;
  std::vector< art::Ptr<recob::Shower> > showers;
  this->CollectTracksAndShowers(nuParticles, pfParticleHandle, evt, tracks, showers);

  // Print a summary of the consolidated event
  std::cout << "Consolidated event summary:" << std::endl;
  std::cout << "  - Number of primary cosmic-ray PFParticles   : " << crParticles.size() << std::endl;
  std::cout << "  - Number of neutrino final-state PFParticles : " << nuParticles.size() << std::endl;
  std::cout << "    ... of which are track-like   : " << tracks.size() << std::endl;
  std::cout << "    ... of which are showers-like : " << showers.size() << std::endl;
  
  // Fill pandora tree:
  nPFPcosmic = crParticles.size();
  nPFPnu = nuParticles.size();
  nPFPnuTrack = tracks.size();
  nPFPnuShower = showers.size();
  t_pandora->Fill();
}

void CRTEventAnalyser::GetPFParticleIdMap(const PFParticleHandle &pfParticleHandle, PFParticleIdMap &pfParticleMap)
{
    for (unsigned int i = 0; i < pfParticleHandle->size(); ++i)
    {
        const art::Ptr<recob::PFParticle> pParticle(pfParticleHandle, i);
        if (!pfParticleMap.insert(PFParticleIdMap::value_type(pParticle->Self(), pParticle)).second)
        {
            throw cet::exception("crt_ana") << "  Unable to get PFParticle ID map, the input PFParticle collection has repeat IDs!";
        }
    }
}
/*
void crt::CRTAnalyserAlgo::PrintOutScores(const art::Event &evt, const PFParticleHandle &pfParticleHandle) const
{
    // Get the associations between PFParticles and larpandoraobj::PFParticleMetadata
    art::FindManyP< larpandoraobj::PFParticleMetadata > pfPartToMetadataAssoc(pfParticleHandle, evt, m_pandoraLabel);

    for (unsigned int i = 0; i < pfParticleHandle->size(); ++i)
    {
        const std::vector< art::Ptr<larpandoraobj::PFParticleMetadata> > &pfParticleMetadataList(pfPartToMetadataAssoc.at(i));
        if (!pfParticleMetadataList.empty())
        {
            const art::Ptr<recob::PFParticle> pParticle(pfParticleHandle, i);
            for (unsigned int j=0; j<pfParticleMetadataList.size(); ++j)
            {
                const art::Ptr<larpandoraobj::PFPaint verbose_;
  //int numberOfevents_;
  std::string data_label_hits_;
  std::string data_label_tracks_;rticleMetadata> &pfParticleMetadata(pfParticleMetadataList.at(j));
                const pandora::PropertiesMap &pfParticlePropertiesMap(pfParticleMetadata->GetPropertiesMap());
                if (!pfParticlePropertiesMap.empty())
                    std::cout << " Found PFParticle " << pParticle->Self() << " with: " << std::endl;
                for (pandora::PropertiesMap::const_iterator it = pfParticlePropertiesMap.begin(); it != pfParticlePropertiesMap.end(); ++it)
                    std::cout << "  - " << it->first << " = " << it->second << std::endl;
            }
        }
    }
}
*/
void CRTEventAnalyser::GetFinalStatePFParticleVectors(const PFParticleIdMap &pfParticleMap, PFParticleVector &crParticles, PFParticleVector &nuParticles)
{
    for (PFParticleIdMap::const_iterator it = pfParticleMap.begin(); it != pfParticleMap.end(); ++it)
    {
        const art::Ptr<recob::PFParticle> pParticle(it->second);

        // Only look for primary particles
        if (!pParticle->IsPrimary()) continue;

        // Check if this particle is identified as the neutrino
        const int pdg(pParticle->PdgCode());
        const bool isNeutrino(std::abs(pdg) == pandora::NU_E || std::abs(pdg) == pandora::NU_MU || std::abs(pdg) == pandora::NU_TAU);

        // All non-neutrino primary particles are reconstructed under the cosmic hypothesis
        if (!isNeutrino)
        {
            crParticles.push_back(pParticle);
            continue;
        }

        // ATTN. We are filling nuParticles under the assumption that there is only one reconstructed neutrino identified per event.
        //       If this is not the case please handle accordingly
        if (!nuParticles.empty())
        {
            throw cet::exception("crt_ana") << "  This event contains multiple reconstructed neutrinos!";
        }

        // Add the daughters of the neutrino PFParticle to the nuPFParticles vector
        for (const size_t daughterId : pParticle->Daughters())
        {
            if (pfParticleMap.find(daughterId) == pfParticleMap.end())
                throw cet::exception("crt_ana") << "  Invalid PFParticle collection!";

            nuParticles.push_back(pfParticleMap.at(daughterId));
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------
    
void CRTEventAnalyser::CollectTracksAndShowers(const PFParticleVector &particles, const PFParticleHandle &pfParticleHandle, const art::Event &evt, TrackVector &tracks, ShowerVector &showers)
{
    // Get the associations between PFParticles and tracks/showers from the event
  
    //std::string m_trackLabel = "";           ///< The label for the track producer from PFParticles
    //std::string m_showerLabel = "";
  
    art::FindManyP< recob::Track > pfPartToTrackAssoc(pfParticleHandle, evt, m_trackLabel);
    art::FindManyP< recob::Shower > pfPartToShowerAssoc(pfParticleHandle, evt, m_showerLabel);
   
    for (const art::Ptr<recob::PFParticle> &pParticle : particles)
    {
        const std::vector< art::Ptr<recob::Track> > associatedTracks(pfPartToTrackAssoc.at(pParticle.key()));
        const std::vector< art::Ptr<recob::Shower> > associatedShowers(pfPartToShowerAssoc.at(pParticle.key()));
        const unsigned int nTracks(associatedTracks.size());
        const unsigned int nShowers(associatedShowers.size());

        // Check if the PFParticle has no associated tracks or showers
        if (nTracks == 0 && nShowers == 0)
        {
            mf::LogDebug("crt_ana") << "  No tracks or showers were associated to PFParticle " << pParticle->Self() << std::endl;
            continue;
        }

        // Check if there is an associated track
        if (nTracks == 1 && nShowers == 0)
        {
            tracks.push_back(associatedTracks.front());
            continue;
        }

        // Check if there is an associated shower
        if (nTracks == 0 && nShowers == 1)
        {
            showers.push_back(associatedShowers.front());
            continue;
        }

        throw cet::exception("crt_ana") << "  There were " << nTracks << " tracks and " << nShowers << " showers associated with PFParticle " << pParticle->Self();
    }
}

void CRTEventAnalyser::initialize_tpandora()
{
  // Implementation of optional member function here.
  // Implementation of required member function here.
  std::cout << "Initialize variables and histograms for pandora consolidated output" << std::endl;
  //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
  t_pandora = tfs->make<TTree>("t_pandora","t_pandora");
  t_pandora->Branch("nPFPcosmic", &nPFPcosmic, "Number of Cosmic PFparticles/I");
  t_pandora->Branch("nPFPnu", &nPFPnu, "Number of nu PFparticles/I");
  t_pandora->Branch("nPFPnuTrack", &nPFPnuTrack, "Number of track like nu PFparticles/I");
  t_pandora->Branch("nPFPnuShower", &nPFPnuShower, "Number of Shower like nu PFparticles/I");

}
  
void CRTEventAnalyser::beginJob()
{
  // Implementation of optional member function here.
  initialize_tpandora();
  //initialize_tracks();
  
}
void CRTEventAnalyser::endJob()
{
  // Implementation of optional member function here.
}
DEFINE_ART_MODULE(CRTEventAnalyser)
}