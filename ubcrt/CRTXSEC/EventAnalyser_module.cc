////////////////////////////////////////////////////////////////////////
// Class:       EventAnalyser
// Module Type: analyzer
// File:        EventAnalyser_module.cc
//
// Generated at Mon Nov 19 03:49:01 2018 by Thomas Mettler using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"

#include "art/Persistency/Common/PtrMaker.h"
//#include "PtrMaker.h"

//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

#include "ubcrt/CRTXSEC/CRTAnaFun.hh"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h"                                                               
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"
#include "Pandora/PdgTable.h"

#include "TTree.h"
#include "TBenchmark.h"
#include "TRandom.h"
#include "TSystem.h"
#include "TClonesArray.h"
#include "TObject.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>

#define LIGHTSPEED 299792458.0 // m/s
#define MASS_MU 105.6583745 // MeV

//namespace lar_pandora
//{
namespace crt {
  class EventAnalyser;

  //this is a test
  typedef art::Handle< std::vector<recob::PFParticle> > PFParticleHandle;
  typedef std::map< size_t, art::Ptr<recob::PFParticle> > PFParticleIdMap;
  typedef std::vector< art::Ptr<recob::PFParticle> > PFParticleVector;
  typedef std::vector< art::Ptr<recob::Track> > TrackVector;
  typedef std::vector< art::Ptr<recob::Shower> > ShowerVector;

  class EventAnalyser : public art::EDAnalyzer {
  public:
    explicit EventAnalyser(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    EventAnalyser(EventAnalyser const &) = delete;
    EventAnalyser(EventAnalyser &&) = delete;
    EventAnalyser & operator = (EventAnalyser const &) = delete;
    EventAnalyser & operator = (EventAnalyser &&) = delete;



    // Required functions.
    void analyze(art::Event const & e) override;

    // Selected optional functions.
    void beginJob() override;
    void endJob() override;


  private:

    // Declare member data here.
    art::ServiceHandle<art::TFileService> tfs;

    //tree variables for PFParticles///////////////////
    //TTree* t_pandora;
    TTree * t_pandora;
    int nPFPcosmic = -9999;
    int nPFPnu = -9999;
    int nPFPnuTrack = -9999;
    int nPFPnuShower = -9999;
    
    TTree * my_event_;
    crt::CRTHit crthit_match;
    recob::Track tpctrack_match;
    double tpc_crthit_dist;
    double track_length;
    uint32_t fEvtNum; //Number of current event                       
    uint32_t frunNum;                //Run Number taken from event  
    uint32_t fsubRunNum;             //Subrun Number taken from event 

    // data lables from fcl file/////////////////////////////////////////////////////////
    std::string m_pandoraLabel;         ///< The label for the pandora producer
    std::string m_trackLabel;           ///< The label for the track producer from PFParticles
    std::string m_showerLabel;          ///< The label for the shower producer from PFParticles
    int verbose_;
    //int numberOfevents_;
    std::string data_label_hits_;
    std::string data_label_tracks_; 
    int saveTTree_;
    std::string  data_label_flash_;
    std::string  data_label_flash_beam_;
    std::string  data_label_track_flash_;
    std::string  data_label_DAQHeader_;
    std::string  data_label_TPCTrack_;
    std::string  data_label_T0reco_;
    std::string  data_label_Calorimetry_;
    int fHardDelay_;
    int fCRTT0off_;
    double fvdrift_;
    double crthitmatch_;
    
    int match_counter = 0;

    // functions ////////////////////////////////////////////////////////////////////////////////////////
    void initialize_tpandora();
    void initialize_tmyevent();
  };

  //}

  //namespace lar_pandora
  //{
  EventAnalyser::EventAnalyser(fhicl::ParameterSet const & pset)
    :
    EDAnalyzer(pset)  // ,
   // More initializers here.

  {
    m_pandoraLabel = pset.get<std::string>("PandoraLabel");
    m_trackLabel = pset.get<std::string>("TrackLabel");
    m_showerLabel = pset.get<std::string>("ShowerLabel");
    //m_printOutScores = pset.get<bool>("PrintOutScores",true);
    verbose_ = pset.get<int>("verbose");
    //numberOfevents_ = pset.get<int>("Number_of_Events");
    data_label_hits_ = pset.get<std::string>("data_label_hits");
    data_label_tracks_ = pset.get<std::string>("data_label_tracks");

    data_label_flash_ = pset.get<std::string>("data_label_flash");
    data_label_flash_beam_ = pset.get<std::string>("data_label_flash_beam");
    data_label_track_flash_ = pset.get<std::string>("data_label_track_flash");
    data_label_DAQHeader_ = pset.get<std::string>("data_label_DAQHeader");
    data_label_TPCTrack_ = pset.get<std::string>("data_label_TPCTrack");
    data_label_T0reco_ = pset.get<std::string>("data_label_T0reco");
    data_label_Calorimetry_ = pset.get<std::string>("data_label_Calorimetry");
    fHardDelay_ = pset.get<int>("fHardDelay",40000);
    fCRTT0off_ = pset.get<int>("fCRTT0off",69000);
    fvdrift_ = pset.get<double>("fvdrift",0.111436);
    crthitmatch_ = pset.get<double>("crthitmatch",1.00);

    saveTTree_ = pset.get<int>("saveTTree");
  }

  void EventAnalyser::analyze(art::Event const & evt)
  {
    // Implementation of required member function here.
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun() << std::endl;
    frunNum    = evt.run();
    fsubRunNum = evt.subRun();
    fEvtNum = evt.event();
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // get PFParticle information////////////////////////////////////////////////////////////////////////////////////
    PFParticleHandle pfParticleHandle;
    evt.getByLabel(m_pandoraLabel, pfParticleHandle);

    if (!pfParticleHandle.isValid())
    {
        mf::LogDebug("ConsolidatedPFParticleAnalysisTemplate") << "  Failed to find the PFParticles." << std::endl;
        return;
    }

    crtana::PFParticleIdMap pfParticleMap;
    crtana::auxfunc::GetPFParticleIdMap(pfParticleHandle, pfParticleMap);
    std::vector< art::Ptr<recob::PFParticle> > crParticles;
    std::vector< art::Ptr<recob::PFParticle> > nuParticles;
    crtana::auxfunc::GetFinalStatePFParticleVectors(pfParticleMap, crParticles, nuParticles);
    std::vector< art::Ptr<recob::Track> > tracks;
    std::vector< art::Ptr<recob::Shower> > showers;
    crtana::auxfunc::CollectTracksAndShowers(nuParticles, pfParticleHandle, evt, tracks, showers, m_trackLabel, m_showerLabel);

    // Print a summary of the consolidated event
    //if(verbose_!=0){
      std::cout << "Consolidated event summary:" << std::endl;
      std::cout << "  - Number of primary cosmic-ray PFParticles   : " << crParticles.size() << std::endl;
      std::cout << "  - Number of neutrino final-state PFParticles : " << nuParticles.size() << std::endl;
      std::cout << "    ... of which are track-like   : " << tracks.size() << std::endl;
      std::cout << "    ... of which are showers-like : " << showers.size() << std::endl;
    //}
    // grab flashes associated with tracks              
    art::Handle< std::vector<recob::Track> > rawHandle_TPCtrack;
    evt.getByLabel(m_trackLabel, rawHandle_TPCtrack);
    //std::vector<recob::Track> const& TPCTrackCollection(*rawHandle_TPCtrack);
    art::FindMany<recob::OpFlash> trk_flash_assn_v(rawHandle_TPCtrack, evt, data_label_track_flash_);
    
    art::Handle< std::vector<crt::CRTHit> > rawHandle_hits;
    evt.getByLabel(data_label_hits_, rawHandle_hits); //what is the product instance name? no BernZMQ
    if (!rawHandle_hits.isValid()){
        mf::LogDebug("Event Analyser") << "  Failed to find the CRTHits." << std::endl;
        return;
    }
    std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_hits);
    //check to make sure the data we asked for is valid                                                                                                      
    //const std::vector< art::Ptr<crt::CRTHit> > CRTHitCollection(*rawHandle_hits);
    
    //std::cout << "Number of crt hits: " << CRTHitCollection.size() << std::endl;
    /*
    //in loop
    //std::vector<double> &pdist = 0;
    std::vector<double> dist;
    for(const art::Ptr<recob::Track> &ptracks : tracks){
      const std::vector<const recob::OpFlash*>& flash_v = trk_flash_assn_v.at(ptracks.key());
      if(verbose_!=0) std::cout << "Found " << flash_v.size() << " assigned flashes for track " << ptracks.key() << std::endl;
      
      //recob::Track my_track = *tracks.at(i).get();
      //std::vector<double> *dist;
      double track_match = crtana::auxfunc::TpcTrack_match_CrtHit(ptracks, CRTHitCollection, dist, crthitmatch_);
      std::cout << "Match?: " << track_match << " size of maching hits: " << dist.size() << std::endl;
      if(track_match==1){
        for(std::vector<int>::size_type i = 0; i != CRTHitCollection.size(); i++) {//A
          if(dist.at(i) < crthitmatch_){
            std::cout << "Found matching hit: " << dist.at(i) << std::endl;
            tpctrack_match = *ptracks.get();
            crthit_match = CRTHitCollection.at(i);
            tpc_crthit_dist = dist.at(i);
            track_length = tpctrack_match.Length();
            my_event_->Fill();
          }

        }
      }
    }*/
    
    ////////////////////////////////////////////////////////////////////////////////////////
    art::Handle< std::vector<recob::Track > > rawHandle_Track;
    evt.getByLabel(data_label_TPCTrack_, rawHandle_Track);
    std::vector<recob::Track >  TPCTrackCollection(*rawHandle_Track);
    
    //std::vector< art::Ptr<recob::Track> > TPCTrackVector;
    //const std::vector< art::Ptr<recob::Track> > TPCTracks = TPCTrackCollection.at(0);
    //auto const& h = evt.getValidHandle<std::vector<recob::Track>>(...);
    //art::PtrMaker<recob::Track> make_Aptr{evt, data_label_TPCTrack_};
    art::PtrMaker<recob::Track> makeTrackPtr(evt,rawHandle_Track.id());
    
    //auto const& h = evt.getValidHandle<std::vector<A>>(...);
    
    //art::PtrMaker<std::vector<recob::Track >> ptrMaker(evt,rawHandle_Track.id());
    //auto const TPCTrackCollection = make_Aptr(0);
    //art::PtrMaker<recob::Track> make_Aptr{evt, rawHandle_Track.id()};
    std::vector< art::Ptr<recob::Track> > TPCTracks;
    for(std::vector<int>::size_type i = 0; i != TPCTrackCollection.size(); i++) {//A
      //auto const iTrack = TPCTrackCollection.size() - 1;
      art::Ptr<recob::Track> trackPtr = makeTrackPtr(i);
      TPCTracks.push_back(trackPtr);
    }
    //tpctrack_vec = TPCTrackCollection;
    for(const art::Ptr<recob::Track> &ptracks : TPCTracks){
      const std::vector<const recob::OpFlash*>& flash_v = trk_flash_assn_v.at(ptracks.key());
      if(verbose_!=0) std::cout << "Found " << flash_v.size() << " assigned flashes for track " << ptracks.key() << std::endl;
      
      //recob::Track my_track = *tracks.at(i).get();
      //std::vector<double> *dist;
      std::vector<double> dist;
      double track_match = crtana::auxfunc::TpcTrack_match_CrtHit(ptracks, CRTHitCollection, dist, crthitmatch_);
      //std::cout << "Match?: " << track_match << " size of maching hits: " << dist.size() << std::endl;
      if(track_match==1){
        for(std::vector<int>::size_type i = 0; i != CRTHitCollection.size(); i++) {//A
          if(dist.at(i) < crthitmatch_){
            //std::cout << "Found matching hit: " << dist.at(i) << std::endl;
            tpctrack_match = *ptracks.get();
            crthit_match = CRTHitCollection.at(i);
            tpc_crthit_dist = dist.at(i);
            track_length = tpctrack_match.Length();
            my_event_->Fill();
            match_counter++;
          }

        }
      }
      dist.clear();
    }
    //std::cout << "found matches: " << match_counter << std::endl;
    ////////////////////////////////////////////////////////////////////////////////////////
    
    //flash in time?
    art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlash;
    evt.getByLabel(data_label_flash_, rawHandle_OpFlash);
    if (!rawHandle_OpFlash.isValid()){
        mf::LogDebug("Event Analyser") << "  Failed to find the OpFlashes." << std::endl;
        return;
    }
    std::vector<recob::OpFlash> const& OpFlashCollection(*rawHandle_OpFlash);
    if(verbose_!=0){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[32m" << OpFlashCollection.size() << "\033[0m"
                << " TPCFlashes " << " in module " << data_label_flash_ << std::endl;
    }
    for(std::vector<int>::size_type i = 0; i != OpFlashCollection.size(); i++) {//A 
        //printf("Processing %ld hit\n", i);
        if(OpFlashCollection[i].Time()<10 && OpFlashCollection[i].Time()>0){
          if(verbose_!=0){
            std::cout << "Flash in time: " << OpFlashCollection[i].Time() << ", with PE: " << OpFlashCollection[i].TotalPE() << std::endl;
            std::cout << "Flash in Beam?: " << OpFlashCollection[i].InBeamFrame() << ", at time: " << OpFlashCollection[i].OnBeamTime() << std::endl;
          }
        }
      }//A 

  }


  void EventAnalyser::initialize_tpandora()
  {
    // Implementation of optional member function here.
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for pandora consolidated output" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    t_pandora = tfs->make<TTree>("t_pandora","t_pandora");
    t_pandora->Branch("nPFPcosmic", &nPFPcosmic, "Number of Cosmic PFparticles/I");
    t_pandora->Branch("nPFPnu", &nPFPnu, "Number of nu PFparticles/I");
    t_pandora->Branch("nPFPnuTrack", &nPFPnuTrack, "Number of track like nu PFparticles/I");
    t_pandora->Branch("nPFPnuShower", &nPFPnuShower, "Number of Shower like nu PFparticles/I");

  }
  void EventAnalyser::initialize_tmyevent()
  {
    // Implementation of optional member function here.
    // Implementation of required member function here.
    std::cout << "Initialize variables and histograms for flash output" << std::endl;
    //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
    my_event_ = tfs->make<TTree>("my_event","my_event");
    
    //int bufsize    = 16000;
    //int splitlevel = 99;
    //_tree1->Branch("ubxsec_event_split", &ubxsec_event, bufsize, splitlevel);
    
    int bufsize_crthit = 128*1;
    //int bufsize_flash = 152*1;
    //int bufsize_crttrack = 184*1;
    int bufsize_track = 368*1;
    //int bufsize_shower = 336*1;
    //int bufsize_daqheader = 48;
    
    int splitlevel = 99;
    my_event_->Branch("crthits", &crthit_match, bufsize_crthit, splitlevel);
    //my_event_->Branch("crttracks", &crttrack_vec, bufsize_crttrack, splitlevel);
    //my_event_->Branch("flashes", &flash_vec, bufsize_flash, splitlevel);
    //my_event_->Branch("beamflashes", &beam_flash_vec, bufsize_flash, splitlevel);
    //my_event_->Branch("nutracks", &nutrack_vec, bufsize_track, splitlevel);
    //my_event_->Branch("nushowers", &nushower_vec, bufsize_shower, splitlevel);
    my_event_->Branch("tpctracks", &tpctrack_match, bufsize_track, splitlevel);
    my_event_->Branch("distance", &tpc_crthit_dist, "distance cm/D");
    my_event_->Branch("track_length", &track_length, "track_length cm/D");
    
    my_event_->Branch("frunNum", &frunNum, "Run Number/i");
    my_event_->Branch("fsubRunNum", &fsubRunNum, "SubRun Number/i");
    my_event_->Branch("fEvtNum", &fEvtNum, "Event Number/i");

    //my_event_->Branch("daqheader", &myTime, bufsize_daqheader, splitlevel);
    //my_event_->Branch("evt_timeGPS_sec", &evt_timeGPS_sec, "Eventtime sec/D");
    //my_event_->Branch("evt_timeGPS_nsec", &evt_timeGPS_nsec, "Eventtime ns/D");
    
    //my_event_->Branch("frunNum", &frunNum, "Run Number/i");
    //my_event_->Branch("fsubRunNum", &fsubRunNum, "SubRun Number/i");
    //my_event_->Branch("fEvtNum", &fEvtNum, "Event Number/i");

  }

  void EventAnalyser::beginJob()
  {
    // Implementation of optional member function here.
    initialize_tpandora();
    initialize_tmyevent();
    std::cout << "crthitmatch_ = " << crthitmatch_ << std::endl;

  }
  void EventAnalyser::endJob()
  {
    // Implementation of optional member function here.
  }
  
  
  
  DEFINE_ART_MODULE(EventAnalyser)
}