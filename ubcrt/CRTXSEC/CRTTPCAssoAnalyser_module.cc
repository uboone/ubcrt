////////////////////////////////////////////////////////////////////////
// Class:       CRTTPCAssoAnalyser
// Module Type: analyzer
// File:        CRTTPCAssoAnalyser_module.cc
//
// Generated at Mon Nov 19 03:49:01 2018 by Thomas Mettler using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"

#include "art/Persistency/Common/PtrMaker.h"
//#include "PtrMaker.h"

//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTzero.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

#include "ubcrt/CRTXSEC/CRTAnaFun.hh"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h"                                                               
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Shower.h"
#include "Pandora/PdgTable.h"

#include "TTree.h"
#include "TBenchmark.h"
#include "TRandom.h"
#include "TSystem.h"
#include "TClonesArray.h"
#include "TObject.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>

#define LIGHTSPEED 299792458.0 // m/s
#define MASS_MU 105.6583745 // MeV

//namespace lar_pandora
//{
namespace crt {

class CRTTPCAssoAnalyser;

class CRTTPCAssoAnalyser : public art::EDAnalyzer {
public:
  explicit CRTTPCAssoAnalyser(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTTPCAssoAnalyser(CRTTPCAssoAnalyser const &) = delete;
  CRTTPCAssoAnalyser(CRTTPCAssoAnalyser &&) = delete;
  CRTTPCAssoAnalyser & operator = (CRTTPCAssoAnalyser const &) = delete;
  CRTTPCAssoAnalyser & operator = (CRTTPCAssoAnalyser &&) = delete;



  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;


private:

  // Declare member data here.
  art::ServiceHandle<art::TFileService> tfs;

  TTree * my_event_;
  TTree * my_hitasso_;
  std::vector<crt::CRTHit> crthit_vec;
  std::vector<crt::CRTTrack> crttrack_vec;
  int crthit_counter;
  int crttrack_counter;
  //crt::CRTHit crthit_match;
  //crt::CRTTrack crttrack_match;
  recob::Track tpctrack_match;
  double tpc_crthit_dist;
  double track_length;
  uint32_t fEvtNum; //Number of current event                       
  uint32_t frunNum;                //Run Number taken from event  
  uint32_t fsubRunNum;             //Subrun Number taken from event 

  // data lables from fcl file/////////////////////////////////////////////////////////
  std::string m_pandoraLabel;         ///< The label for the pandora producer
  std::string m_trackLabel;           ///< The label for the track producer from PFParticles
  std::string m_showerLabel;          ///< The label for the shower producer from PFParticles
  int verbose_;
  //int numberOfevents_;
  std::string data_label_assohits_;
  std::string data_label_assotracks_; 
  std::string data_label_assoT0_;
  int saveTTree_;
  //std::string  data_label_flash_;
  //std::string  data_label_flash_beam_;
  //std::string  data_label_track_flash_;
  std::string  data_label_DAQHeader_;
  std::string  data_label_TPCTrack_;
  std::string  data_label_TPCTrack2_;
  std::string data_label_CRTtzero_;
  //std::string  data_label_T0reco_;
  //std::string  data_label_Calorimetry_;
  int fHardDelay_;
  int fCRTT0off_;
  double fvdrift_;
  double crthitmatch_;

  int match_counter = 0;

  // functions ////////////////////////////////////////////////////////////////////////////////////////
  //void initialize_tpandora();
  void initialize_tmyevent();
  //void initialize_tmy_hitasso();
};

//}

//namespace lar_pandora
//{
CRTTPCAssoAnalyser::CRTTPCAssoAnalyser(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset)  // ,
 // More initializers here.

{
  m_pandoraLabel = pset.get<std::string>("PandoraLabel");
  m_trackLabel = pset.get<std::string>("TrackLabel");
  m_showerLabel = pset.get<std::string>("ShowerLabel");
  //m_printOutScores = pset.get<bool>("PrintOutScores",true);
  verbose_ = pset.get<int>("verbose");
  //numberOfevents_ = pset.get<int>("Number_of_Events");
  data_label_assohits_ = pset.get<std::string>("data_label_assohits");
  data_label_assoT0_ = pset.get<std::string>("data_label_assoT0");
  data_label_assotracks_ = pset.get<std::string>("data_label_assotracks");

  //data_label_flash_ = pset.get<std::string>("data_label_flash");
  //data_label_flash_beam_ = pset.get<std::string>("data_label_flash_beam");
  //data_label_track_flash_ = pset.get<std::string>("data_label_track_flash");
  data_label_DAQHeader_ = pset.get<std::string>("data_label_DAQHeader");
  data_label_TPCTrack_ = pset.get<std::string>("data_label_TPCTrack");
  data_label_TPCTrack2_ = pset.get<std::string>("data_label_TPCTrack2");
  data_label_CRTtzero_ = pset.get<std::string>("data_label_CRTtzero");
  //data_label_T0reco_ = pset.get<std::string>("data_label_T0reco");
  //data_label_Calorimetry_ = pset.get<std::string>("data_label_Calorimetry");

  fHardDelay_ = pset.get<int>("fHardDelay",40000);
  fCRTT0off_ = pset.get<int>("fCRTT0off",69000);
  fvdrift_ = pset.get<double>("fvdrift",0.111436);
  crthitmatch_ = pset.get<double>("crthitmatch",1.00);

  saveTTree_ = pset.get<int>("saveTTree");
}

void CRTTPCAssoAnalyser::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  std::cout << "Run " << evt.run() << ", subrun " << evt.subRun() << std::endl;
  frunNum    = evt.run();
  fsubRunNum = evt.subRun();
  fEvtNum = evt.event();

  art::Handle< std::vector<recob::Track> > rawHandle_TPCtrack;
  evt.getByLabel(data_label_TPCTrack_, rawHandle_TPCtrack);
  
  //check to make sure the data we asked for is valid                                                                                                     
  std::vector<recob::Track> const& TPCTrackCollection(*rawHandle_TPCtrack);    
  //std::cout<<"  TPCTrackCollection.size()  "<<TPCTrackCollection.size()<<std::endl;

  if(!rawHandle_TPCtrack.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " recob::Track " << " in module " << data_label_TPCTrack_ << std::endl;
    std::cout << std::endl;
    return;
  }
  // use only an additional raw handel if the data labe for tracks is different
  // depending which association (track - track // track - hit) is used
  art::Handle< std::vector<recob::Track> > rawHandle_TPCtrack2;
  evt.getByLabel(data_label_TPCTrack2_, rawHandle_TPCtrack2);

  art::Handle< std::vector<crt::CRTTzero> > rawHandle_CRTtzero;
  evt.getByLabel(data_label_CRTtzero_, rawHandle_CRTtzero);

  std::vector<crt::CRTTzero> const& CRTT0Collection(*rawHandle_CRTtzero);    
  //std::cout<<"  CRTT0Collection.size()  "<<CRTT0Collection.size()<<std::endl;
  // grab crt tracks objects associated with tracks   
  art::FindMany<crt::CRTTrack> trk_crttrack_assn_v(rawHandle_TPCtrack2, evt, data_label_assotracks_);
  // to grab the crt hits associated to a tpc track we need to go over crt t0 objects
  // since the association is only between tpc tracks - crt t0 and crt t0 - crt hits
  art::FindMany<crt::CRTTzero> trk_crtT0_assn_v(rawHandle_TPCtrack, evt, data_label_assoT0_);
  art::FindMany<crt::CRTHit> trk_crthit_assn_v(rawHandle_CRTtzero, evt, data_label_assohits_);
  

  for(std::vector<int>::size_type i = 0; i != TPCTrackCollection.size(); i++) {    //start loop over tpc tracks
    crthit_counter = 0;
    crttrack_counter = 0;

    recob::Track my_TPCTrack = TPCTrackCollection[i]; 
    tpctrack_match = my_TPCTrack;
    track_length = tpctrack_match.Length();

    // get crt track associated to TPC track: //////////////////////////
    const std::vector<const crt::CRTTrack*>& CRTtrack_v = trk_crttrack_assn_v.at(i);
    if(CRTtrack_v.size()>0){
      auto crttrack_tmp = CRTtrack_v.at(0);
      if(verbose_!=0){
        std::cout << "found Track - CRT Track assoziation" << std::endl;
        std::cout << "Track time: " << crttrack_tmp->ts0_ns << std::endl;
        std::cout << "Track position 1: " << crttrack_tmp->x1_pos << ":" << crttrack_tmp->y1_pos << ":" << crttrack_tmp->z1_pos << std::endl;
        std::cout << "Track position 2: " << crttrack_tmp->x2_pos << ":" << crttrack_tmp->y2_pos << ":" << crttrack_tmp->z2_pos << std::endl;
      }
      //update the crt track tree variables
      crttrack_vec.push_back(*crttrack_tmp);
      crttrack_counter++;
    }

    // get crt hit associated to TPC track: ///////////////////////////
    // Since crt hits are associated to crt t0 objects and these are associated
    // to tpc tracks an additional step is needed
    const std::vector<const crt::CRTTzero*>& CRTtzero_v = trk_crtT0_assn_v.at(i);
    for(std::vector<int>::size_type j = 0; j != CRTtzero_v.size(); j++){
      if(verbose_!=0) std::cout << "found Track - CRT T0 assoziation" << std::endl;
      //get CRT t0 associated to tpc track and loop over all crt t0:
      auto crtT0_tmp = CRTtzero_v.at(j);
      for(std::vector<int>::size_type i_t0 = 0; i_t0 != CRTT0Collection.size(); i_t0++){
        auto my_crtt0 = CRTT0Collection.at(i_t0);
        // take the crt t0 object from the event which is identical to the associated tpc track
        // and get the associated crt hits
        if( (crtT0_tmp->ts0_ns == my_crtt0.ts0_ns) && (crtT0_tmp->ts0_s == my_crtt0.ts0_s) ){
          //std::cout << "found rigth t0..." << std::endl;
          const std::vector<const crt::CRTHit*>& CRThit_v = trk_crthit_assn_v.at(i_t0);
          for(std::vector<int>::size_type i_hit = 0; i_hit != CRThit_v.size(); i_hit++){
            auto my_crthit = CRThit_v.at(i_hit);
            if(verbose_!=0){
              std::cout << "Hit time: " << my_crthit->ts0_ns << std::endl;
              std::cout << "Hit position: " << my_crthit->x_pos << ":" << my_crthit->y_pos << ":" << my_crthit->z_pos << std::endl;
            }
            //update the crt hit tree variables
            crthit_vec.push_back(*my_crthit);
            crthit_counter++;
          }
        }
      }
    }//end loop over crt t0
    //fill the tree and reset the tree vectors
    my_event_->Fill();
    crthit_vec.clear();
    crttrack_vec.clear();
  }//end loop over tpc tracks

}

void CRTTPCAssoAnalyser::initialize_tmyevent()
{
  // Implementation of optional member function here.
  std::cout << "Initialize variables and histograms for flash output" << std::endl;
  //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
  
  my_event_ = tfs->make<TTree>("my_event","my_event");
  int bufsize_crthit = 128*20;
  //int bufsize_flash = 152*1;
  int bufsize_crttrack = 184*5;
  int bufsize_track = 368*1;
  //int bufsize_shower = 336*1;
  //int bufsize_daqheader = 48;

  int splitlevel = 99;
  my_event_->Branch("crthits", &crthit_vec, bufsize_crthit, splitlevel);
  my_event_->Branch("crttracks", &crttrack_vec, bufsize_crttrack, splitlevel);

  my_event_->Branch("tpctracks", &tpctrack_match, bufsize_track, splitlevel);
  my_event_->Branch("distance", &tpc_crthit_dist, "distance cm/D");
  my_event_->Branch("track_length", &track_length, "track_length cm/D");

  my_event_->Branch("nr_crthit", &crthit_counter, "nr crthit/I");
  my_event_->Branch("nr_crttrack", &crttrack_counter, "nr crttrack/I");

  my_event_->Branch("frunNum", &frunNum, "Run Number/i");
  my_event_->Branch("fsubRunNum", &fsubRunNum, "SubRun Number/i");
  my_event_->Branch("fEvtNum", &fEvtNum, "Event Number/i");

}

void CRTTPCAssoAnalyser::beginJob()
{
  // Implementation of optional member function here.
  //initialize_tpandora();
  initialize_tmyevent();
  //initialize_tmy_hitasso();
  std::cout << "crthitmatch_ = " << crthitmatch_ << std::endl;

}
void CRTTPCAssoAnalyser::endJob()
{
  // Implementation of optional member function here.
}



DEFINE_ART_MODULE(CRTTPCAssoAnalyser)
  
}