////////////////////////////////////////////////////////////////////////
// Class:       CRTeffStd
// Module Type: analyzer
// File:        CRTeffStd_module.cc
// Description: CRT efficiency studies
// Generated at Wed May 16 04:36:39 2018 by David Lorca Galindo using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// data-products
#include "lardataobj/RecoBase/Track.h"                                                                
#include "lardataobj/RecoBase/Hit.h"                                                                  
#include "lardataobj/AnalysisBase/T0.h"                                                               
#include "lardataobj/AnalysisBase/CosmicTag.h"                                                        
#include "lardataobj/AnalysisBase/Calorimetry.h"                                                      
#include "lardataobj/MCBase/MCTrack.h"                                                                
#include "lardataobj/RecoBase/OpFlash.h"                                                              
#include "lardata/Utilities/AssociationUtil.h"

//CRT data-products
#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"


//Root
#include "TTree.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <typeinfo>

namespace crt {
  class CRTeffStd;
}

class crt::CRTeffStd : public art::EDAnalyzer {
public:
  explicit CRTeffStd(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTeffStd(CRTeffStd const &) = delete;
  CRTeffStd(CRTeffStd &&) = delete;
  CRTeffStd & operator = (CRTeffStd const &) = delete;
  CRTeffStd & operator = (CRTeffStd &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;


  double CalorInter(const std::vector<const anab::Calorimetry*>& Calo_v);
  //from Chris
  void SortTrackPoints (const recob::Track& track, std::vector<recob::Track::Point_t>& sorted_trk);

  double CalTheta(double x, double y, double z);
  double CalPhi(double x, double y, double z);

private:

  art::ServiceHandle<art::TFileService> tfs;
                                                                     
  std::string  data_labelCRTtrack_;
  std::string  data_labelCRThit_;
  std::string  data_label_flash_;
  std::string  data_label_DAQHeader_;
  std::string  data_label_TPCTrack_;
  std::string  data_label_T0reco_;
  std::string  data_label_Calorimetry_;
  int fHardDelay_;
  int fCRTT0off_;
  double fvdrift_;
  int verbose_;

  TH1F* hFlashTimeDis;
  TH1F* hTFvsTH_t1;
  TH1F* hTFvsTH_t0;
  TH2F* hTFvsTH_t0_t1;
  TH1F* hTFvsTT_t1;
  TH1F* hTFvsTT_t0;
  TH2F* hTFvsTT_t0_t1;
  TH2F* hTPCTvsCRTT;
  TH1F* hTPCTlength;
  TH1F* hNCRTHitsperFlash;
  TH1F* hNCRTHitsperFlashClone;
  TH1F* hNCRTTracksperFlash;
  TH1F* hNCRTTracksperFlashClone;

  TH1F* hDiffX_bot;
  TH2F* hDiffXvsX_bot;
  TProfile* hDiffXvsX_bot_prof;
  TH1F* hDiffZ_bot;

  TH1F* hDiffY_ft;
  TH1F* hDiffZ_ft;

  TH1F* hDiffX_top;
  TH1F* hDiffZ_top;

  TH1F* hDiffY_pipe;
  TH1F* hDiffZ_pipe;
  TH2F* hDiffY_pipe_vsY;
  TProfile* hDiffY_pipe_vsY_prof;

  TH2F* hBot;
  TH2F* hFT;
  TH2F* hPipe;
  TH2F* hTop;

  TH1F* hDiffZ_FlaTra;
  TH2F* hDiffZ_FlaTra2D;
  TProfile* hDiffZ_FlaTra2D_prof;

  TH1F* hDiffY_FlaTra;
  TH2F* hDiffY_FlaTra2D;
  TProfile* hDiffY_FlaTra2D_prof;

  TH1F* hPES;
  TH2F* hPESvsZ;
  TH2F* hFlashZY;

  TH2F* hDiffXvsCal_bot;
  TProfile* hDiffXvsCal_bot_prof;

  TH2F* hCalvsLen;
  TH1F* hTotCalNorm;

  TH1F* hTheta;
  TH1F* hPhi;

  TH1F* hDiffTheta;
  TH1F* hDiffPhi;
  TH2F* hDiffTheta2D;
  TH2F* hDiffPhi2D;
  TH2F* hDiffThetaPhi2D;

  TH2F*	hDiffThetavsTPCLength;


  TH2F*	hTPCXY_top;
  TH2F*	hTPCZY_top;
  TH2F*	hTPCXY_bottom;
  TH2F*	hTPCZY_bottom;


  TH2F*	hCRTXY;
  TH2F*	hCRTZY;
  
};


crt::CRTeffStd::CRTeffStd(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  data_labelCRTtrack_(p.get<std::string>("data_labelCRTtrack")),
  data_labelCRThit_(p.get<std::string>("data_labelCRThit")),
  data_label_flash_(p.get<std::string>("data_label_flash")),
  data_label_DAQHeader_(p.get<std::string>("data_label_DAQHeader")),
  data_label_TPCTrack_(p.get<std::string>("data_label_TPCTrack")),
  data_label_T0reco_(p.get<std::string>("data_label_T0reco")),
  data_label_Calorimetry_(p.get<std::string>("data_label_Calorimetry")),
  fHardDelay_(p.get<int>("fHardDelay",40000)),
  fCRTT0off_(p.get<int>("fCRTT0off",69000)),
  fvdrift_(p.get<double>("fvdrift",0.111436)),
  verbose_(p.get<int>("verbose"))  // ,
 // More initializers here.
{}

void crt::CRTeffStd::analyze(art::Event const & evt)
{

  //get DAQHeader for GPS time
  art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;
  evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
  
  //check to make sure the data we asked for is valid                     
  if(!rawHandle_DAQHeader.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;
    return;
  }
  //get DAQHeader for GPS time

  raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);
  art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();
  auto evt_timeGPS_sec = evtTimeGPS.timeHigh();
  auto evt_timeGPS_nsec = evtTimeGPS.timeLow();
  if(verbose_==3){
    std::cout<<"Evt:GPS_Time: sec, nsec :"<<evt_timeGPS_sec <<" "<< evt_timeGPS_nsec <<std::endl;
  }  

  //get CRTHits                                                                    
  art::Handle< std::vector<crt::CRTHit> > rawHandle_CRThit;
  evt.getByLabel(data_labelCRThit_, rawHandle_CRThit); //                                

  //check to make sure the data we asked for is valid                              
  if(!rawHandle_CRThit.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " CRTHits " << " in module " << data_labelCRThit_ << std::endl;
    std::cout << std::endl;
    return;
  }

  //get better access to the data                                                                      
  std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_CRThit);
  
  if(verbose_!=0){
    std::cout<<"  CRTHitCollection.size()  "<<CRTHitCollection.size()<<std::endl;
  }
  //get CRTHits
  
  
  //get CRTTracks                                                                  
  art::Handle< std::vector<crt::CRTTrack> > rawHandle_CRTtrack;
  evt.getByLabel(data_labelCRTtrack_, rawHandle_CRTtrack);                               
                                                                                   
  //check to make sure the data we asked for is valid                              
  if(!rawHandle_CRTtrack.isValid()){                                                  
  std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()                
  << ", event " << evt.event() << " has zero"                          
  << " CRTTracks " << " in module " << data_labelCRTtrack_ << std::endl;  
  std::cout << std::endl;                                                        
  return;                                                                        
  }                                                                                
  
  //get better access to the data                                                                                   
  std::vector<crt::CRTTrack> const& CRTTrackCollection(*rawHandle_CRTtrack);          
  
  if(verbose_!=0){
    std::cout<<"  CRTTrackCollection.size()  "<<CRTTrackCollection.size()<<std::endl;                                                                                
  }                                                                                
  //get CRTTracks                                                                  
  
  //get Optical Flash                                                                                                   
  art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlash;
  evt.getByLabel(data_label_flash_, rawHandle_OpFlash);

  std::vector<recob::OpFlash> const& OpFlashCollection(*rawHandle_OpFlash);
  
  if(verbose_!=0){
    std::cout<<"  OpFlashCollection.size()  "<<OpFlashCollection.size()<<std::endl;
  }
  //get Optical Flash
  
  //get TPC Tracks                                                                                                      
  art::Handle< std::vector<recob::Track> > rawHandle_TPCtrack;
  evt.getByLabel(data_label_TPCTrack_, rawHandle_TPCtrack);
  
  //check to make sure the data we asked for is valid                                                                   
  if(!rawHandle_TPCtrack.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " recob::Track " << " in module " << data_label_TPCTrack_ << std::endl;
    std::cout << std::endl;
    return;
  }

  //get better access to the data
  std::vector<recob::Track> const& TPCTrackCollection(*rawHandle_TPCtrack);
  
  // if(verbose_==1 || verbose_==2){
  if(verbose_!=0){
    std::cout<<"  TPCTrackCollection.size()  "<<TPCTrackCollection.size()<<std::endl;
  }
  //get TPCTracks 
  
  // grab T0 objects associated with tracks
  art::FindMany<anab::T0> trk_t0_assn_v(rawHandle_TPCtrack, evt, data_label_T0reco_); //objeto, evento, label           
  
  // grab flashes associated with tracks                                                                                
  art::FindMany<recob::OpFlash> trk_flash_assn_v(rawHandle_TPCtrack, evt, data_label_T0reco_ );
  
  // grab calorimetry associated with tracks
  art::FindMany<anab::Calorimetry> trk_calo_assn_v(rawHandle_TPCtrack, evt, data_label_Calorimetry_  );
  
  if(CRTTrackCollection.size()<40){//A0 //cut in shower events
    
    for(std::vector<int>::size_type i = 0; i != TPCTrackCollection.size(); i++) {//A
    
      recob::Track my_TPCTrack = TPCTrackCollection[i];
      
      auto TPCTrackLength =  my_TPCTrack.Length();
      hTPCTlength->Fill(TPCTrackLength);
      
      // Chris::get sorted points for the track object [assuming downwards going]      
      std::vector<recob::Track::Point_t> sorted_trk;
      SortTrackPoints(my_TPCTrack,sorted_trk);
      
      auto const& top    = sorted_trk.at(0);
      auto const& bottom = sorted_trk.at(sorted_trk.size() - 1);
      
      
      const std::vector<const anab::T0*>& T0_v = trk_t0_assn_v.at(i);
      
      const std::vector<const recob::OpFlash*>& flash_v = trk_flash_assn_v.at(i);
      
      const std::vector<const anab::Calorimetry*>& Calo_v = trk_calo_assn_v.at(i);
      
      if(verbose_!=0){    
	std::cout<< " Track "<<i<<" for this event has\t"
		 << flash_v.size() << "\tflash objects associated to this track["<<i<<"]\t"
		 << T0_v.size() << "\tT0 objects associated to this track["<<i<<"]\t"
		 << Calo_v.size() << "\tCalorimetry objects associated to this track["<<i<<"]" << std::endl;  
	
	if( (flash_v.size() != 0) || (T0_v.size() != 0) ) getchar();
      }
      
      
      
      if( (flash_v.size() != 0) && (T0_v.size() != 0)  ){//B
	
	auto t0 = T0_v.at(0);
	auto TimeT0 = t0->Time();
	auto TimeT0_ns = (TimeT0 * 1000);      
	
	auto flash = flash_v.at(0);
	auto Timeflash = flash->Time(); //in us from trigger time 
	auto Timeflash_ns = (Timeflash * 1000);
	auto Timeflash_ns_GPS = evt_timeGPS_nsec + (Timeflash * 1000);
	uint32_t Flash_sec = evt_timeGPS_sec;
	auto TotalPE = flash->TotalPE();
	double FlashY = flash->YCenter();
	double FlashZ = flash->ZCenter();
	
	hFlashTimeDis->Fill(Timeflash);
	hFlashZY->Fill(FlashZ,FlashY);
	hPES->Fill(TotalPE);
	hPESvsZ->Fill(FlashZ,TotalPE);      
	
	//Correct track position by T0
	double T[] = {top.X() - (TimeT0 * fvdrift_),top.Y(),top.Z()}; //x corrected by T0
	double B[] = {bottom.X() - (TimeT0 * fvdrift_),bottom.Y(),bottom.Z()};//x corrected by T0
	double V[] = {B[0] - T[0], B[1] - T[1], B[2] - T[2]};
	//Correct track position by T0
	
	double TrackTheta = crt::auxfunctions::CalTheta(V[0],V[1],V[2]);
	double TrackPhi = crt::auxfunctions::CalPhi(V[0],V[1],V[2]);
	
	double TotCal= CalorInter(Calo_v);
	auto TotCalNorm = TotCal/TPCTrackLength;
	
	hCalvsLen->Fill(TotCal,TPCTrackLength);
	hTotCalNorm->Fill(TotCalNorm);
	
	if(verbose_!=0){
	  std::cout<<"Flash information: this flash is in time with TPC track "<<i<<std::endl;
	  std::cout<<"Flash time: "<<Flash_sec<< " seconds"<<std::endl;
	  std::cout<<"Flash time: "<<Timeflash<< "  us w.r.t to trigger"<<std::endl;
	  std::cout<<"Flash time: "<<Timeflash_ns<< "  ns w.r.t to trigger"<<std::endl;
	  std::cout<<"Flash time: "<<Timeflash_ns_GPS<< "  ns in GPS"<<std::endl;
	  
	  std::cout<<"T0::Time:  "<<TimeT0<< " us w.r.t to trigger"<<std::endl;
	  std::cout<<"T0::Time_ns:  "<<TimeT0_ns<< " ns w.r.t to trigger"<<std::endl;
	  
	  std::cout<<"PES: "<<TotalPE<<std::endl;
	  std::cout<<"Calorimetry for this track is: "<<TotCal<<" ion e-"<<std::endl;
	  std::cout<<"TPC Track Length is: "<<TPCTrackLength<<" cm"<<std::endl;
	  std::cout<<"TrackTheta: "<<TrackTheta<<std::endl;
	  std::cout<<"TrackPhi: "<<TrackPhi<<std::endl;
	  getchar();
	  
	}
	
	int Hitcounter=0;
	
	for(std::vector<int>::size_type j = 0; j != CRTHitCollection.size(); j++) {//C
	  
	  crt::CRTHit my_CRTHit = CRTHitCollection[j];
	  
	  int Hit_sec = my_CRTHit.ts0_s;
	  
	  int Hit_T1_nsec = my_CRTHit.ts1_ns + fHardDelay_;
	  int Hit_T0_nsec = my_CRTHit.ts0_ns + fCRTT0off_;
	  
	  int diff_sec = Flash_sec - Hit_sec;
	  int diff_secABS = std::abs(diff_sec);
	  
	  int diffT1_nsec = Timeflash_ns - Hit_T1_nsec;
	  int diffT1_nsecABS = std::abs(diffT1_nsec);
	  
	  int diffT0_nsec = Timeflash_ns_GPS - Hit_T0_nsec;
	  int diffT0_nsecABS = std::abs(diffT0_nsec);
	  
	  hTFvsTH_t1->Fill(diffT1_nsec);
	  hTFvsTH_t0->Fill(diffT0_nsec);
	  //hTFvsTH_t0_t1->Fill(diffT0_nsecABS, diffT1_nsecABS);
	  hTFvsTH_t0_t1->Fill(diffT0_nsec, diffT1_nsec);
	  
	  //if( ((diffT1_nsec)>(300))  &&  ((diffT1_nsec)<(600)) ){//D : cut in time, T1 matched with Flash
	  if(diffT0_nsecABS<500){//D : cut in GPS Match
	    
	    hTPCXY_bottom -> Fill(bottom.X() - (TimeT0 * fvdrift_), bottom.Y());
	    hTPCZY_bottom -> Fill(bottom.Z(), bottom.Y());
	    
	    hTPCXY_top -> Fill(top.X() - (TimeT0 * fvdrift_), top.Y());
	    hTPCZY_top -> Fill(top.Z(), top.Y());
	    
	    hCRTXY->Fill(my_CRTHit.x_pos,my_CRTHit.y_pos);
	    hCRTZY->Fill(my_CRTHit.z_pos,my_CRTHit.y_pos);
	    
	    
	    Hitcounter++;
	    
	    if(my_CRTHit.plane==0){//Bottom Hits
	      
	      double BotY = -261; //Intersection with Bottom
	      
	      double Xcal = ( ( ( BotY - T[1]) / V[1]    ) * V[0] ) + T[0];
	      double Zcal = ( ( ( BotY - T[1]) / V[1]    ) * V[2] ) + T[2];
	      
	      hDiffX_bot->Fill(Xcal - my_CRTHit.x_pos);
	      hDiffZ_bot->Fill(Zcal - my_CRTHit.z_pos);
	      
	      hDiffXvsX_bot->Fill(my_CRTHit.x_pos,Xcal - my_CRTHit.x_pos);
	      hDiffXvsX_bot_prof->Fill(my_CRTHit.x_pos, Xcal - my_CRTHit.x_pos);
	      
	      hBot->Fill(Zcal,Xcal);
	      
	      hDiffXvsCal_bot->Fill(TotCalNorm, Xcal - my_CRTHit.x_pos);
	      hDiffXvsCal_bot_prof->Fill(TotCalNorm, Xcal - my_CRTHit.x_pos);
	      
	    }//Bottom Hits
	    
	    
	    if(my_CRTHit.plane==1){//FT Hits
	      
	      double FT_X = -142.484;//Intersection with Feedthrough
	      
	      double Ycal = ( ( ( FT_X - T[0]) / V[0]    ) * V[1] ) + T[1];
	      double Zcal = ( ( ( FT_X - T[0]) / V[0]    ) * V[2] ) + T[2];
	      
	      hDiffY_ft->Fill(Ycal - my_CRTHit.y_pos);
	      hDiffZ_ft->Fill(Zcal - my_CRTHit.z_pos);
	      
	      hFT->Fill(Zcal,Ycal);
	      
	      
	    }//Intersection with Feedthrough
	    
	    
	    if(my_CRTHit.plane==2){//Pipe Hits
	      
	      double Pipe_X = 383.016;//Intersection with Pipe //average->3 layers, 2 intersections
	      
	      double Ycal = ( ( ( Pipe_X - T[0]) / V[0]    ) * V[1] ) + T[1];
	      double Zcal = ( ( ( Pipe_X - T[0]) / V[0]    ) * V[2] ) + T[2];
	      
	      
	      Ycal = Ycal + (0.103531 * my_CRTHit.y_pos); //Ycorr
	      
	      hDiffY_pipe->Fill(Ycal - my_CRTHit.y_pos);
	      hDiffZ_pipe->Fill(Zcal - my_CRTHit.z_pos);
	      
	      hDiffY_pipe_vsY->Fill(my_CRTHit.y_pos,Ycal - my_CRTHit.y_pos);
	      hDiffY_pipe_vsY_prof->Fill(my_CRTHit.y_pos,Ycal - my_CRTHit.y_pos);
	      
	      
	      hPipe->Fill(Zcal,Ycal);
	      
	    }//Pipe Hits
	    
	    if(my_CRTHit.plane==3){//Top Hits
	      
	      double TopY = 658.25;
	      
	      double Xcal = ( ( ( TopY - T[1]) / V[1]    ) * V[0] ) + T[0];
	      double Zcal = ( ( ( TopY - T[1]) / V[1]    ) * V[2] ) + T[2];
	      
	      hDiffX_top->Fill(Xcal - my_CRTHit.x_pos);
	      hDiffZ_top->Fill(Zcal - my_CRTHit.z_pos);
	      
	      hTop->Fill(Zcal,Xcal);
	      
	    }//Top Hits
	    
	    if(verbose_==3){
	      std::cout<<"Flash_sec - Hit_sec: "<<diff_sec<<std::endl;
	      std::cout<<"ABS( Flash_sec - Hit_sec ): "<<diff_secABS<<std::endl;
	      std::cout<<" "<<std::endl;
	      std::cout<<"Hit_ns(T1): "<<Hit_T1_nsec<<std::endl;
	      std::cout<<"Flash_nsec(w.r.t. Trigger): "<<Timeflash_ns<<std::endl;
	      std::cout<<"     Flash_nsec - Hit_nsec(T1)  : "<<diffT1_nsec<<std::endl;
	      std::cout<<"ABS( Flash_nsec - Hit_nsec(T1) ): "<<diffT1_nsecABS<<std::endl;
	      std::cout<<" "<<std::endl;
	      std::cout<<"Hit_ns(T0): "<<Hit_T0_nsec<<std::endl;
	      std::cout<<"Flash_nsec(GPS units): "<<Timeflash_ns_GPS<<std::endl;
	      std::cout<<"     Flash_nsec - Hit_nsec(T0)  : "<<diffT0_nsec<<std::endl;
	      std::cout<<"ABS( Flash_nsec - Hit_nsec(T0) ): "<<diffT0_nsecABS<<std::endl;
	      getchar();
	    }
	    
	  }//D : cut in time, T1 matched with Flash  
	  
	}//C  //Hits loop
	
	hNCRTHitsperFlash->Fill(Hitcounter);
	hNCRTHitsperFlashClone->Fill(Hitcounter);
	
        
	int Trackcounter=0;      
	
	for(std::vector<int>::size_type k = 0; k != CRTTrackCollection.size(); k++) {//E
	  
	  crt::CRTTrack my_CRTTrack = CRTTrackCollection[k];
	  
	  int CRTTrack_sec = my_CRTTrack.ts0_s;                                                                            
	  
	  int CRTTrack_T1_nsec = my_CRTTrack.ts1_ns + fHardDelay_;                                                         
	  int CRTTrack_T0_nsec = my_CRTTrack.ts0_ns + fCRTT0off_;                                                                       
	  
	  int Tdiff_sec = Flash_sec - CRTTrack_sec;                                                                        
	  int Tdiff_secABS = std::abs(Tdiff_sec);                                                                       
	  
	  int TdiffT1_nsec = Timeflash_ns - CRTTrack_T1_nsec;                                                              
	  int TdiffT1_nsecABS = std::abs(TdiffT1_nsec);                                                                 
	  
	  int TdiffT0_nsec = Timeflash_ns_GPS - CRTTrack_T0_nsec;                                                          
	  int TdiffT0_nsecABS = std::abs(TdiffT0_nsec);                                                                 
	  
	  
	  hTFvsTT_t1->Fill(TdiffT1_nsec);
	  hTFvsTT_t0->Fill(TdiffT0_nsec);
	  //hTFvsTT_t0_t1->Fill(TdiffT0_nsecABS, TdiffT1_nsecABS);
	  hTFvsTT_t0_t1->Fill(TdiffT0_nsec, TdiffT1_nsec);
	  
	  
	  //if( ((TdiffT1_nsec)>300)  &&  ((TdiffT1_nsec)<600) ){//F:: cut in time T1
	  if(TdiffT0_nsecABS<500){//F : cut in GPS Match	    

	    Trackcounter++;
	    hTPCTvsCRTT->Fill(my_CRTTrack.length,TPCTrackLength);
	    
	    
	    //flash and CRTTrack
	    double Th1[] = {my_CRTTrack.x1_pos,my_CRTTrack.y1_pos,my_CRTTrack.z1_pos};
	    double Th2[] = {my_CRTTrack.x2_pos,my_CRTTrack.y2_pos,my_CRTTrack.z2_pos};
	    double TV[]  = {Th2[0] - Th1[0], Th2[1] - Th1[1], Th2[2] - Th1[2]};
	    
	    double CRT_Z_atTPC_Y0 = ( ( ( 0 - Th1[1]) / TV[1]    ) * TV[2] ) + Th1[2]; //Z del CRTTrack at TPC Y=0
	    double CRT_Y_atTPC_Y0 = ( ( ( FlashZ - Th1[2]) / TV[2]    ) * TV[1] ) + Th1[1];
	    
	    double CRTTheta = CalTheta(TV[0],TV[1],TV[2]);
	    double CRTPhi = CalPhi(TV[0],TV[1],TV[2]);
	    
	    hTheta->Fill(CRTTheta);
	    hPhi->Fill(CRTPhi);
	    
	    
	    if(verbose_==7){
	      std::cout.precision(19);                                                                                  
	      std::cout<<"Flash_nsec(w.r.t. Trigger): "<<Timeflash_ns<<std::endl;                                       
	      std::cout<<"CRT_Track_ns(T1): "<<CRTTrack_T1_nsec<<std::endl;
	      std::cout<<"                                   Time Diff:: "<<Timeflash_ns - CRTTrack_T1_nsec<<std::endl;
	      std::cout<<"TPC DV-> X: "<<V[0]<<" Y: "<<V[1]<<" Z: "<<V[2]<<std::endl;
	      std::cout<<"CRT DV-> X: "<<TV[0]<<" Y: "<<TV[1]<<" Z: "<<TV[2]<<std::endl;
	      std::cout<<"TPCTrack_Theta: "<<TrackTheta<<"  TPCTrack_Phi: "<<TrackPhi<<std::endl;                            
	      std::cout<<"CRTTrack_Theta: "<<CRTTheta<<"    CRTTrack_Phi: "<<CRTPhi<<std::endl;                                                      
	      getchar();	  
	    }
	    
	    hDiffTheta->Fill(TrackTheta-CRTTheta);
	    hDiffPhi->Fill(TrackPhi-CRTPhi);
	    hDiffTheta2D->Fill(TrackTheta,CRTTheta);
	    hDiffPhi2D->Fill(TrackPhi,CRTPhi);
	    hDiffThetaPhi2D->Fill(TrackTheta-CRTTheta,TrackPhi-CRTPhi);
	    
	    hDiffThetavsTPCLength->Fill(TrackTheta-CRTTheta,TPCTrackLength);
	    
	    hDiffY_FlaTra->Fill(FlashY - CRT_Y_atTPC_Y0);
	    hDiffY_FlaTra2D->Fill(FlashY,CRT_Y_atTPC_Y0);
	    hDiffY_FlaTra2D_prof->Fill(FlashY,CRT_Y_atTPC_Y0);
	    
	    hDiffZ_FlaTra->Fill(FlashZ - CRT_Z_atTPC_Y0);
	    hDiffZ_FlaTra2D->Fill(FlashZ,CRT_Z_atTPC_Y0);
	    hDiffZ_FlaTra2D_prof->Fill(FlashZ,CRT_Z_atTPC_Y0);
	    
	    if(verbose_==1){                                                                                            
	      std::cout.precision(19);                                                                                  
	      std::cout<<"Flash_sec - Track_sec: "<<Tdiff_sec<<std::endl;                                               
	      std::cout<<"ABS( Flash_sec - Track_sec ): "<<Tdiff_secABS<<std::endl;                                     
	      std::cout<<" "<<std::endl;                                                                                
	      std::cout<<"Track_ns(T1): "<<CRTTrack_T1_nsec<<std::endl;                                                    
	      std::cout<<"Flash_nsec(w.r.t. Trigger): "<<Timeflash_ns<<std::endl;                                       
	      std::cout<<"     Flash_nsec - Track_nsec(T1)  : "<<TdiffT1_nsec<<std::endl;                               
	      std::cout<<"ABS( Flash_nsec - Track_nsec(T1) ): "<<TdiffT1_nsecABS<<std::endl;                            
	      std::cout<<" "<<std::endl;                                                                                
	      std::cout<<"Track_ns(T0): "<<CRTTrack_T0_nsec<<std::endl;                                                    
	      std::cout<<"Flash_nsec(GPS units): "<<Timeflash_ns_GPS<<std::endl;                                        
	      std::cout<<"     Flash_nsec - Track_nsec(T0)  : "<<TdiffT0_nsec<<std::endl;                               
	      std::cout<<"ABS( Flash_nsec - Track_nsec(T0) ): "<<TdiffT0_nsecABS<<std::endl;                            
	      getchar();                                                                                                
	    }
	    
	  }//F  
	  
	  
	  hNCRTTracksperFlash->Fill(Trackcounter);
	  hNCRTTracksperFlashClone->Fill(Trackcounter);
	  
	}//E
        
      }//B
    }//A
  }//A0 //cut in shower events  
  
}

void crt::CRTeffStd::beginJob()
{
  // Implementation of optional member function here.
  
  hFlashTimeDis = tfs->make<TH1F>("hFlashTimDis","hFlashTimDis",8500,-3500,5000);//Cosmic activity
  hFlashTimeDis->GetXaxis()->SetTitle("Flash Time w.r.t. trigger (us)");
  hFlashTimeDis->GetYaxis()->SetTitle("Entries/bin");
  
  hTFvsTH_t1 = tfs->make<TH1F>("hBeamMatching","hBeamMatching",500,-1000,1000);
  hTFvsTH_t1->GetXaxis()->SetTitle("Flash Time w.r.t. trigger - CRTHit Time_t1 (ns)");
  hTFvsTH_t1->GetYaxis()->SetTitle("Entries/bin");
  
  hTFvsTH_t0 = tfs->make<TH1F>("hGPSMatching","GPSMatching",500,-1000,1000);
  hTFvsTH_t0->GetXaxis()->SetTitle("Flash_Time_GPS - CRTHit_Time_T0 (ns)");
  hTFvsTH_t0->GetYaxis()->SetTitle("Entries/bin");
  
  hTFvsTH_t0_t1 = tfs->make<TH2F>("hGPSBeamMatching","hGPSBeamMatching",500,-500,500,500,0,1000);
  hTFvsTH_t0_t1->GetXaxis()->SetTitle("Flash_Time_GPS - CRTHit_Time_T0 (ns)");
  hTFvsTH_t0_t1->GetYaxis()->SetTitle("Flash Time w.r.t Trigger - CRTHit_Time_t1 (ns)");
  hTFvsTH_t0_t1->SetOption("COLZ");
  
  
  hTFvsTT_t1 = tfs->make<TH1F>("hBeamMatchingTrack","hBeamMatchingTrack",30000,-25000,25000);
  hTFvsTT_t1->GetXaxis()->SetTitle("Flash Time w.r.t. trigger - CRTTrack Time_t1 (ns)");
  hTFvsTT_t1->GetYaxis()->SetTitle("Entries/bin");
  
  hTFvsTT_t0 = tfs->make<TH1F>("hGPSMatchingTrack","GPSMatchingTrack",500,-1000,1000);
  hTFvsTT_t0->GetXaxis()->SetTitle("Flash_Time_GPS - CRTTrack_Time_T0 (ns)");
  hTFvsTT_t0->GetYaxis()->SetTitle("Entries/bin");
  
  hTFvsTT_t0_t1 = tfs->make<TH2F>("hGPSBeamMatchingTrack","hGPSBeamMatchingTrack",500,-500,500,500,0,1000);
  hTFvsTT_t0_t1->GetXaxis()->SetTitle("Flash_Time_GPS - CRTTrack_Time_T0 (ns)");
  hTFvsTT_t0_t1->GetYaxis()->SetTitle("Flash Time w.r.t Trigger - CRTTrack_Time_t1 (ns)");
  hTFvsTT_t0_t1->SetOption("COLZ");
  

  hTPCTvsCRTT = tfs->make<TH2F>("hTPCTvsCRTT","hTPCTvsCRTT",140, 0, 1400 ,120, 0, 600);
  hTPCTvsCRTT->GetXaxis()->SetTitle("CRT Track Length (cm)");
  hTPCTvsCRTT->GetYaxis()->SetTitle("TPC Track Length (cm)");
  hTPCTvsCRTT->SetOption("COLZ");
  
  hTPCTlength = tfs->make<TH1F>("hTPCLength","hTPCLength",800,0,800);
  hTPCTlength->GetXaxis()->SetTitle("TPC Track Length (cm)");
  hTPCTlength->GetYaxis()->SetTitle("Entries/bin");

  hNCRTHitsperFlash = tfs->make<TH1F>("hNCRTHitsperFlash","hNCRTHitsperFlash",8,-1,7);
  hNCRTHitsperFlash->GetXaxis()->SetTitle("Number of CRTHits on time with T0 flashes");
  hNCRTHitsperFlash->GetYaxis()->SetTitle("Entries/bin");

  hNCRTHitsperFlashClone = tfs->make<TH1F>("hNCRTHitsperFlashFrac","hNCRTHitsperFlashFrac",8,-1,7);
  hNCRTHitsperFlashClone->GetXaxis()->SetTitle("Number of CRTHits on time with T0 flashes");
  hNCRTHitsperFlashClone->GetYaxis()->SetTitle("Fraction of events");


  hNCRTTracksperFlash = tfs->make<TH1F>("hNCRTTracksperFlash","hNCRTTracksperFlash",8,-1,7);
  hNCRTTracksperFlash->GetXaxis()->SetTitle("Number of CRTTrack on time with T0 flashes");
  hNCRTTracksperFlash->GetYaxis()->SetTitle("Entries/bin");

  hNCRTTracksperFlashClone = tfs->make<TH1F>("hNCRTTracksperFlashFrac","hNCRTTracksperFlashFrac",8,-1,7);
  hNCRTTracksperFlashClone->GetXaxis()->SetTitle("Number of CRTTracks on time with T0 flashes");
  hNCRTTracksperFlashClone->GetYaxis()->SetTitle("Fraction of events");


  hDiffX_bot = tfs->make<TH1F>("hDiffX_bot","hDiffX_bot",500,-500,500);
  hDiffX_bot->GetXaxis()->SetTitle("Difference X CRTHit and TPC Track (cm)");
  hDiffX_bot->GetYaxis()->SetTitle("Entries/bin");

  hDiffZ_bot = tfs->make<TH1F>("hDiffZ_bot","hDiffZ_bot",500,-500,500);
  hDiffZ_bot->GetXaxis()->SetTitle("Difference Z CRTHit and TPC Track (cm)");
  hDiffZ_bot->GetYaxis()->SetTitle("Entries/bin");


  hDiffY_ft = tfs->make<TH1F>("hDiffY_ft","hDiffY_ft",500,-500,500);
  hDiffY_ft->GetXaxis()->SetTitle("Difference Y CRTHit and TPC Track (cm)");
  hDiffY_ft->GetYaxis()->SetTitle("Entries/bin");

  hDiffZ_ft = tfs->make<TH1F>("hDiffZ_ft","hDiffZ_ft",500,-500,500);
  hDiffZ_ft->GetXaxis()->SetTitle("Difference Z CRTHit and TPC Track (cm)");
  hDiffZ_ft->GetYaxis()->SetTitle("Entries/bin");

  hDiffY_pipe = tfs->make<TH1F>("hDiffY_pipe","hDiffY_pipe",500,-500,500);
  hDiffY_pipe->GetXaxis()->SetTitle("Difference Y CRTHit and TPC Track (cm)");
  hDiffY_pipe->GetYaxis()->SetTitle("Entries/bin");

  double inch =2.54; //inch in cm                                                                                                                  
  hDiffY_pipe_vsY = tfs->make<TH2F>("hDiffY_pipe_vsY","hDiffY_pipe_vsY",60,-294-19.1*inch,-294-19.1*inch+60*10.89, 500,-500,500);
  hDiffY_pipe_vsY->GetXaxis()->SetTitle("Height (cm)");
  hDiffY_pipe_vsY->GetYaxis()->SetTitle("Difference Y CRTHit and TPC Track (cm)");

  hDiffY_pipe_vsY_prof = tfs->make<TProfile>("hDiffY_pipe_vsY_prof","hDiffY_pipe_vsY_prof",60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  hDiffY_pipe_vsY_prof->GetXaxis()->SetTitle("Height (cm)");
  hDiffY_pipe_vsY_prof->GetYaxis()->SetTitle("Difference Y CRTHit and TPC Track (cm)");


  hDiffZ_pipe = tfs->make<TH1F>("hDiffZ_pipe","hDiffZ_pipe",500,-500,500);
  hDiffZ_pipe->GetXaxis()->SetTitle("Difference Z CRTHit and TPC Track (cm)");
  hDiffZ_pipe->GetYaxis()->SetTitle("Entries/bin");

  hDiffX_top = tfs->make<TH1F>("hDiffX_top","hDiffX_top",500,-500,500);
  hDiffX_top->GetXaxis()->SetTitle("Difference X CRTHit and TPC Track (cm)");
  hDiffX_top->GetYaxis()->SetTitle("Entries/bin");

  hDiffZ_top = tfs->make<TH1F>("hDiffZ_top","hDiffZ_top",500,-500,500);
  hDiffZ_top->GetXaxis()->SetTitle("Difference Z CRTHit and TPC Track (cm)");
  hDiffZ_top->GetYaxis()->SetTitle("Entries/bin");

  hBot = tfs->make<TH2F>("hBottom","Bottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  hBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  hBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  hBot->GetZaxis()->SetTitle("Entries/bin");
  hBot->SetOption("COLZ");

  hFT = tfs->make<TH2F>("hFeedthroughSide","Feedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
  hFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  hFT->GetYaxis()->SetTitle("Height (cm)");
  hFT->GetZaxis()->SetTitle("Entries/bin");
  hFT->SetOption("COLZ");

  hPipe = tfs->make<TH2F>("hPipeSide","Pipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  hPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  hPipe->GetYaxis()->SetTitle("Height (cm)");
  hPipe->GetZaxis()->SetTitle("Entries/bin");
  hPipe->SetOption("COLZ");

  hTop = tfs->make<TH2F>("hTop","Top",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
  hTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  hTop->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  hTop->GetZaxis()->SetTitle("Entries/bin");
  hTop->SetOption("COLZ");

  
  hDiffXvsX_bot = tfs->make<TH2F>("hDiffXvsX_bot","hDiffXvsX_bot",350,-200,500,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  hDiffXvsX_bot->GetXaxis()->SetTitle("Lenght along the drift (cm)");
  hDiffXvsX_bot->GetYaxis()->SetTitle("Difference X CRTHit and TPC Track (cm)");

  hDiffXvsX_bot_prof = tfs->make<TProfile>("hDiffXvsX_bot_prof","hDiffXvsX_bot_prof",350,-200,500);
  hDiffXvsX_bot_prof->GetXaxis()->SetTitle("Lenght along the drift (cm)");
  hDiffXvsX_bot_prof->GetYaxis()->SetTitle("Difference X CRTHit and TPC Track (cm)");

  hDiffZ_FlaTra = tfs->make<TH1F>("hDiffZ_FlaTra","hDiffZ_FlaTra",100,-100,100);
  hDiffZ_FlaTra->GetXaxis()->SetTitle("DiffZ_FlaTra at Y0 (cm)");
  hDiffZ_FlaTra->GetYaxis()->SetTitle("Entries/bin");

  hDiffZ_FlaTra2D = tfs->make<TH2F>("hDiffZ_FlaTra2D","hDiffZ_FlaTra2D",100,-704+205*inch,-704+205*inch+125*10.89,100,-704+205*inch,-704+205*inch+125*10.89);
  hDiffZ_FlaTra2D->GetXaxis()->SetTitle(" Flash Z ");
  hDiffZ_FlaTra2D->GetYaxis()->SetTitle(" CRTTrack Z at Y=0");

  hDiffZ_FlaTra2D_prof = tfs->make<TProfile>("hDiffZ_FlaTra2D_prof","hDiffZ_FlaTra2D_prof",100,-704+205*inch,-704+205*inch+125*10.89);
  hDiffZ_FlaTra2D_prof->GetXaxis()->SetTitle(" Flash Z ");
  hDiffZ_FlaTra2D_prof->GetYaxis()->SetTitle(" CRTTrack Z at Y=0");

  hDiffY_FlaTra = tfs->make<TH1F>("hDiffY_FlaTra","hDiffZ_FlaTra",100,-100,100);
  hDiffY_FlaTra->GetXaxis()->SetTitle("DiffY_FlaTra at Y0 (cm)");
  hDiffY_FlaTra->GetYaxis()->SetTitle("Entries/bin");

  hDiffY_FlaTra2D = tfs->make<TH2F>("hDiffY_FlaTra2D","hDiffY_FlaTra2D",100,-100,100,100,-100,100);
  hDiffY_FlaTra2D->GetXaxis()->SetTitle(" Flash Y ");
  hDiffY_FlaTra2D->GetYaxis()->SetTitle(" CRTTrack Y at Y=0");

  hDiffY_FlaTra2D_prof = tfs->make<TProfile>("hDiffY_FlaTra2D_prof","hDiffY_FlaTra2D_prof",100,-100,100);
  hDiffY_FlaTra2D_prof->GetXaxis()->SetTitle(" Flash Y ");
  hDiffY_FlaTra2D_prof->GetYaxis()->SetTitle(" CRTTrack Y at Y=0");

  hPES = tfs->make<TH1F>("hPES","hPES",250,0,2500);
  hPES->GetXaxis()->SetTitle("Number of Photoelectrons per Flash");
  hPES->GetYaxis()->SetTitle("Entries/bin");

  hPESvsZ = tfs->make<TH2F>("hPESvsZ","hPESvsZ",1500,-100,1400,250,0,2500);
  hPESvsZ->GetXaxis()->SetTitle(" Flash Z ");
  hPESvsZ->GetYaxis()->SetTitle(" PES");

  hFlashZY = tfs->make<TH2F>("hFlashZY","hFlashZY",1500,-100,1400,200,-200,200);
  hFlashZY->GetXaxis()->SetTitle(" Flash Z (cm) ");
  hFlashZY->GetYaxis()->SetTitle(" Flash Y (cm)");


  hDiffXvsCal_bot = tfs->make<TH2F>("hDiffXvsCal_bot","hDiffXvsCal_bot",250,0,2500,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  hDiffXvsCal_bot->GetXaxis()->SetTitle("Track Calorimetry (ion e-/cm)");
  hDiffXvsCal_bot->GetYaxis()->SetTitle("Difference X CRTHit and TPC Track (cm)");

  hDiffXvsCal_bot_prof = tfs->make<TProfile>("hDiffXvsCal_bot_prof","hDiffXvsCal_bot_prof",250,0,2500);
  hDiffXvsCal_bot_prof->GetXaxis()->SetTitle("Track Calorimetry (ion e-/cm)");
  hDiffXvsCal_bot_prof->GetYaxis()->SetTitle("Difference X CRTHit and TPC Track (cm)");

  
  hCalvsLen = tfs->make<TH2F>("hCalvsLen","hCalvsLen",1000,0,100000,100,0,500);
  hCalvsLen->GetXaxis()->SetTitle("Track Calorimetry (ion e-)");
  hCalvsLen->GetYaxis()->SetTitle("TPC Track Length (cm)");
  
  
  hTotCalNorm = tfs->make<TH1F>("hTotCalNorm","hTotCalNorm",250,0,2500);
  hTotCalNorm->GetXaxis()->SetTitle("Track Calorimetry/Length (ion e-/cm)");
  hTotCalNorm->GetYaxis()->SetTitle("Entries/bin");
  
  hDiffTheta = tfs->make<TH1F>("hDiffTheta","hDiffTheta",400,-100,100);
  hDiffTheta->GetXaxis()->SetTitle("TPC Track Theta - CRT Track Theta");
  hDiffTheta->GetYaxis()->SetTitle("Entries/bin");

  hDiffPhi = tfs->make<TH1F>("hDiffPhi","hDiffPhi",800,-200,200);
  hDiffPhi->GetXaxis()->SetTitle("TPC Track Phi - CRT Track Phi");
  hDiffPhi->GetYaxis()->SetTitle("Entries/bin");

  hDiffTheta2D = tfs->make<TH2F>("hDiffTheta2D","hDiffTheta2D",200,0,100,200,0,100);
  hDiffTheta2D->GetXaxis()->SetTitle("TPC Track Theta");
  hDiffTheta2D->GetYaxis()->SetTitle("CRT Track Theta");

  hDiffPhi2D = tfs->make<TH2F>("hDiffPhi2D","hDiffPhi2D",800,-200,200,800,-200,200);
  hDiffPhi2D->GetXaxis()->SetTitle("TPC Track Phi");
  hDiffPhi2D->GetYaxis()->SetTitle("CRT Track Phi");

  hDiffThetaPhi2D = tfs->make<TH2F>("hDiffThetaPhi2D","hDiffThetaPhi2D",400,-50,50,400,-50,50);
  hDiffThetaPhi2D->GetXaxis()->SetTitle("TPC Track Theta - CRT Track Theta");
  hDiffThetaPhi2D->GetYaxis()->SetTitle("TPC Track Phi - CRT Track Phi");

  hDiffThetavsTPCLength = tfs->make<TH2F>("hDiffThetavsTPCLength","hDiffThetavsTPCLength",400,-200,200,500,0,500);
  hDiffThetavsTPCLength->GetXaxis()->SetTitle("TPC Track Theta - CRT Track Theta");
  hDiffThetavsTPCLength->GetYaxis()->SetTitle("TPC Track Length (cm)");
  hDiffThetavsTPCLength->SetOption("COLZ");

  hTPCXY_top = tfs->make<TH2F>("hTPCXY_top","hTPCXY_top",1200,-300+50.4*inch,-300+50.4*inch+60*10.89, 1200,-308-19.1*inch,200+2*(-308-19.1*inch+60*10.89));
  hTPCXY_top->GetXaxis()->SetTitle("Length along the drift (cm)");
  hTPCXY_top->GetYaxis()->SetTitle("Height (cm)");

  hTPCZY_top = tfs->make<TH2F>("hTPCZY_top","hTPCZY_top",2500,-700+205*inch,-700+205*inch+125*10.89, 1200,-308-19.1*inch,200+2*(-308-19.1*inch+60*10.89));
  hTPCZY_top->GetXaxis()->SetTitle("Length along the Beam (cm)");
  hTPCZY_top->GetYaxis()->SetTitle("Height (cm)");

  hTPCXY_bottom = tfs->make<TH2F>("hTPCXY_bottom","hTPCXY_bottom",1200,-300+50.4*inch,-300+50.4*inch+60*10.89, 1200,-308-19.1*inch,200+2*(-308-19.1*inch+60*10.89));
  hTPCXY_bottom->GetXaxis()->SetTitle("Length along the drift (cm)");
  hTPCXY_bottom->GetYaxis()->SetTitle("Height (cm)");

  hTPCZY_bottom = tfs->make<TH2F>("hTPCZY_bottom","hTPCZY_bottom",2500,-700+205*inch,-700+205*inch+125*10.89, 1200,-308-19.1*inch,200+2*(-308-19.1*inch+60*10.89));
  hTPCZY_bottom->GetXaxis()->SetTitle("Length along the Beam (cm)");
  hTPCZY_bottom->GetYaxis()->SetTitle("Height (cm)");

  hCRTXY = tfs->make<TH2F>("hCRTXY","hCRTXY",1200,-300+50.4*inch,-300+50.4*inch+60*10.89, 1200,-308-19.1*inch,200+2*(-308-19.1*inch+60*10.89));
  hCRTXY->GetXaxis()->SetTitle("Length along the drift (cm)");
  hCRTXY->GetYaxis()->SetTitle("Height (cm)");
    
  hCRTZY = tfs->make<TH2F>("hCRTZY","hCRTZY",2500,-700+205*inch,-700+205*inch+125*10.89, 1200,-308-19.1*inch,200+2*(-308-19.1*inch+60*10.89));
  hCRTZY->GetXaxis()->SetTitle("Length along the Beam (cm)");
  hCRTZY->GetYaxis()->SetTitle("Height (cm)");

  hTheta = tfs->make<TH1F>("hTheta","hTheta",180,0,90);
  hTheta->GetXaxis()->SetTitle("CRT Theta (degrees)");
  hTheta->GetYaxis()->SetTitle("Entries/bin");

  hPhi = tfs->make<TH1F>("hPhi","hPhi",360,-90,90);
  hPhi->GetXaxis()->SetTitle("CRT Phi (degrees)");
  hPhi->GetYaxis()->SetTitle("Entries/bin");



}

void crt::CRTeffStd::endJob()
{

  // Implementation of optional member function here.
  Double_t norm = hNCRTHitsperFlashClone->GetEntries();
  hNCRTHitsperFlashClone->Scale(1/norm);

  Double_t normT = hNCRTTracksperFlashClone->GetEntries();
  hNCRTTracksperFlashClone->Scale(1/normT);

  
}

double crt::CRTeffStd::CalorInter(const std::vector<const anab::Calorimetry*>& Calo_v)
{
  double TotCal=0;
  //calorimetry
  for (size_t pl=0; pl < Calo_v.size(); pl++){
    
    auto const& calo = Calo_v.at(pl);
    auto const& plane = calo->PlaneID().Plane;
    if (plane == 2){
      
      auto const& dqdx_v = calo->dQdx();
      
      for (size_t n=0; n < dqdx_v.size(); n++){
	TotCal += dqdx_v[n]; //integrate calorimetry
      }
    }
  }
  //calorimetry
  
  return TotCal;
}


void crt::CRTeffStd::SortTrackPoints(const recob::Track& track, std::vector<recob::Track::Point_t>& sorted_trk)
{

  sorted_trk.clear();

  auto const&N = track.NumberTrajectoryPoints();
  auto const&start = track.LocationAtPoint(0);
  auto const&end   = track.LocationAtPoint( N - 1 );

  if (start.Y() > end.Y()){
    for (size_t i=0; i < N; i++)
      sorted_trk.push_back( track.LocationAtPoint(i) );
  }
                                                                                                                               
  else {
    for (size_t i=0; i < N; i++)
      sorted_trk.push_back( track.LocationAtPoint( N - i - 1) );
  }
}



double crt::CRTeffStd::CalTheta(double x, double y, double z){

  double PI = 3.14159265;
  double L = sqrt(pow(x,2) + pow(y,2) + pow(z,2));

  double Theta = acos( sqrt(pow(x,2) + pow(z,2) ) /L ) * (180/PI); 
  
  return Theta;

}

double crt::CRTeffStd::CalPhi(double x, double y, double z){
  
  double PI = 3.14159265;

  double Phi = atan(z/x) * (180/PI);

  return Phi;
}

DEFINE_ART_MODULE(crt::CRTeffStd)
