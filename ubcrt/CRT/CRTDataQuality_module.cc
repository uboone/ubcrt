////////////////////////////////////////////////////////////////////////
// Class:       CRTDataQuality
// Module Type: analyzer
// File:        CRTDataQuality_module.cc
//
// Generated at Thur March 28 2019 by Elena Gramellini
// Scope of this analyzer is a simple data quality monitor
// Compute the rate of cosmic rays in all CRT modules per date
// 
// [ x ] Read out CRT hits
// [ x ] Identify Corresponding Module
// [ x ] Count N Hit Per module in DeltaT
// [   ] Store the following in a ttree:
//            [ x ] date
//            [ x ] N hit per module
//            [ x ] FEBIndex
//            [ x ] DeltaT Readout
//            [ x ] AvgPe
//            [   ] AvgX, AvgY, AvgZ count
//            [   ] MaxX, MaxY, MaxZ count
//            [   ] MaxX, MaxY, MaxZ position
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardata/Utilities/AssociationUtil.h"

#include <artdaq-core/Data/Fragment.hh>

#include "art/Framework/Services/Optional/TFileService.h"

#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTzero.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

#include "TTree.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <typeinfo>
#include <iomanip>
#include <math.h>
#include <time.h>       /* time_t, struct tm, time, localtime, strftime */



//const int kMaxCRThits = 1000;
//const int kMaxCRTtzeros = 1000;
//const int kMaxCRTtracks = 1000;
//const int kMaxTPCtracks = 100;
//const int kMaxPMTflashes = 100;


 // namespace crt {
 //   class CRTDataQuality;
 // }

class CRTDataQuality : public art::EDAnalyzer {
public:
  explicit CRTDataQuality(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTDataQuality(CRTDataQuality const &) = delete;
  CRTDataQuality(CRTDataQuality &&) = delete;
  CRTDataQuality & operator = (CRTDataQuality const &) = delete;
  CRTDataQuality & operator = (CRTDataQuality &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions.
  void beginJob() override;
  void endJob() override;
  void ResetVar();
  void calculateFlashMatch(std::vector<crt::CRTHit> const CRTHitCollection, int &nFlashes, int &nMatchedFlashes);
  void calculateTrackMatch(std::vector<crt::CRTHit> const CRTHitCollection, int &nTracks , int &nMatchedTracks );

private:

  art::ServiceHandle<art::TFileService> tfs;
  art::ServiceHandle<art::TFileService> tfs1;

  // Declare member data here.
  std::string data_labelhit_;
  std::string data_label_DAQHeader_;
  double minT_ ;
  double maxT_ ;
  int    fTimeZeroOffset; 
  bool   verbose_;

  // TTree Variables
  TH1D*  hHitTime;
  TH1D*  hHitTimeAfterCut;
  TH1D*  hModule_X[73];
  TH1D*  hModule_Y[73];
  TH1D*  hModule_Z[73];

  TTree* fTree;
  int run;
  int subrun;
  int event;
  int date; // Time in seconds from linux start time
  int nFlashes;
  int nMatchedFlashes;
  int nTracks;
  int nMatchedTracks;
  // CRT Modules
  int nCRThits[73];
  double AvgPe[73];
  double reaoutTime;
  int febIndex[73]  = {11  , 12 ,14 ,17  ,18  ,19  ,  22 ,23  ,  24,
		       105 ,106 ,107,108 ,109 ,111 , 112 ,113 , 114, 
		       115 ,116 ,117,118 ,119 ,120 , 121 ,123 , 124, 
		       125 ,126 ,127,128 ,129 ,195 ,  26 , 27 , 28 , 
		       29  , 30 , 31, 52 , 56 , 57 , 58  , 59 , 60 , 
		       61  , 15 , 16, 20 , 21 , 32 , 33  , 34 , 35 , 
		       36  , 37 , 38, 39 , 40 , 41 , 42 ,  43 , 44 , 
		       45  , 46 , 47, 48 , 49 , 50 , 51 ,  53 , 54 , 55};
  
};


void CRTDataQuality::ResetVar()
{
  run             = -9999;
  subrun          = -9999;
  event           = -9999;
  date            = -9999; 
  nFlashes        = -9999; 
  nMatchedFlashes = -9999; 
  nTracks         = -9999; 
  nMatchedTracks  = -9999; 
  
  for (size_t i= 0; i < 73; i++ )
    {
      nCRThits[i]  = 0;
      AvgPe[i]     = 0.;
    }
   reaoutTime = -9999.;

}

CRTDataQuality::CRTDataQuality(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
    data_labelhit_(p.get<std::string>("data_labelhit_")),
    data_label_DAQHeader_(p.get<std::string>("data_label_DAQHeader_")),  
    minT_(p.get<double>("minT_",-1500000.)),
    maxT_(p.get<double>("maxT_", 3500000.)),
    fTimeZeroOffset(p.get<int>("fTimeZeroOffset",60000)),
    verbose_(p.get<bool>("verbose",true))
    // More initializers here.    
{
}

void CRTDataQuality::analyze(art::Event const & evt)
{
  ResetVar();
  // This will be useful for the date
  art::Timestamp        evtTime  = evt.time();

  long int timeInNsSec = (long int) evtTime.value () ;
  date = (int) (timeInNsSec >>  32 ); // Convert ns time stamp into second time stamp

 
  
  //Get GPS Time
  art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;  
  evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
    
  //check to make sure the data we asked for is valid 
  if(!rawHandle_DAQHeader.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
	      << ", event " << evt.event() << " has zero"
	      << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;    
    return;
  }
  raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader); 
  art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();  
  double evt_timeGPS_nsec = (double)evtTimeGPS.timeLow();  


  //get CRTHits
  art::Handle< std::vector<crt::CRTHit> > rawHandle_hit;
  evt.getByLabel(data_labelhit_, rawHandle_hit); 
  //check to make sure the data we asked for is valid
  if(!rawHandle_hit.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " CRTHits " << " in module " << data_labelhit_ << std::endl;
    std::cout << std::endl;
    return;
  } // This should throw an exception, but ok WRONG!


  run    = evt.run() ;
  subrun = evt.subRun() ;
  event  = evt.event() ;
  // Build FEB to ArrayIndex Conversion
  std::map<int, int> febIndexConversion;
  for (size_t iM = 0; iM<73 ; iM++ ) febIndexConversion[febIndex[iM] ] = iM;
 
  std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_hit);
 
  /*
  //    Stuff I care about
      AvgCountX[i] = -9999.;
      AvgCountY[i] = -9999.;
      AvgCountZ[i] = -9999.;
      MaxCountX[i] = -9999.;
      MaxCountY[i] = -9999.;
      MaxCountZ[i] = -9999.;
      MaxPositX[i] = -9999.;
      MaxPositY[i] = -9999.;
      MaxPositZ[i] = -9999.;
    }

   */

  
  // Loop over CRT Hits, keep them if they're within some readout time
  for(size_t j = 0; j < CRTHitCollection.size(); j++) {   
    crt::CRTHit my_CRTHit = CRTHitCollection[j];
    // Calculate the reaout time (time we're considering the CRT hit in)
    reaoutTime = maxT_ - minT_;
    // Calculate the time of this CRT Hit
    double thisHitTime =(double)my_CRTHit.ts0_ns - (double)evt_timeGPS_nsec + (double)fTimeZeroOffset;
    hHitTime->Fill(thisHitTime);
    // If the hit time is not within the readout time, skip
    if (thisHitTime < minT_ ) continue;
    if (thisHitTime > maxT_ ) continue;
    hHitTimeAfterCut->Fill(thisHitTime);
    // Every hit is composed by 2 FEBs: the horizontal and vertical one
    auto febID_v = my_CRTHit.feb_id;
    for (auto const febID : febID_v) {
      int key   = (int) febID;
      int index = febIndexConversion[key];
     
      nCRThits[ index ]++ ;
      AvgPe   [ index ] += my_CRTHit.peshit ;
      hModule_X[ index ]->Fill(my_CRTHit.x_pos);
      hModule_Y[ index ]->Fill(my_CRTHit.y_pos);
      hModule_Z[ index ]->Fill(my_CRTHit.z_pos);
    } 
        
    /*
    hit_charge[j]         = my_CRTHit.peshit;
    hit_plane[j]          = my_CRTHit.plane%10;
    hit_posx[j]           = my_CRTHit.x_pos;
    hit_posy[j]           = my_CRTHit.y_pos;
    hit_posz[j]           = my_CRTHit.z_pos;
    
   
    */
  }//Loop on CRT hits

  
  for (size_t i = 0; i < 73; i++)
    {
      if (nCRThits[i]){  AvgPe[ i ] /= (float)nCRThits[i];}
      else AvgPe[ i ] = -999.;
    } 

 
  calculateFlashMatch(CRTHitCollection, nFlashes,nMatchedFlashes);
  calculateTrackMatch(CRTHitCollection, nTracks ,nMatchedTracks );


fTree->Fill();
}



void  CRTDataQuality::calculateFlashMatch(std::vector<crt::CRTHit> const CRTHitCollection, int &nFlashes, int &nMatchedFlashes)
{
  std::cout<<CRTHitCollection.size()<<"\n";
  /*Michelle's code */
}

void  CRTDataQuality::calculateTrackMatch(std::vector<crt::CRTHit> const CRTHitCollection, int &nTracks ,int &nMatchedTracks )
{
  std::cout<<CRTHitCollection.size()<<"\n";
  /*Michelle's code */
}



void CRTDataQuality::beginJob()
{
  // Implementation of optional member function here.
  
  fTree = tfs->make<TTree>("CRTDataQuality","analysis tree");
  fTree->Branch("run"       ,&run       ,"run/I"   );
  fTree->Branch("subrun"    ,&subrun    ,"subrun/I");
  fTree->Branch("event"     ,&event     ,"event/I" );
  fTree->Branch("date"      ,&date      ,"date/I"  );

  fTree->Branch("nFlashes"         ,&nFlashes        ,"nFlashes/I"         );
  fTree->Branch("nMatchedFlashes"  ,&nMatchedFlashes ,"nMatchedFlashes/I"  );
  fTree->Branch("nTracks"          ,&nTracks         ,"nTracks/I"          );
  fTree->Branch("nMatchedTracks"   ,&nMatchedTracks  ,"nMatchedTracks/I"   );
  
  fTree->Branch("nCRThits"  ,nCRThits   ,"nCRThits[73]/I");
  fTree->Branch("febIndex"  ,febIndex   ,"febIndex[73]/I");
  fTree->Branch("AvgPe"     ,AvgPe      ,"AvgPe[73]/D"   );


  /*
  fTree->Branch("AvgCountX" ,AvgCountX  ,"AvgCountX[73]/D");
  fTree->Branch("AvgCountY" ,AvgCountY  ,"AvgCountY[73]/D");
  fTree->Branch("AvgCountZ" ,AvgCountZ  ,"AvgCountZ[73]/D");
  fTree->Branch("MaxCountX" ,MaxCountX  ,"MaxCountX[73]/D");
  fTree->Branch("MaxCountY" ,MaxCountY  ,"MaxCountY[73]/D");
  fTree->Branch("MaxCountZ" ,MaxCountZ  ,"MaxCountZ[73]/D");
  fTree->Branch("MaxPositX" ,MaxPositX  ,"MaxPositX[73]/D");
  fTree->Branch("MaxPositY" ,MaxPositY  ,"MaxPositY[73]/D");
  fTree->Branch("MaxPositZ" ,MaxPositZ  ,"MaxPositZ[73]/D");
  */
  fTree->Branch("reaoutTime",&reaoutTime,"reaoutTime/D"  );
  
  hHitTime         = tfs1->make<TH1D>("hHitTime"        ,"CRT Hit Time; time [ns]; ",2000, -10000000,10000000);
  hHitTimeAfterCut = tfs1->make<TH1D>("hHitTimeAfterCut","CRT Hit Time; time [ns]; ",2000, -10000000,10000000);
  
  for (size_t i = 0; i<73; i++)
    {
      std::string feb = std::to_string(febIndex[i]);
      std::string x = "hModule_X" + feb;
      std::string y = "hModule_Y" + feb;
      std::string z = "hModule_Z" + feb;
      hModule_X[i]  = tfs1->make<TH1D>(x.c_str() ,"CRT Hit X Position; X [cm]; ",2000, -1000, 1000);
      hModule_Y[i]  = tfs1->make<TH1D>(y.c_str() ,"CRT Hit Y Position; Y [cm]; ",2000, -1000, 1000); 
      hModule_Z[i]  = tfs1->make<TH1D>(z.c_str() ,"CRT Hit Z Position; Z [cm]; ",2000, -500 , 1500);

    }

}
 
void CRTDataQuality::endJob()
{  

}


DEFINE_ART_MODULE(CRTDataQuality)


