////////////////////////////////////////////////////////////////////////
// Class:       CheckTimingOverlay
// Module Type: analyzer
// File:        CheckTimingOverlay_module.cc
//
// Generated at Mon Jul  3 03:51:03 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardata/Utilities/AssociationUtil.h"

#include <artdaq-core/Data/Fragment.hh>

#include "art/Framework/Services/Optional/TFileService.h"

#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTzero.hh"
#include "ubobj/CRT/CRTTrack.hh"
#include "ubcrt/CRT/CRTAuxFunctions.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"

#include "TTree.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <typeinfo>


const int kMaxCRThits = 1000;
const int kMaxCRTtzs = 1000;
const int kMaxCRTtracks = 1000;
const int kMaxTPCtracks = 100;
const int kMaxPMTflash = 100;


 // namespace crt {
 //   class CheckTimingOverlay;
 // }

class CheckTimingOverlay : public art::EDAnalyzer {
public:
  explicit CheckTimingOverlay(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CheckTimingOverlay(CheckTimingOverlay const &) = delete;
  CheckTimingOverlay(CheckTimingOverlay &&) = delete;
  CheckTimingOverlay & operator = (CheckTimingOverlay const &) = delete;
  CheckTimingOverlay & operator = (CheckTimingOverlay &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  void ResetVars();

  art::ServiceHandle<art::TFileService> tfs;
  // Declare member data here.
  


  std::string  data_labelhit_;
  std::string  sim_labelhit_;
  std::string  data_label_DAQHeader_;
  bool fIsMC;
  int fHardDelay_;
  int fTimeZeroOffset;
  int verbose_;
  bool fRunOverData;
  bool fRunOverSim;

  TTree*       fTree;
  // run information
  int run;
  int subrun;
  int event;
  double evttime;

  // CRT hits data
  int    nCRThitsData;
  double data_hit_time_s[kMaxCRThits];
  double data_hit_time0[kMaxCRThits];
  double data_hit_time1[kMaxCRThits];
  double data_hit_charge[kMaxCRThits]; 
  double data_hit_posx[kMaxCRThits];
  double data_hit_posy[kMaxCRThits]; 
  double data_hit_posz[kMaxCRThits];   
  int    data_hit_isSim[kMaxCRThits];
  double data_hit_timeCheck[kMaxCRThits];
  double avgSizeData;

  // CRT hits data
  int    nCRThitsSim;
  double sim_GPS_time_s[kMaxCRThits];
  double sim_hit_time_s[kMaxCRThits];
  double sim_hit_time0[kMaxCRThits];
  double sim_hit_time1[kMaxCRThits];
  double sim_hit_charge[kMaxCRThits]; 
  double sim_hit_posx[kMaxCRThits];
  double sim_hit_posy[kMaxCRThits]; 
  double sim_hit_posz[kMaxCRThits];   
  int    sim_hit_isSim[kMaxCRThits];
  double avgSizeSim;

  
};


CheckTimingOverlay::CheckTimingOverlay(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
    data_labelhit_(p.get<std::string>("data_labelhit","merger")),
    sim_labelhit_(p.get<std::string>("sim_labelhit","crthitsim")),
    data_label_DAQHeader_(p.get<std::string>("data_label_DAQHeader_","daq")),
    fHardDelay_(p.get<int>("fHardDelay",40000)),
    fTimeZeroOffset(p.get<int>("fTimeZeroOffset",69000)),
    verbose_(p.get<int>("verbose")),
    fRunOverData(p.get<bool>("fRunOverData",true)),
    fRunOverSim(p.get<bool>("fRunOverSim",true))
    // More initializers here.    
{
}

void CheckTimingOverlay::analyze(art::Event const & evt)
{
  
  ResetVars();
  
  run    = evt.run();
  subrun = evt.subRun();
  event  = evt.event();
  
  /*
  // Event Time Stamp
  art::Timestamp evtTime = evt.time();
  //auto evt_time_sec = evtTime.timeHigh();
  //auto evt_time_nsec = evtTime.timeLow();
  
  */

  double evt_timeGPS_sec = 0.0;
  double evt_timeGPS_nsec = 0.0;
  double evt_timeNTP_sec = 0.0;
  double evt_timeNTP_nsec = 0.0;
  double timstp_diff = 0.0;
  // Get DAQ timestamps for the data part
  // get DAQ Header                                                                  

  art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;  
  evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
  
  //check to make sure the data we asked for is valid 
  if(!rawHandle_DAQHeader.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
	      << ", event " << evt.event() << " has zero"
	      << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;    
    return;
  }
    
  // Magic with DAQHeader 
  raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);
  art::Timestamp evtTimeGPS = my_DAQHeader.gps_time(); 
  evt_timeGPS_sec = evtTimeGPS.timeHigh();
  evt_timeGPS_nsec = (double)evtTimeGPS.timeLow();
  art::Timestamp evtTimeNTP = my_DAQHeader.ntp_time();
  evt_timeNTP_sec = evtTimeNTP.timeHigh();
  evt_timeNTP_nsec = (double)evtTimeNTP.timeLow();
  timstp_diff = std::abs(evt_timeGPS_nsec - evt_timeNTP_nsec);

  evttime = evt_timeGPS_sec;
 



  if(fRunOverData) {
    //get CRTHits: we need 2 of those: one for data and one for sim
    // Let's start with the data one:
    art::Handle< std::vector<crt::CRTHit> > rawHandle_hit_data;
    evt.getByLabel(data_labelhit_, rawHandle_hit_data); //
    
    //check to make sure the data we asked for is valid
    if(!rawHandle_hit_data.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
		<< ", event " << evt.event() << " has zero"
		<< " CRTHits " << " in module " << data_labelhit_ 
		<< evt_timeGPS_sec <<evt_timeGPS_nsec << evt_timeNTP_nsec<<evt_timeNTP_sec<<timstp_diff << std::endl;
      std::cout << std::endl;
      return;
    }

    std::vector<crt::CRTHit> const& CRTHitCollectionData(*rawHandle_hit_data);
    if(verbose_==1){ 
      std::cout<<"  CRTHitCollectionData.size()  "<<CRTHitCollectionData.size()<<std::endl; 
      //  getchar();   
    }    //end get CRTHits
    
    avgSizeData = 0;
    nCRThitsData = CRTHitCollectionData.size();


    if (nCRThitsData>kMaxCRThits) nCRThitsData=kMaxCRThits;
    for(int j = 0; j < nCRThitsData; j++) {
      
    //fill tree
      crt::CRTHit my_CRTHit = CRTHitCollectionData[j];

      data_hit_time_s[j]=(double)my_CRTHit.ts0_s;      
      data_hit_time0[j]=(double)my_CRTHit.ts0_ns - (double)evt_timeGPS_nsec + (double)fTimeZeroOffset;
      data_hit_time1[j]=(double)my_CRTHit.ts1_ns + (double)fHardDelay_; 
      data_hit_charge[j]= my_CRTHit.peshit;
      data_hit_posx[j]  = my_CRTHit.x_pos;
      data_hit_posy[j]  = my_CRTHit.y_pos;
      data_hit_posz[j]  = my_CRTHit.z_pos;

      std::vector<std::pair<int,float>> pes = my_CRTHit.pesmap.find(int(my_CRTHit.feb_id[0]))->second;
      if (pes.size() == 2) {
	data_hit_isSim[j] = 1 ;
	data_hit_timeCheck[j] = (double)my_CRTHit.ts1_ns;
      }
      else if (pes.size() == 32) {data_hit_isSim[j] = 0 ;
      	data_hit_timeCheck[j] = (double)my_CRTHit.ts0_ns  - (double)evt_timeGPS_nsec + (double)fTimeZeroOffset;
      }
      else data_hit_isSim[j] = -4 ;
      avgSizeData+= (double)pes.size();
    }// loop over hits

    avgSizeData/=(double)nCRThitsData;
  }
  
  if(fRunOverSim) {
    // Then with the Sim
    art::Handle< std::vector<crt::CRTHit> > rawHandle_hit_sim;
    evt.getByLabel(sim_labelhit_, rawHandle_hit_sim); //
    
    //check to make sure the sim we asked for is valid
    if(!rawHandle_hit_sim.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
		<< ", event " << evt.event() << " has zero"
		<< " CRTHits " << " in module " << sim_labelhit_ << std::endl;
      std::cout << std::endl;
      return;
    }



    std::vector<crt::CRTHit> const& CRTHitCollectionSim(*rawHandle_hit_sim);
    if(verbose_==1){ 
      std::cout<<"  CRTHitCollectionSim.size()  "<<CRTHitCollectionSim.size()<<std::endl; 
      //  getchar();   
    }    //end get CRTHits
    
    
    nCRThitsSim = CRTHitCollectionSim.size();
    avgSizeSim = 0;
    if (nCRThitsSim>kMaxCRThits) nCRThitsSim=kMaxCRThits;
    for(int j = 0; j < nCRThitsSim; j++) {

      //fill tree
      crt::CRTHit my_CRTHit = CRTHitCollectionSim[j];      
      std::vector<std::pair<int,float>> pes = my_CRTHit.pesmap.find(int(my_CRTHit.feb_id[0]))->second;
      if (pes.size() == 2) {
	sim_hit_isSim[j] = 1 ;
      }
      else if (pes.size() == 32) {
	sim_hit_isSim[j] = 0 ;
      }
      else sim_hit_isSim[j] = -4 ;


      sim_hit_time_s[j]=(double)my_CRTHit.ts0_s;
      sim_hit_time0[j]=(double)my_CRTHit.ts0_ns;// - (double)evt_timeGPS_nsec + (double)fTimeZeroOffset;
      sim_hit_time1[j]=(double)my_CRTHit.ts1_ns;// + (double)fHardDelay_; 
    
      sim_hit_charge[j]= my_CRTHit.peshit;
      sim_hit_posx[j]  = my_CRTHit.x_pos;
      sim_hit_posy[j]  = my_CRTHit.y_pos;
      sim_hit_posz[j]  = my_CRTHit.z_pos;

      avgSizeSim+= (double)pes.size();
    }// loop over hits

    avgSizeSim/=nCRThitsSim;

  }

  if(verbose_==1)std::cout<<"Avg Size --------------------- "<<avgSizeSim<<" "<<avgSizeData<<"\n";
  fTree->Fill();
  
}

void CheckTimingOverlay::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("checkOverlayTime","analysis tree");
  fTree->Branch("run"       ,&run,"run/I");
  fTree->Branch("subrun"    ,&subrun,"subrun/I");
  fTree->Branch("event"     ,&event,"event/I");
  fTree->Branch("evttime"   ,&evttime,"evttime/D");

  fTree->Branch("nCRThitsData"   ,&nCRThitsData  ,"nCRThitsData/I");
  fTree->Branch("data_hit_time_s",data_hit_time_s,"data_hit_time_s[nCRThitsData]/D");
  fTree->Branch("data_hit_time0" ,data_hit_time0 ,"data_hit_time0[nCRThitsData]/D");
  fTree->Branch("data_hit_time1" ,data_hit_time1 ,"data_hit_time1[nCRThitsData]/D");
  fTree->Branch("data_hit_charge",data_hit_charge,"data_hit_charge[nCRThitsData]/D");
  fTree->Branch("data_hit_posx"  ,data_hit_posx  ,"data_hit_posx[nCRThitsData]/D");
  fTree->Branch("data_hit_posy"  ,data_hit_posy  ,"data_hit_posy[nCRThitsData]/D");
  fTree->Branch("data_hit_posz"  ,data_hit_posz  ,"data_hit_posz[nCRThitsData]/D");
  fTree->Branch("data_hit_isSim" ,data_hit_isSim ,"data_hit_isSim[nCRThitsData]/I");
  fTree->Branch("data_hit_timeCheck"  ,data_hit_timeCheck  ,"data_hit_timeCheck[nCRThitsData]/D");
  fTree->Branch("avgSizeData"    ,&avgSizeData  ,"avgSizeData/I");

  fTree->Branch("nCRThitsSim"   ,&nCRThitsSim  ,"nCRThitsSim/I");
  fTree->Branch("sim_hit_time_s",sim_hit_time_s,"sim_hit_time_s[nCRThitsSim]/D");
  fTree->Branch("sim_hit_time0" ,sim_hit_time0 ,"sim_hit_time0[nCRThitsSim]/D");
  fTree->Branch("sim_hit_time1" ,sim_hit_time1 ,"sim_hit_time1[nCRThitsSim]/D");
  fTree->Branch("sim_hit_charge",sim_hit_charge,"sim_hit_charge[nCRThitsSim]/D");
  fTree->Branch("sim_hit_posx"  ,sim_hit_posx  ,"sim_hit_posx[nCRThitsSim]/D");
  fTree->Branch("sim_hit_posy"  ,sim_hit_posy  ,"sim_hit_posy[nCRThitsSim]/D");
  fTree->Branch("sim_hit_posz"  ,sim_hit_posz  ,"sim_hit_posz[nCRThitsSim]/D");
  fTree->Branch("sim_hit_isSim" ,sim_hit_isSim ,"sim_hit_isSim[nCRThitsData]/I");
  fTree->Branch("avgSizeSim"    ,&avgSizeSim   ,"avgSizeSim/I");
}

void CheckTimingOverlay::endJob()
{
  // Implementation of optional member function here.
  
  
  //fTree->Write();
  
}


void CheckTimingOverlay::ResetVars()
{
  run = -99999;
  subrun = -99999;
  event = -99999;
  evttime = -99999;
  nCRThitsData = 0;
  avgSizeSim   = 0;
  nCRThitsSim  = 0;
  avgSizeSim   = 0;
  for (int i = 0; i<kMaxCRThits; ++i){
    data_hit_timeCheck[i] = -99999.;
    data_hit_time_s[i] = -99999.;
    data_hit_time0[i] = -99999.;
    data_hit_time1[i] = -99999.;
    data_hit_charge[i] = -99999.; 
    data_hit_posx[i]   = -99999.;
    data_hit_posy[i]   = -99999.; 
    data_hit_posz[i]   = -99999;   
    data_hit_isSim[i]  = -1;

    sim_hit_time_s[i] = -99999.;
    sim_hit_time0[i] = -99999.;
    sim_hit_time1[i] = -99999.;
    sim_hit_charge[i] = -99999.; 
    sim_hit_posx[i]   = -99999.;
    sim_hit_posy[i]   = -99999.; 
    sim_hit_posz[i]   = -99999;
    sim_hit_isSim[i]  = -1;   
  }
}


DEFINE_ART_MODULE(CheckTimingOverlay)


