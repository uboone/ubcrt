////////////////////////////////////////////////////////////////////////////
/// Class:       CRTDataHitCorr
/// Module Type: producer
/// File:        CRTDataHitCorr_module.cc
///
/// Author:         Michelle Stancari
/// E-mail address: mstancar@fnal.gov
///
/////////////////////////////////////////////////////////////////////////////

#include "ubobj/CRT/CRTHit.hh"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>
#include <vector>

// LArSoft
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVector3.h"
#include "TGeoManager.h"

namespace crt{

  
  class CRTDataHitCorr : public art::EDProducer {
  public:

    explicit CRTDataHitCorr(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTDataHitCorr(CRTDataHitCorr const &) = delete;
    CRTDataHitCorr(CRTDataHitCorr &&) = delete;
    CRTDataHitCorr & operator = (CRTDataHitCorr const &) = delete; 
    CRTDataHitCorr & operator = (CRTDataHitCorr &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);


    crt::CRTHit FillCrtHit(std::vector<uint8_t> tfeb_id, std::map<uint8_t,std::vector<std::pair<int,float>>> tpesmap, 
			   float peshit, double time1, double time2, double time3, double time4, double time5, int plane,
			   double x, double ex, double y, double ey, double z, double ez); 

  private:

    // Params got from fcl file.......
    art::InputTag fCrtHitsIn_Label1;      ///< name of crt producer
    art::InputTag fCrtHitsIn_Label2;      ///< name of crt producer
    int fNumberCollections;
			   bool fPlane3Only_Coll2;

    //for later
    // bool fChoose;
    // art::InputTag fPMTflashLabel;         ///< name of flash producer
    // art::InputTag fTPCtrackLabel;         ///< name of flash producer

			   //Option to apply higher threshold
    float fHitThreshold;
    float fStripThreshold;
    float fSiPMThreshold;

    //alignment params
			   bool fCorrectAlignment;
			   float fAlignBotX;
			   float fAlignBotY;
			   float fAlignBotZ;
			   float fAlignAnodeX;
			   float fAlignAnodeY;
			   float fAlignAnodeZ;
			   float fAlignCathX;
			   float fAlignCathY;
			   float fAlignCathZ;
			   float fAlignTopX;
			   float fAlignTopY;
			   float fAlignTopZ;
			   //
    bool          fVerbose;             ///< print info
   
  }; // class CRTDataHitCorr
    
  CRTDataHitCorr::CRTDataHitCorr(fhicl::ParameterSet const & p)
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
    // Call appropriate produces<>() functions here.
    produces< std::vector<crt::CRTHit> >();
    

    reconfigure(p);

  } // CRTDataHitCorr()

  void CRTDataHitCorr::reconfigure(fhicl::ParameterSet const & p)
  {
    fCrtHitsIn_Label1       = (p.get<art::InputTag> ("CrtHitsIn_Label1","merger")); 
    fCrtHitsIn_Label2       = (p.get<art::InputTag> ("CrtHitsIn_Label2","remerge")); 
    fNumberCollections      = (p.get<int> ("NumberCollections",1));
    fPlane3Only_Coll2 = (p.get<bool> ("Plane3Only_Coll2",true));
    //
    fHitThreshold           = (p.get<float>("HitThreshold",0.0));
    fStripThreshold           = (p.get<float>("StripThreshold",0.0));
    fSiPMThreshold           = (p.get<float>("SiPMThreshold",0.0));
    //alignment params
    fCorrectAlignment       = (p.get<bool> ("CorrectAlignment",true));
			       fAlignBotX = (p.get<float>("AlignBotX",0.0));
			       fAlignBotY = (p.get<float>("AlignBotY",0.0));
			       fAlignBotZ = (p.get<float>("AlignBotZ",0.0));
			       fAlignAnodeX = (p.get<float>("AlignAnodeX",0.0));
			       fAlignAnodeY = (p.get<float>("AlignAnodeY",0.0));
			       fAlignAnodeZ = (p.get<float>("AlignAnodeZ",0.0));
			       fAlignCathX = (p.get<float>("AlignCathX",0.0));
			       fAlignCathY = (p.get<float>("AlignCathY",0.0));
			       fAlignCathZ = (p.get<float>("AlignCathZ",0.0));
			       fAlignTopX = (p.get<float>("AlignTopX",0.0));
			       fAlignTopY = (p.get<float>("AlignTopY",0.0));
			       fAlignTopZ = (p.get<float>("AlignTopZ",0.0));
    // fTimeStart           = (p.get<float>("TimeStart",-10000.));
    // fTimeEnd           = (p.get<float>("TimeEnd",10000.));
    fVerbose              = (p.get<bool> ("Verbose",false));

  }

  void CRTDataHitCorr::beginJob()
    {
    if(fVerbose){std::cout<<"----------------- CRT Hit Reco Module -------------------"<<std::endl;}
    
  } // beginJob()
    
  void CRTDataHitCorr::produce(art::Event & event)
  {

    int nHits = 0;

    if(fVerbose){
      std::cout<<"============================================"<<std::endl
               <<"Run = "<<event.run()<<", SubRun = "<<event.subRun()<<", Event = "<<event.id().event()<<std::endl
               <<"============================================"<<std::endl;
    }

    // Place to store corrected CRThits as they are created
    std::unique_ptr<std::vector<crt::CRTHit>> CRTHitOutCol( new std::vector<crt::CRTHit>);


    std::vector<crt::CRTHit> crtHitInList;
    // Retrieve first list of CRT hits
    art::Handle< std::vector<crt::CRTHit>> crtHitsInHandle;
    event.getByLabel(fCrtHitsIn_Label1, crtHitsInHandle);
    //check to make sure the data we asked for is valid
    if(!crtHitsInHandle.isValid()){
      std::cout << "Run " << event.run() << ", subrun " << event.subRun()
		<< ", event " << event.event() << " has zero"
		<< " CRTHits " << " in module " << fCrtHitsIn_Label1 << std::endl;
      std::cout << std::endl;
      //add protection here
      event.put(std::move(CRTHitOutCol));
      return;
    }
    std::vector<crt::CRTHit> const& crtHitInList1(*crtHitsInHandle);
    crtHitInList.insert(crtHitInList.end(), crtHitInList1.begin(), crtHitInList1.end());
    if(fVerbose) std::cout<<"Number of CRT hits read in= "<<crtHitInList.size()<< 
		   " after first collection" << std::endl;
    //
    if (fNumberCollections>1) {
    // Retrieve second list of CRT hits
    event.getByLabel(fCrtHitsIn_Label2, crtHitsInHandle);
    //check to make sure the data we asked for is valid
    if(!crtHitsInHandle.isValid()){
      std::cout << "Run " << event.run() << ", subrun " << event.subRun()
		<< ", event " << event.event() << " has zero"
		<< " CRTHits " << " in module " << fCrtHitsIn_Label2 << std::endl;
      std::cout << " Skipping this CRT hit collection " << std::endl;
    }
    std::vector<crt::CRTHit> const& crtHitInList2(*crtHitsInHandle);
    if (fPlane3Only_Coll2) {
      for (size_t i = 0; i < crtHitInList2.size(); i++){
	if (crtHitInList2[i].plane==3)  crtHitInList.insert(crtHitInList.end(), crtHitInList2[i]);
      }
    }
    else     crtHitInList.insert(crtHitInList.end(), crtHitInList2.begin(), crtHitInList2.end());
    if(fVerbose) std::cout<<"Number of CRT hits read in= "<<crtHitInList.size()<< " after second collection" << std::endl;
    }

    for (size_t i = 0; i < crtHitInList.size(); i++){

      crt::CRTHit thisCrtHit = crtHitInList[i];

      std::vector<uint8_t> tfeb_id = thisCrtHit.feb_id; 
      double time1 = thisCrtHit.ts0_s;
      double time2 = thisCrtHit.ts0_s_corr;
      double time3 = thisCrtHit.ts0_ns;
      double time4 = thisCrtHit.ts0_ns_corr;
      double time5 = thisCrtHit.ts1_ns;
      
      int plane = thisCrtHit.plane;
      double x = thisCrtHit.x_pos;
      double ex = thisCrtHit.x_err;
      double y = thisCrtHit.y_pos;
      double ey = thisCrtHit.y_err;
      double z = thisCrtHit.z_pos;
      double ez= thisCrtHit.z_err;
      
      std::map<uint8_t, std::vector<std::pair<int,float>>> tpesmap=thisCrtHit.pesmap;
      float pestot = thisCrtHit.peshit;      

      int iKeepMe = 1;

      // only change/remove data hits
      std::vector<std::pair<int,float>> test = tpesmap.find(tfeb_id[0])->second; 
      if (test.size()==32)  { // this is data	    
	
	// apply hit threshold
	if (pestot<fHitThreshold) iKeepMe=0;

	// apply strip and sipm threshold
	std::vector<std::pair<int,float>> pes1 = tpesmap.find(tfeb_id[0])->second; 
	std::vector<std::pair<int,float>> pes2 = tpesmap.find(tfeb_id[1])->second; 
	std::pair<int,float> ind_pes1,ind_pes2,ind2_pes1,ind2_pes2;
	float pmax1=0.0; float pmax2=0.0;
	// use the max recorded sipm signal on this feb for this hit.  Not perfect.
	for (int ii=0;ii<32;ii+=2){ 
	  std::pair<int,float> ind_pesa=pes1[ii];  
	  std::pair<int,float> ind_pesb=pes1[ii+1];
	  if (ind_pesa.second+ind_pesb.second>pmax1) {
	    ind_pes1=ind_pesa; ind_pes2=ind_pesb;
	    pmax1=ind_pesa.second+ind_pesb.second;	    
	  }
	  ind_pesa=pes2[ii];  
	  ind_pesb=pes2[ii+1];
	  if ((ind_pesa.second+ind_pesb.second)>pmax2) {
	    ind2_pes1=ind_pesa; ind2_pes2=ind_pesb;
	    pmax2=ind_pesa.second+ind_pesb.second;	    
	  }
	}

	float tot1 = ind_pes1.second+ind_pes2.second;
	float tot2 = ind2_pes1.second+ind2_pes2.second;
	
	// issue here reconstructing exactly the report peshit for the hit.  Ignore for now
	/*
	float pdiff = (tot1+tot2-pestot);  
	if (fabs(pdiff)>1) { std::cout << "double hit in this feb " << pestot<< " "  << tot1 << " " << tot2 << std::endl;
	for (int ii=0;ii<32;ii+=2)
	  std::cout << ii << " " << pes1[ii].second << " " << pes1[ii+1].second << std::endl;
	for (int ii=0;ii<32;ii+=2)
	  std::cout << ii << " " << pes2[ii].second << " " << pes2[ii+1].second << std::endl;
	}
	*/
	if ( tot2<fStripThreshold || tot1<fStripThreshold ) iKeepMe=0;
	if (ind2_pes1.second < fSiPMThreshold || ind2_pes2.second<fSiPMThreshold) iKeepMe=0;
	if (ind_pes1.second < fSiPMThreshold || ind_pes2.second<fSiPMThreshold ) iKeepMe=0;

      if (iKeepMe) {
	int feb1=thisCrtHit.feb_id[0];
	int feb2=thisCrtHit.feb_id[1];
	// apply alignment offsets
	if (fCorrectAlignment) {
	  if (plane==3) {x+=12.1;  y-=40.0;  z-=31.1;}
	  else if (plane==2) {
	    if  (feb1==15 ||  feb1==20 ||  feb1==46 ||  feb1==48 ||  feb1==50  ) y-=5.0;

	    if  (feb2==15 ||  feb2==20 ||  feb2==46 ||  feb2==48 ||  feb2==50  ) y-=5.0;
	    if  (feb1==16 ||  feb1==21 ||  feb1==47 ||  feb1==49 ||  feb1==51  ) y-=9.0;
	    if  (feb2==16 ||  feb2==21 ||  feb2==47 ||  feb2==49 ||  feb2==51  ) y-=9.0;
	    if  ((feb1>52 && feb1<56) || (feb2>52 && feb2<56)) y-=6.2;
	    if ((feb1>31 && feb1<39) || (feb2>31 && feb2<39) ) z+=5.2;
	    if ((feb1>38 && feb1<46) || (feb2>38 && feb2<46) ) z-=5.5;
	  }
	  else if (plane==1) {	  y+=20.7; z+=5.7;}
	  else if (plane==0) {
	    x-=4.4; 	  z+=32.8;
	    if (feb1==11 || feb2==11) z-=10.4;
	    if (feb1==12 || feb2==12) x-=4.9;
	  }
	}
       } 
      }	// if this is a data hit	
      if (iKeepMe) {
	// Create a corrected CRT hit
	crt::CRTHit crtHit = FillCrtHit(tfeb_id, tpesmap, pestot, time1,  time2,  time3,  time4,  time5, 
					plane, x, ex,y,ey,z,ez );
	
	CRTHitOutCol->push_back(crtHit);
	nHits++;
	// if (fVerbose) std::cout << "hit created: time " << time5 << " x " <<  x << 
	// 		" y " << y << " z " <<  z << std::endl;
      }  // keep this hit	    
    } // loop over hits
    
    event.put(std::move(CRTHitOutCol));

    if(fVerbose) std::cout<<"Number of CRT hits produced = "<<nHits<<std::endl;
      
    
  } // produce()
    
    void CRTDataHitCorr::endJob()
    {
      
    }
    
    crt::CRTHit CRTDataHitCorr::FillCrtHit(std::vector<uint8_t> tfeb_id, std::map<uint8_t, std::vector<std::pair<int,float>>> tpesmap, float peshit,double time1, double time2, double time3, double time4, double time5, 
int plane, double x, double ex, double y, double ey, double z, double ez){
	
	crt::CRTHit crtHit;
	crtHit.feb_id = tfeb_id;
	crtHit.pesmap = tpesmap;
	crtHit.peshit = peshit;
	crtHit.ts0_s = time1; 
	crtHit.ts0_s_corr = time2;
	crtHit.ts0_ns = time3;
	crtHit.ts0_ns_corr = time4;
	crtHit.ts1_ns = time5 ;
	crtHit.plane = plane;
	crtHit.x_pos = x;
	crtHit.x_err = ex;
	crtHit.y_pos = y; 
	crtHit.y_err = ey;
	crtHit.z_pos = z;
	crtHit.z_err = ez;
	return crtHit;
      }
      

      DEFINE_ART_MODULE(CRTDataHitCorr)

    }// namespace crt

namespace {


}
