//////////////////////////////////////////////////////////////////////
// Class:       T0recoCRTHitAna2
// Module Type: analyzer
// File:        T0recoCRTHitAna2_module.cc
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardata/Utilities/AssociationUtil.h"
#include <artdaq-core/Data/Fragment.hh>

#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/Assns.h"
#include "canvas/Persistency/Provenance/ProductID.h"
#include "art/Persistency/Common/PtrMaker.h"

#include "ubobj/CRT/CRTHit.hh"
#include "ubobj/CRT/CRTTzero.hh"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"
#include "larevt/SpaceCharge/SpaceCharge.h"
#include "larevt/SpaceChargeServices/SpaceChargeService.h"

#include "TTree.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TMath.h"
#include "Math/SMatrix.h"
#include "Math/Functions.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <typeinfo>


// namespace crt {
//   class T0recoCRTHitAna2;
// }

class T0recoCRTHitAna2 : public art::EDAnalyzer {
public:
  explicit T0recoCRTHitAna2(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  T0recoCRTHitAna2(T0recoCRTHitAna2 const &) = delete;
  T0recoCRTHitAna2(T0recoCRTHitAna2 &&) = delete;
  T0recoCRTHitAna2 & operator = (T0recoCRTHitAna2 const &) = delete;
  T0recoCRTHitAna2 & operator = (T0recoCRTHitAna2 &&) = delete;

 // Required functions.
  void analyze(art::Event const & e);
  
  // Selected optional functions.
  void beginJob();
  void endJob();

private:

  art::ServiceHandle<art::TFileService> tfs;
  
  uint32_t fEvtNum; //Number of current event                       
  uint32_t frunNum;                //Run Number taken from event  
  uint32_t fsubRunNum;             //Subrun Number taken from event         
  std::string  data_label_TPCtrack_;
  std::string  data_label_CRTtzero_;
  std::string  data_label_CRThit_;
  std::string  data_label_acptT0;
  std::string  data_label_flash_;
  std::string  data_label_DAQHeader_;
  int fHardDelay;
  int fTimeZeroOffset;
  int fTimeSelect;
  int fMatchCut;
  int fMatchCutTop;
  float fDriftVel;
  bool fverbose;
  //alignment params
  float fAlignBotX;
  float fAlignBotY;
  float fAlignBotZ;
  float fAlignAnodeX;
  float fAlignAnodeY;
  float fAlignAnodeZ;
  float fAlignCathX;
  float fAlignCathY;
  float fAlignCathZ;
  float fAlignTopX;
  float fAlignTopY;
  float fAlignTopZ;

  //histograms

  TH1F* hTrackLength;
  TH1F* hOpeningAngle;

  // TH1F* hDistTwo;
  TH1F* hDistOne;
  TH1F* hDistAn;
  TH1F* hDistCa;
  TH1F* hDistNone;
  TH1F* hTimeBest;

  TH1F *dca0;
  TH1F *dca1;
  TH1F *dca2;
  TH1F *dca3;
  TH1F *dla0;
  TH1F *dla1;
  TH1F *dla2;
  TH1F *dla3;
  TH1F *dcn0;
  TH1F *dcn1;
  TH1F *dcn2;
  TH1F *dcn3;
  TH1F *dcab;
  TH1F *botx;
  TH1F *botz;
  TH1F *botx1;
  TH1F *botz1;
  TH1F *botx2;
  TH1F *botz2;
  TH1F *any;
  TH1F *anz;
  TH1F *caty;
  TH1F *catz;
  TH1F *caty1;
  TH1F *catz2;
  TH1F *caty3;
  TH1F *catz4;
  TH1F *caty5;
  TProfile *catyp;
  TProfile *catzp;
  TH1F *topx11;
  TH1F *topx22;
  TH1F *topx33;
  TH1F *topx44;
  TH1F *topx;
  TH1F *topz;
  TH1F *topxc;
  TH1F *topzc;
  TH2F *topx2;
  TH2F *topz2;
  TProfile *topxp;
  TProfile *topzp;
  TH1F *pe;
  TH1F *pe2;
  TProfile *peave;
  TH2F *pefull;
  TH1F *inang;
  TH1F *topz109;
  TH1F *topz105;
  TH1F *topz106;
  TH1F *topz107;
  TH1F *topz108;
  TH1F *topz112;
  TH1F *topz111;
  TH1F *topz128;
  TH1F *topz126;
  TH1F *topz125;
  TH1F *topz195;
  TH1F *topz123;
  TH1F *topz124;
  TH1F *topx113;
  TH1F *topx114;
  TH1F *topx115;
  TH1F *topx116;
  TH1F *topx117;
  TH1F *topx118;
  TH1F *topx119;
  TH1F *topx120;
  TH1F *topx121;
  TH1F *topx129;
  TH1F *topx127;
  //
  TH2F *top2z109;
  TH2F *top2z105;
  TH2F *top2z106;
  TH2F *top2z107;
  TH2F *top2z108;
  TH2F *top2z112;
  TH2F *top2z111;
  TH2F *top2z128;
  TH2F *top2z126;
  TH2F *top2z125;
  TH2F *top2z195;
  TH2F *top2z123;
  TH2F *top2z124;
  TH2F *top2x113;
  TH2F *top2x114;
  TH2F *top2x115;
  TH2F *top2x116;
  TH2F *top2x117;
  TH2F *top2x118;
  TH2F *top2x119;
  TH2F *top2x120;
  TH2F *top2x121;
  TH2F *top2x129;
  TH2F *top2x127;

  TH2F *hTop;
  TH2F *hPipe;
  TH2F *hFT;
  TH2F *hBot;

  /*
  TH1F* hTrackLengthACPT;
  TH1F* hOpeningAngleACPT;
  TH1F* hThetaAll;
  TH1F* hThetaACPT;
  TH1F* hThetaGood;
  TH1F* hThetaGoodA;
  TH1F* hThetaGoodY;
  TH1F* hThetaGoodN;
  TH1F* hThetaAnodeY;
  TH1F* hThetaAnodeN;
  TH1F* hThetaCathY;
  TH1F* hThetaCathN;
  TH1F* hPhiAll;
  TH1F* hPhiACPT;
  TH1F* hPhiGood;
  TH1F* hPhiGoodA;
  TH1F* hPhiGoodY;
  TH1F* hPhiGoodN;
  TH1F* hPhiAnodeY;
  TH1F* hPhiAnodeN;
  TH1F* hPhiCathY;
  TH1F* hPhiCathN;
  TH2F* hTvsPACPT;
  TH2F* hTvsPGood;
  TH2F* hTvsPGoodA;
  TH2F* hTvsPGoodY;
  TH2F* hTvsPGoodN;
  TH2F* hTvsPAnodeY;
  TH2F* hTvsPAnodeN;
  TH2F* hTvsPCathY;
  TH2F* hTvsPCathN;
  TH1F* hDistTrue[4];
  TH1F* hDistWrong[4];
  TH1F* hDistTrueAll;
  TH1F* hDistWrongAll;
  TH1F* hDistNone;
  TH1F* hDistTrueA;
  TH1F* hDistWrongA;
  TH1F* hDistNoneA;
  TH1F* hPlaneClosest;
  TH1F* hPlaneCorr;
  TH1F* hPlaneWrong;
  TH1F* hDistMistake;
  TH1F* hTimeDiffCorr; 
  TH1F* hTimeDiffWrong;
  TH1F* hTimeDiffNone;
  */

  
};


T0recoCRTHitAna2::T0recoCRTHitAna2(fhicl::ParameterSet const & p)
  : 
  EDAnalyzer(p),
    data_label_TPCtrack_(p.get<std::string>("data_label_TPCtrack")),
    data_label_CRTtzero_(p.get<std::string>("data_label_CRTtzero")),
    data_label_CRThit_(p.get<std::string>("data_label_CRThit")),
    data_label_acptT0(p.get<std::string>("data_label_acptT0","pandoraCosmicT0Reco")),
    data_label_flash_(p.get<std::string>("data_label_flash")),
    data_label_DAQHeader_(p.get<std::string>("data_label_DAQHeader")),
    fHardDelay(p.get<int>("HardDelay",40000)),
    fTimeZeroOffset(p.get<int>("TimeZeroOffset",69000)),
    fTimeSelect(p.get<int>("TimeSelect",0)),
    fMatchCut(p.get<int>("MatchCut",25)),
    fMatchCutTop(p.get<int>("MatchCutTop",40)),
    fDriftVel(p.get<float>("DriftVel",0.111436)),   // cm/us
    fverbose(p.get<bool>("verbose",false)),
    fAlignBotX(p.get<float>("AlignBotX",0.0)),
    fAlignBotY(p.get<float>("AlignBotY",0.0)),
    fAlignBotZ(p.get<float>("AlignBotZ",0.0)),
    fAlignAnodeX(p.get<float>("AlignAnodeX",0.0)),
    fAlignAnodeY(p.get<float>("AlignAnodeY",0.0)),
    fAlignAnodeZ(p.get<float>("AlignAnodeZ",0.0)),
    fAlignCathX(p.get<float>("AlignCathX",0.0)),
    fAlignCathY(p.get<float>("AlignCathY",0.0)),
    fAlignCathZ(p.get<float>("AlignCathZ",0.0)),
    fAlignTopX(p.get<float>("AlignTopX",0.0)),
    fAlignTopY(p.get<float>("AlignTopY",0.0)),
    fAlignTopZ(p.get<float>("AlignTopZ",0.0))
{}



void T0recoCRTHitAna2::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  
  frunNum    = evt.run();
  fsubRunNum = evt.subRun();
  fEvtNum = evt.event();
  
   
  bool iT0acpt=false;

  // get TPC Track List 
  art::Handle< std::vector<recob::Track>  > trackListHandle;
  std::vector<art::Ptr<recob::Track> >  tracklist;

  if (evt.getByLabel(data_label_TPCtrack_,trackListHandle))
      art::fill_ptr_vector(tracklist, trackListHandle);

  // get any t0 information for these tracks from ACPT module
  art::Handle< std::vector<anab::T0> > rawHandle_Tzero;
  evt.getByLabel(data_label_acptT0, rawHandle_Tzero);
  if(rawHandle_Tzero.isValid()) { 
    iT0acpt=true;
    if (fverbose) std::cout << iT0acpt << std::endl;
    art::FindMany<anab::T0> trk_t0_assn_v(trackListHandle, evt, data_label_acptT0 );
    //  art::FindMany<recob::OpFlash> trk_flash_assn_v(trackListHandle, evt, "t0reco" );
  }
  
  double evt_timeGPS_nsec=0.0;   double evt_timeGPS_sec=0.0;
  if (evt.isRealData() ) {  // this is data

    //check to make sure the data we asked for is valid 
    //get DAQ Header                                                                  
    art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;  
    evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
    
    if(!rawHandle_DAQHeader.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
		<< ", event " << evt.event() << " has zero"
		<< " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;    
      return;
    }
    
    raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);
    art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();  
    evt_timeGPS_sec = evtTimeGPS.timeHigh();
    evt_timeGPS_nsec = (double)evtTimeGPS.timeLow();
    // art::Timestamp evtTimeNTP = my_DAQHeader.ntp_time();
    // double evt_timeNTP_sec = evtTimeNTP.timeHigh();
    // double evt_timeNTP_nsec = (double)evtTimeNTP.timeLow();
    // double timstp_diff = std::abs(evt_timeGPS_nsec - evt_timeNTP_nsec);
  }// end if data
  if(fverbose){
    std::cout<< "Run:  "<<frunNum << "   subRun: " <<fsubRunNum<<std::endl;
    std::cout<<"event: "<<fEvtNum <<std::endl;
    std::cout.precision(19);
    std::cout<<"  GPS time second:  "<<evt_timeGPS_sec<<std::endl;
    std::cout<<"  GPS time nano_second:  "<<evt_timeGPS_nsec<<std::endl;
    // std::cout<<"  NTP time second:  "<<evt_timeNTP_sec<<std::endl;    
    // std::cout<<"  NTP time nano_second:  "<<evt_timeNTP_nsec<<std::endl;
    // std::cout<<"  event time second:  "<<evt_time_sec<<std::endl;
    // std::cout<<"  event time nano_second:  "<<evt_time_nsec<<std::endl;
    // std::cout<<"  difference between GPS and NTP:  "<<evt_timeGPS_nsec - evt_timeNTP_nsec<<" ns"<<std::endl;
    // std::cout<<"  ABS difference between GPS and NTP:  "<<timstp_diff<<" ns"<<std::endl;
    // if( (evt_time_sec==evt_timeGPS_sec) && (evt_time_nsec==evt_timeGPS_nsec))  std::cout<<" Event time type is: GPS  "<<std::endl;
    // if( (evt_time_sec==evt_timeNTP_sec) && (evt_time_nsec==evt_timeNTP_nsec))  std::cout<<" Event time type is: NTP  "<<std::endl;
  }// end if verbose  
  

// Set up space charge map
  //Spacecharge services provider 
  auto const* sce = lar::providerFrom<spacecharge::SpaceChargeService>();
   

  // fetch tzeros 
  art::Handle< std::vector<crt::CRTTzero> > rawHandletzero;
  evt.getByLabel(data_label_CRTtzero_, rawHandletzero);  //check to make sure the data we asked for is valid                                           
  if(!rawHandletzero.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " CRTTzeros " << " in module " << data_label_CRTtzero_ << std::endl;
    std::cout << std::endl;
    return;
  }
  std::vector<art::Ptr<crt::CRTTzero> > tzerolist;
  if (evt.getByLabel(data_label_CRTtzero_,rawHandletzero))
    art::fill_ptr_vector(tzerolist, rawHandletzero);
  art::FindManyP<crt::CRTHit> fmht(rawHandletzero, evt, data_label_CRTtzero_);
  

  // art::PtrMaker<recob::Track> trackPtrMaker(evt, trackListHandle.id());
  // //art::PtrMaker<recob::OpFlash> flashPtrMaker(evt, rawHandle_OpFlash.id());
  // art::PtrMaker<crt::CRTTzero> crttzPtrMaker(evt, rawHandletzero.id());
  // //  art::PtrMaker<anab::T0> t0PtrMaker(evt, *this);  
  // art::PtrMaker<anab::T0> t0PtrMaker(evt);  

  //get Optical Flash
  art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlash;
  evt.getByLabel(data_label_flash_, rawHandle_OpFlash);  
  std::vector<recob::OpFlash> const& OpFlashCollection(*rawHandle_OpFlash);
  if(fverbose){ 
    std::cout<<"  OpFlashCollection.size()  "<<OpFlashCollection.size()<<std::endl; 
  }  //get Optical Flash
  



  // look for match between CRT and flashes   
  for(std::vector<int>::size_type i = 0; i != OpFlashCollection.size(); i++) {//B
      
    recob::OpFlash my_OpFlash = OpFlashCollection[i];
      
    auto Yflash = my_OpFlash.YCenter();
    auto Zflash = my_OpFlash.ZCenter();
    auto PEflash = my_OpFlash.TotalPE();
    auto Timeflash = my_OpFlash.Time(); //in us from trigger time
    auto Timeflash_ns = (Timeflash * 1000);
    auto Timeflash_ns_GPS = evt_timeGPS_nsec + (Timeflash * 1000);      
    int fbeam = my_OpFlash.OnBeamTime();
    uint32_t Flash_sec = evt_timeGPS_sec;
      
    //    hFlashTimeDis->Fill(Timeflash);
    
    if (tzerolist.size()<=0) {
      std::cout << "no tzeros so no crt hits " << std::endl;
      return;
    }

    //loop over CRT tzeros
    float min_deltat = 3000.0; int best_time_match = -1;
    if (tzerolist.size()>0) {   
      for(size_t tzIter = 0; tzIter < tzerolist.size(); ++tzIter){   
	
	// if (fTimeSelect==0) // for EXT BNB data
	//     xshift = ((double)tzerolist[tzIter]->ts0_ns - (double)evt_timeGPS_nsec)*vdrift);
	// else //fTimeSelect_==1 for BNB data
	float diff;
	if (fTimeSelect==1) diff= fabs(0.001*(tzerolist[tzIter]->ts1_ns+fHardDelay)-Timeflash);
	else diff = fabs(0.001*(tzerolist[tzIter]->ts0_ns+fTimeZeroOffset-(double)evt_timeGPS_nsec)-Timeflash);
	if (diff<min_deltat) { min_deltat=diff; best_time_match=tzIter;}
      } // loop over tzeros     
      if (best_time_match>=0) {
	if (fverbose) std::cout << "Closest CRT hit in time to this flash is tzero no " << 
			best_time_match << " at time (us) " <<
			0.001*(tzerolist[best_time_match]->ts1_ns+fHardDelay) << std::endl;
      }// if CRT-flash match found
    } // if tzeros 

    if(fverbose){ 
      std::cout<<"event: "<<fEvtNum<<std::endl;
      std::cout<<"Flash: "<<i<<std::endl;
      std::cout<<"Beam: "<<fbeam<<std::endl;
      std::cout<<"Zflash: "<<Zflash<<std::endl;
      std::cout<<"Yflash: "<<Yflash<<std::endl;
      std::cout<<"PEflash: "<<PEflash<<std::endl;
      std::cout.precision(19);
      std::cout<<" "<<std::endl;
      std::cout<<"Flash time: "<<Flash_sec<< " seconds"<<std::endl;
      std::cout<<"Flash time: "<<Timeflash<< "  us w.r.t to trigger"<<std::endl;
      std::cout<<"Flash time: "<<Timeflash_ns<< "  ns w.r.t to trigger"<<std::endl;
      std::cout<<"Flash time: "<<Timeflash_ns_GPS<< "  ns in GPS"<<std::endl;
      std::cout<<" "<<std::endl;
    }
  } // loop over flashes
   
  
    double const vdrift = fDriftVel*0.001;  // in cm/ns
  // const detinfo::DetectorProperties *_detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
  // double const vdrift =  _detprop->DriftVelocity();  
  // std::cout << "drift velocity is " << vdrift << std::endl;
  //     vdrift*=0.001;  // in cm/ns

  // loop over tracks  
  if (tracklist.size()>0) {
    for (size_t trkIter = 0; trkIter < tracklist.size(); ++trkIter) {
      
      //    int TrackGood=0;
      float dist_besthit = 99999999.; int plane_besthit=111;
      double time_besthit=999999999.; float pe_besthit=0; float dla_besthit = 999.;
      int feb1_besthit=-1; int feb2_besthit=-1;
      TVector3 bestCRTpoint;
      double theta,phi,trklen;
      // fetch track length, start and end points, theta and phi
      auto startP=tracklist[trkIter]->Start();      
      auto endP=tracklist[trkIter]->End();      

      trklen = tracklist[trkIter]->Length();
      theta=tracklist[trkIter]->Theta();      phi=tracklist[trkIter]->Phi();
      if (phi>0) {theta=3.14159-theta; phi=phi-3.14159;}
      
      // get track directional cosines
      auto trackCosStart = tracklist[trkIter]->StartDirection();
      auto trackCosEnd = tracklist[trkIter]->EndDirection();

      double opang = trackCosStart.X()*trackCosEnd.X() +  trackCosStart.Y()*trackCosEnd.Y() + 
	trackCosStart.Z()*trackCosEnd.Z();
      
      //reject tracks that are too short and bend too much
      if (trklen>20 && opang>0.95)  {
	//      if (trklen>5 && opang>0.8)  {
	
	if (fverbose) {
	  std::cout << "Event " << evt.event() <<  " Track " << trkIter << " cos(opening angle) " << 
	    opang << "  track length " << trklen << std::endl;
	  std::cout << "        theta " << theta << " phi " << phi << std::endl;
	}
	
	int besttz=-1; 
	//loop over CRT tzeros
	if (tzerolist.size()>0) {   
	  for(size_t tzIter = 0; tzIter < tzerolist.size(); ++tzIter){   
	    
	    //calculate track shift in x for the time  of this CRT hit
	    double xshift = 0.0;

	    if (fTimeSelect==0) // for EXT BNB data
	      xshift = ((double)tzerolist[tzIter]->ts0_ns +fTimeZeroOffset- (double)evt_timeGPS_nsec)*vdrift;
	    else //fTimeSelect==1 for BNB data
	      xshift = ((double)(tzerolist[tzIter]->ts1_ns) + fHardDelay)*vdrift;	      
	    // verify that track is within the fiducial volume after this time shift
	    double test1 = startP.X()-xshift; double test2 = endP.X()-xshift;
	    if (test1>-10. && test1<270. && test2>-10 && test2<270.) {
	      
	      //  loop over CRT hits for this tzero
	      std::vector<art::Ptr<crt::CRTHit> > hitlist=fmht.at(tzIter);
	      if (hitlist.size()>0) {
		for (size_t ah = 0; ah< hitlist.size(); ++ah){	
		  
		  //adjust CRT hit positions for rough alignment correction 
		  //   temporary until the CRT geometry is updated with the precise positions from the laser survey
		  double crt_x=hitlist[ah]->x_pos;
		  double crt_y=hitlist[ah]->y_pos;
		  double crt_z=hitlist[ah]->z_pos;
		  
		  int crt_plane = (hitlist[ah]->plane)%10;
		  if (crt_plane==0) {
		    crt_x+=fAlignBotX;
		    crt_y+=fAlignBotY;
		    crt_z+=fAlignBotZ;
		  }
		  else if (crt_plane==1) {
		    crt_x+=fAlignAnodeX;
		    crt_y+=fAlignAnodeY;
		    crt_z+=fAlignAnodeZ;
		  }
		  else if (crt_plane==2) {
		    crt_x+=fAlignCathX;
		    crt_y+=fAlignCathY;
		    crt_z+=fAlignCathZ;
		  }
		  else if (crt_plane==3) {
		    crt_x+=fAlignTopX;
		    crt_y+=fAlignTopY;
		    crt_z+=fAlignTopZ;
		  }
		  TVector3 CRTpoint(crt_x,crt_y,crt_z);
		  
		  //calculate track shift in x for the time  of this CRT hit
		  if (fTimeSelect==0) // for EXT BNB data
		    xshift = ((double)hitlist[ah]->ts0_ns + fTimeZeroOffset - evt_timeGPS_nsec)*vdrift;
		  else //fTimeSelect_==1 for BNB data
		    xshift = ((double)(hitlist[ah]->ts1_ns) + fHardDelay)*vdrift;	      
		  
		  //  Correct start and end point for space charge with this tzero
		  geo::Point_t newStartP = startP; geo::Point_t newEndP = endP;
		  if(sce->EnableCalSpatialSCE()) {
		    geo::Point_t fTrackPos = startP;  fTrackPos.SetX(startP.X()-xshift);
		    geo::Vector_t fPosOffsets = sce->GetCalPosOffsets(geo::Point_t{fTrackPos.X(),fTrackPos.Y(),fTrackPos.Z()});
		    newStartP = geo::Point_t{fTrackPos.X() - fPosOffsets.X(), fTrackPos.Y() + fPosOffsets.Y(), 
							  fTrackPos.Z() + fPosOffsets.Z()};
		    // std::cout << fPosOffsets.X() << " " <<   fPosOffsets.Y() << " " <<  fPosOffsets.Z() << std::endl;
		    
		    fTrackPos = endP;  fTrackPos.SetX(endP.X()-xshift);
		    fPosOffsets = sce->GetCalPosOffsets(geo::Point_t{fTrackPos.X(),fTrackPos.Y(),fTrackPos.Z()});
		    newEndP = geo::Point_t{fTrackPos.X() - fPosOffsets.X(), fTrackPos.Y() + fPosOffsets.Y(), 
							fTrackPos.Z() + fPosOffsets.Z()};
		    
		    // std::cout << fPosOffsets.X() << " " <<   fPosOffsets.Y() << " " <<  fPosOffsets.Z() << std::endl;
		  }
		  else {
		    newStartP.SetX(startP.X()-xshift); newEndP.SetX(endP.X()-xshift);
		  }

		    
		  TVector3 trackstart(newStartP.X(),newStartP.Y(),newStartP.Z());
		  TVector3 trackend(newEndP.X(),newEndP.Y(),newEndP.Z());

		  
		  // calculate the distance of closest approach (DCA) of track to CRT hit
		  TVector3 denom = trackend-trackstart;
		  TVector3 a =CRTpoint-trackstart;  TVector3 b=CRTpoint-trackend;
		  TVector3 numer = a.Cross(b);
		  double dca = numer.Mag()/denom.Mag();
		  
		  // calculate distance from track end to hit.  
		  float dla = a.Mag();  float d2 = b.Mag();
		  if (d2<dla) dla=d2;
		  
		  
		  // if (dca<200.) {
		  // }

		  if (dca<dist_besthit) {
		    dla_besthit = dla;
		    besttz = tzIter;
		    dist_besthit=dca;
		    plane_besthit=(hitlist[ah]->plane)%10;
		    pe_besthit=hitlist[ah]->peshit;
		    feb1_besthit=hitlist[ah]->feb_id[0];  
		    feb2_besthit=hitlist[ah]->feb_id[1];

		    //	    art::Ptr<recob::OpFlash> flashptr = flashPtrMaker(j);
		    //	    art::Ptr<crt::CRTHit> crthitptr = crthitPtrMaker(k);
		    if (fTimeSelect==0)
		      time_besthit = (double)hitlist[ah]->ts0_ns + fTimeZeroOffset- evt_timeGPS_nsec;
		    else  time_besthit=hitlist[ah]->ts1_ns+ fHardDelay; 
		    bestCRTpoint=CRTpoint;
		  }
		} // loop over CRT hits

	      }// if hits 
	    }  // track fid vol check
	  } //loop over tzeros
	}  //if tzeros
	
	// fill histograms and creates associations	
	if (dist_besthit<200) {
	  //	  std::vector<art::Ptr<crt::CRTHit> > hitlist=fmht.at(besttz);
	  // int icountplanes =1;
	  // if (hitlist.size()>0) {
	  //   for (size_t ah = 0; ah< hitlist.size(); ++ah){	
	  //     if (hitlist[ah]->plane!=plane_besthit) icountplanes=2;
	  //   }
	  // }
	  if (fverbose) std::cout << besttz << std::endl;
	  hDistOne->Fill(dist_besthit);
	  
	  //calculate track shift in x for the time  of this CRT hit
	  double xshift = time_besthit*vdrift;
	  //  Correct start and end point for space charge with this tzero
	  geo::Point_t newStartP = startP; geo::Point_t newEndP = endP;
	  if(sce->EnableCalSpatialSCE()) {
	    geo::Point_t fTrackPos = startP;  fTrackPos.SetX(startP.X()-xshift);
	    geo::Vector_t fPosOffsets = sce->GetCalPosOffsets(geo::Point_t{fTrackPos.X(),fTrackPos.Y(),fTrackPos.Z()});
	    newStartP = geo::Point_t{fTrackPos.X() - fPosOffsets.X(), fTrackPos.Y() + fPosOffsets.Y(), 
				     fTrackPos.Z() + fPosOffsets.Z()};
	    //	    std::cout << fPosOffsets.X() << " " <<   fPosOffsets.Y() << " " <<  fPosOffsets.Z() << std::endl;
	    
	    fTrackPos = endP;  fTrackPos.SetX(endP.X()-xshift);
	    fPosOffsets = sce->GetCalPosOffsets(geo::Point_t{fTrackPos.X(),fTrackPos.Y(),fTrackPos.Z()});
	    newEndP = geo::Point_t{fTrackPos.X() - fPosOffsets.X(), fTrackPos.Y() + fPosOffsets.Y(), 
				   fTrackPos.Z() + fPosOffsets.Z()};
	    //	    std::cout << fPosOffsets.X() << " " <<   fPosOffsets.Y() << " " <<  fPosOffsets.Z() << std::endl;
	  }
	  else {
	    newStartP.SetX(startP.X()-xshift); newEndP.SetX(endP.X()-xshift);
	  }
	  
	  TVector3 trackstart(newStartP.X(),newStartP.Y(),newStartP.Z());
	  TVector3 trackend(newEndP.X(),newEndP.Y(),newEndP.Z());
	  
	  if (plane_besthit==1) {
	    if ((trackstart.X()>-10 && trackstart.X()<2)  || (trackend.X()>-10 && trackend.X()<2) )
	      hDistAn->Fill(dist_besthit); 
	  }
	  else if (plane_besthit==2) {
	    if ((trackstart.X()>255 && trackstart.X()<268)  || (trackend.X()>255 && trackend.X()<268) )
	      hDistCa->Fill(dist_besthit); 
	  }	  
	  hTimeBest->Fill(time_besthit*0.001);
	  if (plane_besthit==3) { dca3->Fill(dist_besthit);dla3->Fill(dla_besthit);dcn3->Fill(100.0*dist_besthit/dla_besthit);}
	  else if (plane_besthit==2) {dca2->Fill(dist_besthit);dla2->Fill(dla_besthit);dcn2->Fill(100.0*dist_besthit/dla_besthit);}
	  else if (plane_besthit==1) {dca1->Fill(dist_besthit);dla1->Fill(dla_besthit);dcn1->Fill(100.0*dist_besthit/dla_besthit);}
	  else if (plane_besthit==0) {dca0->Fill(dist_besthit);dla0->Fill(dla_besthit);dcn0->Fill(100.0*dist_besthit/dla_besthit);}




	  if ((dist_besthit<fMatchCut) || (dist_besthit<fMatchCutTop && plane_besthit==3)) {

	  // angle between track extrap and CRT plane
	  TVector3 trackdir = trackstart-trackend;
	  TVector3 proj=trackdir;  
	  if (plane_besthit==0 || plane_besthit==3) proj.SetY(0.0);
	  else proj.SetX(0.0);
	  trackdir.SetMag(1.0); proj.SetMag(1.0);
	  double cosang=trackdir.Dot(proj);
	  if (cosang<0) cosang*=-1.0;
	  if (cosang>1) { if (fverbose) std::cout << "bad value cosang " << cosang << std::endl; cosang=0.0;}
	  float iang = acos(cosang);
	  if (iang<0.35) dcab->Fill(dist_besthit);

	  pe->Fill(pe_besthit);
	  if (iang>1.4) pe2->Fill(pe_besthit);
	  peave->Fill(iang,pe_besthit);
	  pefull->Fill(iang,pe_besthit);
	  inang->Fill(iang);

	  if (plane_besthit==3) { 
	    hTop->Fill(bestCRTpoint.Z(),bestCRTpoint.X());
	    double dx = (bestCRTpoint.Y()-trackend.Y())*(trackstart.X()-trackend.X())/(trackstart.Y()-trackend.Y());
	    dx += trackend.X(); dx-=bestCRTpoint.X(); dx*=-1.0;
	    topx->Fill(dx);
	    topxp->Fill(bestCRTpoint.X(),dx);
	    topx2->Fill(bestCRTpoint.X(),dx);
	    topxc->Fill(bestCRTpoint.X());
	    double dz = (bestCRTpoint.Y()-trackend.Y())*(trackstart.Z()-trackend.Z())/(trackstart.Y()-trackend.Y());
	    dz += trackend.Z(); dz-=bestCRTpoint.Z(); dz*=-1.0;
	    topz->Fill(dz);
	    topzp->Fill(bestCRTpoint.Z(),dz);
	    topz2->Fill(bestCRTpoint.Z(),dz);
	    topzc->Fill(bestCRTpoint.Z());
	    if (feb1_besthit==113 || feb1_besthit==116) topx11->Fill(dx);
	    if (feb2_besthit==113 || feb2_besthit==116) topx11->Fill(dx);
	    if (feb1_besthit==114 || feb1_besthit==117 ||feb1_besthit==119) topx22->Fill(dx);
	    if (feb2_besthit==114 || feb2_besthit==117 ||feb2_besthit==119) topx22->Fill(dx);
	    if (feb1_besthit==115 || feb1_besthit==118 ||feb1_besthit==129 ||feb1_besthit==120) topx33->Fill(dx);
	    if (feb2_besthit==115 || feb2_besthit==118 ||feb2_besthit==129 ||feb2_besthit==120) topx33->Fill(dx);
	    if (feb1_besthit==127 || feb1_besthit==121) topx44->Fill(dx);
	    if (feb2_besthit==127 || feb2_besthit==121) topx44->Fill(dx);
	    //
	    if (feb1_besthit==109 || feb2_besthit==109)  {topz109->Fill(dz);top2z109->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==105 || feb2_besthit==105)   {topz105->Fill(dz);top2z105->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==106 || feb2_besthit==106)   {topz106->Fill(dz);top2z106->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==107 || feb2_besthit==107)   {topz107->Fill(dz);top2z107->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==108 || feb2_besthit==108)   {topz108->Fill(dz);top2z108->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==112 || feb2_besthit==112)   {topz112->Fill(dz);top2z112->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==111 || feb2_besthit==111)   {topz111->Fill(dz);top2z111->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==128 || feb2_besthit==128)   {topz128->Fill(dz);top2z128->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==126 || feb2_besthit==126)   {topz126->Fill(dz);top2z126->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==125 || feb2_besthit==125)   {topz125->Fill(dz);top2z125->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==195 || feb2_besthit==195)   {topz195->Fill(dz);top2z195->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==123 || feb2_besthit==123)   {topz123->Fill(dz);top2z123->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==124 || feb2_besthit==124)   {topz124->Fill(dz);top2z124->Fill(dz,bestCRTpoint.Z());}
	    if (feb1_besthit==113 || feb2_besthit==113)   {topx113->Fill(dx);top2x113->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==114 || feb2_besthit==114)   {topx114->Fill(dx);top2x114->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==115 || feb2_besthit==115)   {topx115->Fill(dx);top2x115->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==116 || feb2_besthit==116)   {topx116->Fill(dx);top2x116->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==117 || feb2_besthit==117)   {topx117->Fill(dx);top2x117->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==118 || feb2_besthit==118)   {topx118->Fill(dx);top2x118->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==119 || feb2_besthit==119)   {topx119->Fill(dx);top2x119->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==120 || feb2_besthit==120)   {topx120->Fill(dx);top2x120->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==121 || feb2_besthit==121)   {topx121->Fill(dx);top2x121->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==129 || feb2_besthit==129)   {topx129->Fill(dx);top2x129->Fill(dx,bestCRTpoint.X());}
	    if (feb1_besthit==127 || feb2_besthit==127)   {topx127->Fill(dx);top2x127->Fill(dx,bestCRTpoint.X());}

	  }
	  else if (plane_besthit==2) { 
	    hPipe->Fill(bestCRTpoint.Z(),bestCRTpoint.Y());
	    double dy = (bestCRTpoint.X()-trackend.X())*(trackstart.Y()-trackend.Y())/(trackstart.X()-trackend.X());
	    dy += trackend.Y(); dy-=bestCRTpoint.Y(); dy*=-1.0;
	    caty->Fill(dy);
	    catyp->Fill(bestCRTpoint.Y(),dy);
	    double dz = (bestCRTpoint.X()-trackend.X())*(trackstart.Z()-trackend.Z())/(trackstart.X()-trackend.X());
	    dz += trackend.Z(); dz-=bestCRTpoint.Z(); dz*=-1.0;
	    catz->Fill(dz);
	    catzp->Fill(bestCRTpoint.Z(),dz);
	    if  (feb1_besthit==15 ||  feb1_besthit==20 ||  feb1_besthit==46 ||  feb1_besthit==48 ||  feb1_besthit==50  ) caty1->Fill(dy);
	    if  (feb2_besthit==15 ||  feb2_besthit==20 ||  feb2_besthit==46 ||  feb2_besthit==48 ||  feb2_besthit==50  ) caty1->Fill(dy);
	    if  (feb1_besthit==16 ||  feb1_besthit==21 ||  feb1_besthit==47 ||  feb1_besthit==49 ||  feb1_besthit==51  ) caty3->Fill(dy);
	    if  (feb2_besthit==16 ||  feb2_besthit==21 ||  feb2_besthit==47 ||  feb2_besthit==49 ||  feb2_besthit==51  ) caty3->Fill(dy);
	    if  ((feb1_besthit>52 && feb1_besthit<56) || (feb2_besthit>52 && feb2_besthit<56)) caty5->Fill(dy);
	    if  ((feb1_besthit>31 && feb1_besthit<39) || (feb2_besthit>31 && feb2_besthit<39)) catz2->Fill(dz);
	    if  ((feb1_besthit>38 && feb1_besthit<46) || (feb2_besthit>38 && feb2_besthit<46)) catz4->Fill(dz);

	  }
	  else if (plane_besthit==1) { 
	    hFT->Fill(bestCRTpoint.Z(),bestCRTpoint.Y());
	    double dy = (bestCRTpoint.X()-trackend.X())*(trackstart.Y()-trackend.Y())/(trackstart.X()-trackend.X());
	    dy += trackend.Y(); dy-=bestCRTpoint.Y(); dy*=-1.0;
	    any->Fill(dy);
	    double dz = (bestCRTpoint.X()-trackend.X())*(trackstart.Z()-trackend.Z())/(trackstart.X()-trackend.X());
	    dz += trackend.Z(); dz-=bestCRTpoint.Z(); dz*=-1.0;
	    anz->Fill(dz);
	  }
	  else if (plane_besthit==0) { 
	    hBot->Fill(bestCRTpoint.Z(),bestCRTpoint.X());
	    double dx = (bestCRTpoint.Y()-trackend.Y())*(trackstart.X()-trackend.X())/(trackstart.Y()-trackend.Y());
	    dx += trackend.X(); dx-=bestCRTpoint.X(); dx*=-1.0;
	    botx->Fill(dx);
	    double dz = (bestCRTpoint.Y()-trackend.Y())*(trackstart.Z()-trackend.Z())/(trackstart.Y()-trackend.Y());
	    dz += trackend.Z(); dz-=bestCRTpoint.Z(); dz*=-1.0;
	    botz->Fill(dz);
	    if (feb1_besthit==11 || feb2_besthit==11) botz2->Fill(dz);
	    if (feb1_besthit==12 || feb2_besthit==12) botx2->Fill(dx);
	    if (feb1_besthit==14 || feb1_besthit==17 || feb1_besthit==18 || feb1_besthit==19 ) botz1->Fill(dz);
	    if (feb2_besthit==14 || feb2_besthit==17 || feb2_besthit==18 || feb2_besthit==19 ) botz1->Fill(dz);
	    if (feb1_besthit==24 || feb1_besthit==23 || feb1_besthit==22 ) botx1->Fill(dx);
	    if (feb2_besthit==24 || feb2_besthit==23 || feb2_besthit==22 ) botx1->Fill(dx);
	  }


	  }  // end if dca<matchcut
	  else hDistNone->Fill(100.);
	  //
	  
	} // if hit is close	  
      } // if good track
      
      
      //    if (TrackGood) {       hThetaGood->Fill(theta);      hPhiGood->Fill(phi); hTvsPGood->Fill(phi,theta);}
      hTrackLength->Fill(trklen);
      hOpeningAngle->Fill(opang);
      //    hThetaAll->Fill(theta);
      //hPhiAll->Fill(phi);    
      
    } //loop over tracks
  }  // if tracks
  
  

}

void T0recoCRTHitAna2::beginJob()
{
  // Implementation of optional member function here.

  // Create histograms 
  hTrackLength = tfs->make<TH1F>("hTrackLength","hTrackLength",175,0.,350.);
  hTrackLength->GetXaxis()->SetTitle("Track Length (cm)");
  //  
  hOpeningAngle = tfs->make<TH1F>("hOpeningAngle","hOpeningAngle",50,0.,1.);
  hOpeningAngle->GetXaxis()->SetTitle("cosine opening angle");
  //
  
  hDistOne = tfs->make<TH1F>("hDistOne","hDistOne",200,0.,200.);
  hDistOne->GetXaxis()->SetTitle("distance (cm)");
  hDistAn = tfs->make<TH1F>("hDistAn","hDistAn",200,0.,200.);
  hDistAn->GetXaxis()->SetTitle("distance (cm)");
  hDistCa = tfs->make<TH1F>("hDistCa","hDistCa",200,0.,200.);
  hDistCa->GetXaxis()->SetTitle("distance (cm)");
  // hDistTwo= tfs->make<TH1F>("hDistTwo","hDistTwo",200,0.,200.);    
  // hDistTwo->GetXaxis()->SetTitle("distance (cm)");
  hDistNone= tfs->make<TH1F>("hDistNone","hDistNone",200,0.,200.);    
  hDistNone->GetXaxis()->SetTitle("distance (cm)");
  hTimeBest = tfs->make<TH1F>("hTimeBest","hTimeBest",200,0.,200.);
  hTimeBest->GetXaxis()->SetTitle("time (us)");


  dca0 = tfs->make<TH1F>("dca0","dca0",200,0.,200.); 
  dca0->GetXaxis()->SetTitle("distance (cm)");
  dca1 =tfs->make<TH1F>("dca1","dca1",200,0.,200.);
  dca1->GetXaxis()->SetTitle("distance (cm)");
  dca2 = tfs->make<TH1F>("dca2","dca2",200,0.,200.);
  dca2->GetXaxis()->SetTitle("distance (cm)");
  dca3 = tfs->make<TH1F>("dca3","dca3",200,0.,200.);
  dca3->GetXaxis()->SetTitle("distance (cm)");
  dla0 = tfs->make<TH1F>("dla0","dla0",200,0.,800.); 
  dla0->GetXaxis()->SetTitle("distance (cm)");
  dla1 =tfs->make<TH1F>("dla1","dla1",200,0.,800.);
  dla1->GetXaxis()->SetTitle("distance (cm)");
  dla2 = tfs->make<TH1F>("dla2","dla2",200,0.,800.);
  dla2->GetXaxis()->SetTitle("distance (cm)");
  dla3 = tfs->make<TH1F>("dla3","dla3",200,0.,2000.);
  dla3->GetXaxis()->SetTitle("distance (cm)");
  dcn0 = tfs->make<TH1F>("dcn0","dca/el",200,0.,40.); 
  dcn0->GetXaxis()->SetTitle("distance (cm)");
  dcn1 =tfs->make<TH1F>("dcn1","dca/el",200,0.,40.);
  dcn1->GetXaxis()->SetTitle("distance (cm)");
  dcn2 = tfs->make<TH1F>("dcn2","dca/el",200,0.,40.);
  dcn2->GetXaxis()->SetTitle("dca/el");
  dcn3 = tfs->make<TH1F>("dcn3","dcn3",200,0.,40.);
  dcn3->GetXaxis()->SetTitle("distance (cm)");
  dcab = tfs->make<TH1F>("dcab","dcab",200,0.,200.);
  dcab->GetXaxis()->SetTitle("distance (cm)");
  botx = tfs->make<TH1F>("botx","botx",200,-100.,100.);
  botx->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  botz = tfs->make<TH1F>("botz","botz",200,-100.,100.);
  botz->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  botx1 = tfs->make<TH1F>("botx1","botx1",200,-100.,100.);
  botx1->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  botz1 = tfs->make<TH1F>("botz1","botz1",200,-100.,100.);
  botz1->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  botx2 = tfs->make<TH1F>("botx2","botx2",200,-100.,100.);
  botx2->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  botz2 = tfs->make<TH1F>("botz2","botz2",200,-100.,100.);
  botz2->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  any = tfs->make<TH1F>("any","any",200,-100.,100.);
  any->GetXaxis()->SetTitle("y separation track projection and CRT hit (cm)");
  anz = tfs->make<TH1F>("anz","anz",200,-100.,100.);
  anz->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  caty = tfs->make<TH1F>("caty","caty",200,-100.,100.);
  caty->GetXaxis()->SetTitle("y separation track projection and CRT hit (cm)");
  catz = tfs->make<TH1F>("catz","catz",200,-100.,100.);
  catz->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  catyp = tfs->make<TProfile>("catyp","catyp",100,-300.,300.,-200.,200.);
  catyp->GetXaxis()->SetTitle("y of CRT hit (cm)");
  catyp->GetYaxis()->SetTitle("y different hit-track");
  catzp = tfs->make<TProfile>("catzp","catzp",50,-200.,1200.,-200.,200.);
  catzp->GetXaxis()->SetTitle("z of CRT hit (cm)");
  catzp->GetYaxis()->SetTitle("z different hit-track");
  topx11 = tfs->make<TH1F>("topx11","topx11",200,-100.,100.);
  topx11->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  topx22 = tfs->make<TH1F>("topx22","topx22",200,-100.,100.);
  topx22->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  topx33 = tfs->make<TH1F>("topx33","topx33",200,-100.,100.);
  topx33->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  topx44 = tfs->make<TH1F>("topx44","topx44",200,-100.,100.);
  topx44->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  topx = tfs->make<TH1F>("topx","topx",200,-100.,100.);
  topx->GetXaxis()->SetTitle("x separation track projection and CRT hit (cm)");
  topz = tfs->make<TH1F>("topz","topz",200,-100.,100.);
  topz->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  topxc = tfs->make<TH1F>("topxc","topxc",100,-300.,600.);
  topxc->GetXaxis()->SetTitle("x of matched CRT hits (cm)");
  topzc = tfs->make<TH1F>("topzc","topzc",175,-200.,1200.);
  topzc->GetXaxis()->SetTitle("z of matched CRT hits (cm)");
  topx2 = tfs->make<TH2F>("topx2","topx2",100,-300,600,50,-200,200);
  topx2->GetXaxis()->SetTitle("x of CRT hit (cm)");
  topx2->GetYaxis()->SetTitle("x different hit-track");
  topz2 = tfs->make<TH2F>("topz2","topz2",100,-200,1200,50,-200,200);
  topz2->GetXaxis()->SetTitle("z of CRT hit (cm)");
  topz2->GetYaxis()->SetTitle("z different hit-track");
  topxp = tfs->make<TProfile>("topxp","topxp",100,-300.,600.,-200.,200.);
  topxp->GetXaxis()->SetTitle("x of CRT hit (cm)");
  topxp->GetYaxis()->SetTitle("x different hit-track");
  topzp = tfs->make<TProfile>("topzp","topzp",100,-200.,1200.,-200.,200.);
  topzp->GetXaxis()->SetTitle("z of CRT hit (cm)");
  topzp->GetYaxis()->SetTitle("z different hit-track");
  caty1 = tfs->make<TH1F>("caty1","caty1",200,-100.,100.);
  caty1->GetXaxis()->SetTitle("y separation track projection and CRT hit (cm)");
  catz2 = tfs->make<TH1F>("catz2","catz2",200,-100.,100.);
  catz2->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  caty3 = tfs->make<TH1F>("caty3","caty3",200,-100.,100.);
  caty3->GetXaxis()->SetTitle("y separation track projection and CRT hit (cm)");
  catz4 = tfs->make<TH1F>("catz4","catz4",200,-100.,100.);
  catz4->GetXaxis()->SetTitle("z separation track projection and CRT hit (cm)");
  caty5 = tfs->make<TH1F>("caty5","caty5",200,-100.,100.);
  caty5->GetXaxis()->SetTitle("y separation track projection and CRT hit (cm)");
  //
  pe = tfs->make<TH1F>("pe","pe",100,0.,500.);
  pe->GetXaxis()->SetTitle("hit pe");
  pe2 = tfs->make<TH1F>("pe2","pe2",100,0.,500.);
  pe2->GetXaxis()->SetTitle("hit pe");
  peave = tfs->make<TProfile>("peave","peave",100,0.,1.571,0.,500.,"s");
  peave->GetXaxis()->SetTitle("incident angle of track (rad)");
  peave->GetYaxis()->SetTitle("hit pe");
  pefull = tfs->make<TH2F>("pefull","pefull",100,0.,1.571,100,0.,500.);
  pefull->GetXaxis()->SetTitle("incident angle of track (rad)");
  pefull->GetYaxis()->SetTitle("hit pe");
  inang = tfs->make<TH1F>("inang","inang",100,0.,1.571);
  inang->GetXaxis()->SetTitle("incident angle of track (rad)");
  //
  topz109 = tfs->make<TH1F>("topz109","topz109",50,-100,100);
  topz105 = tfs->make<TH1F>("topz105","topz105",50,-100,100);
  topz106 = tfs->make<TH1F>("topz106","topz106",50,-100,100);
  topz107 = tfs->make<TH1F>("topz107","topz107",50,-100,100);
  topz108 = tfs->make<TH1F>("topz108","topz108",50,-100,100);
  topz112 = tfs->make<TH1F>("topz112","topz112",50,-100,100);
  topz111 = tfs->make<TH1F>("topz111","topz111",50,-100,100);
  topz128 = tfs->make<TH1F>("topz128","topz128",50,-100,100);
  topz126 = tfs->make<TH1F>("topz126","topz126",50,-100,100);
  topz125 = tfs->make<TH1F>("topz125","topz125",50,-100,100);
  topz195 = tfs->make<TH1F>("topz195","topz195",50,-100,100);
  topz123 = tfs->make<TH1F>("topz123","topz123",50,-100,100);
  topz124 = tfs->make<TH1F>("topz124","topz124",50,-100,100);
  topx113 = tfs->make<TH1F>("topx113","topx113",50,-100,100);
  topx114 = tfs->make<TH1F>("topx114","topx114",50,-100,100);
  topx115 = tfs->make<TH1F>("topx115","topx115",50,-100,100);
  topx116 = tfs->make<TH1F>("topx116","topx116",50,-100,100);
  topx117 = tfs->make<TH1F>("topx117","topx117",50,-100,100);
  topx118 = tfs->make<TH1F>("topx118","topx118",50,-100,100);
  topx119 = tfs->make<TH1F>("topx119","topx119",50,-100,100);
  topx120 = tfs->make<TH1F>("topx120","topx120",50,-100,100);
  topx121 = tfs->make<TH1F>("topx121","topx121",50,-100,100);
  topx129 = tfs->make<TH1F>("topx129","topx129",50,-100,100);
  topx127 = tfs->make<TH1F>("topx127","topx127",50,-100,100);
  //
  top2z109 = tfs->make<TH2F>("top2z109","top2z109",50,-100,100,50,900,1200);
  top2z105 = tfs->make<TH2F>("top2z105","top2z105",50,-100,100,50,750,1000);
  top2z106 = tfs->make<TH2F>("top2z106","top2z106",50,-100,100,50,500,850);
  top2z107 = tfs->make<TH2F>("top2z107","top2z107",50,-100,100,50,400,600);
  top2z108 = tfs->make<TH2F>("top2z108","top2z108",50,-100,100,50,400,600);
  top2z112 = tfs->make<TH2F>("top2z112","top2z112",50,-100,100,50,160,450);
  top2z111 = tfs->make<TH2F>("top2z111","top2z111",50,-100,100,50,-20,250);
  top2z128 = tfs->make<TH2F>("top2z128","top2z128",50,-100,100,50,-170,70);
  top2z126 = tfs->make<TH2F>("top2z126","top2z126",50,-100,100,50,-20,250);
  top2z125 = tfs->make<TH2F>("top2z125","top2z125",50,-100,100,50,160,450);
  top2z195 = tfs->make<TH2F>("top2z195","top2z195",50,-100,100,50,900,1200);
  top2z123 = tfs->make<TH2F>("top2z123","top2z123",50,-100,100,50,750,1000);
  top2z124 = tfs->make<TH2F>("top2z124","top2z124",50,-100,100,50,500,850);
  top2x113 = tfs->make<TH2F>("top2x113","top2x113",50,-100,100,50,-260,0);
  top2x114 = tfs->make<TH2F>("top2x114","top2x114",50,-100,100,50,-100,200);
  top2x115 = tfs->make<TH2F>("top2x115","top2x115",50,-100,100,50,100,350);
  top2x116 = tfs->make<TH2F>("top2x116","top2x116",50,-100,100,50,-260,0);
  top2x117 = tfs->make<TH2F>("top2x117","top2x117",50,-100,100,50,-100,200);
  top2x118 = tfs->make<TH2F>("top2x118","top2x118",50,-100,100,50,100,350);
  top2x119 = tfs->make<TH2F>("top2x119","top2x119",50,-100,100,50,-100,200);
  top2x120 = tfs->make<TH2F>("top2x120","top2x120",50,-100,100,50,100,350);
  top2x121 = tfs->make<TH2F>("top2x121","top2x121",50,-100,100,50,300,520);
  top2x129 = tfs->make<TH2F>("top2x129","top2x129",50,-100,100,50,100,350);
  top2x127 = tfs->make<TH2F>("top2x127","top2x127",50,-100,100,50,300,520);


  /*
  hThetaAll = tfs->make<TH1F>("hThetaAll","hThetaAll",100,0.,3.1416);
  hThetaAll->GetXaxis()->SetTitle("theta (radians)");
  hThetaACPT= tfs->make<TH1F>("hThetaACPT","hThetaACPT",100,0.,3.1416);
  hThetaACPT->GetXaxis()->SetTitle("theta (radians)");
  hThetaGood = tfs->make<TH1F>("hThetaGood","hThetaGood",100,0.,3.1416);
  hThetaGood->GetXaxis()->SetTitle("theta (radians)");
  hThetaGoodA = tfs->make<TH1F>("hThetaGoodA","hThetaGoodA",100,0.,3.1416);
  hThetaGoodA->GetXaxis()->SetTitle("theta (radians)");
  hThetaGoodY = tfs->make<TH1F>("hThetaGoodY","hThetaGoodY",100,0.,3.1416);
  hThetaGoodY->GetXaxis()->SetTitle("theta (radians)");
  hThetaGoodN = tfs->make<TH1F>("hThetaGoodN","hThetaGoodN",100,0.,3.1416);
  hThetaGoodN->GetXaxis()->SetTitle("theta (radians)");
  hThetaAnodeY = tfs->make<TH1F>("hThetaAnodeY","hThetaAnodeY",100,0.,3.1416);
  hThetaAnodeY->GetXaxis()->SetTitle("theta (radians)");
  hThetaAnodeN = tfs->make<TH1F>("hThetaAnodeN","hThetaAnodeN",100,0.,3.1416);
  hThetaAnodeN->GetXaxis()->SetTitle("theta (radians)");
  hThetaCathY = tfs->make<TH1F>("hThetaCathY","hThetaCathY",100,0.,3.1416);
  hThetaCathY->GetXaxis()->SetTitle("theta (radians)");
  hThetaCathN = tfs->make<TH1F>("hThetaCathN","hThetaCathN",100,0.,3.1416);
  hThetaCathN->GetXaxis()->SetTitle("theta (radians)");
  hPhiAll= tfs->make<TH1F>("hPhiAll","hPhiAll",100,-3.1416,0.);
  hPhiAll->GetXaxis()->SetTitle("phi (radians)");
  hPhiACPT = tfs->make<TH1F>("hPhiACPT","hPhiACPT",100,-3.1416,0.);
  hPhiACPT->GetXaxis()->SetTitle("phi (radians)");
  hPhiGood= tfs->make<TH1F>("hPhiGood","hPhiGood",100,-3.1416,0.);
  hPhiGood->GetXaxis()->SetTitle("phi (radians)");
  hPhiGoodA= tfs->make<TH1F>("hPhiGoodA","hPhiGoodA",100,-3.1416,0.);
  hPhiGoodA->GetXaxis()->SetTitle("phi (radians)");
  hPhiGoodY= tfs->make<TH1F>("hPhiGoodY","hPhiGoodY",100,-3.1416,0.);
  hPhiGoodY->GetXaxis()->SetTitle("phi (radians)");
  hPhiGoodN= tfs->make<TH1F>("hPhiGoodN","hPhiGoodN",100,-3.1416,0.);
  hPhiGoodN->GetXaxis()->SetTitle("phi (radians)");
  hPhiAnodeY= tfs->make<TH1F>("hPhiAnodeY","hPhiAnodeY",100,-3.1416,0.);
  hPhiAnodeY->GetXaxis()->SetTitle("phi (radians)");
  hPhiAnodeN= tfs->make<TH1F>("hPhiAnodeN","hPhiAnodeN",100,-3.1416,0.);
  hPhiAnodeN->GetXaxis()->SetTitle("phi (radians)");
  hPhiCathY= tfs->make<TH1F>("hPhiCathY","hPhiCathY",100,-3.1416,0.);
  hPhiCathY->GetXaxis()->SetTitle("phi (radians)");
  hPhiCathN= tfs->make<TH1F>("hPhiCathN","hPhiCathN",100,-3.1416,0.);
  hPhiCathN->GetXaxis()->SetTitle("phi (radians)");
  hTvsPACPT= tfs->make<TH2F>("hTvsPACPT","hTvsPACPT",50,-3.1416,0.,50,0.,3.1416);
  hTvsPACPT->GetXaxis()->SetTitle("phi (radians)");
  hTvsPACPT->GetYaxis()->SetTitle("theta (radians)");
  hTvsPGood= tfs->make<TH2F>("hTvsPGood","hTvsPGood",50,-3.1416,0.,50,0.,3.1416);
  hTvsPGood->GetXaxis()->SetTitle("phi (radians)");
  hTvsPGood->GetYaxis()->SetTitle("theta (radians)");
  hTvsPGoodA= tfs->make<TH2F>("hTvsPGoodA","hTvsPGoodA",50,-3.1416,0.,50,0.,3.1416);
  hTvsPGoodA->GetXaxis()->SetTitle("phi (radians)");
  hTvsPGoodA->GetYaxis()->SetTitle("theta (radians)");
  hTvsPGoodY= tfs->make<TH2F>("hTvsPGoodY","hTvsPGoodY",50,-3.1416,0.,50,0.,3.1416);
  hTvsPGoodY->GetXaxis()->SetTitle("phi (radians)");
  hTvsPGoodY->GetYaxis()->SetTitle("theta (radians)");
  hTvsPGoodN= tfs->make<TH2F>("hTvsPGoodN","hTvsPGoodN",50,-3.1416,0.,50,0.,3.1416);
  hTvsPGoodN->GetXaxis()->SetTitle("phi (radians)");
  hTvsPGoodN->GetYaxis()->SetTitle("theta (radians)");
  hTvsPAnodeY= tfs->make<TH2F>("hTvsPAnodeY","hTvsPAnodeY",50,-3.1416,0.,50,0.,3.1416);
  hTvsPAnodeY->GetXaxis()->SetTitle("phi (radians)");
  hTvsPAnodeY->GetYaxis()->SetTitle("theta (radians)");
  hTvsPAnodeN= tfs->make<TH2F>("hTvsPAnodeN","hTvsPAnodeN",50,-3.1416,0.,50,0.,3.1416);
  hTvsPAnodeN->GetXaxis()->SetTitle("phi (radians)");
  hTvsPAnodeN->GetYaxis()->SetTitle("theta (radians)");
  hTvsPCathY= tfs->make<TH2F>("hTvsPCathY","hTvsPCathY",50,-3.1416,0.,50,0.,3.1416);
  hTvsPCathY->GetXaxis()->SetTitle("phi (radians)");
  hTvsPCathY->GetYaxis()->SetTitle("theta (radians)");
  hTvsPCathN= tfs->make<TH2F>("hTvsPCathN","hTvsPCathN",50,-3.1416,0.,50,0.,3.1416);
  hTvsPCathN->GetXaxis()->SetTitle("phi (radians)");
  hTvsPCathN->GetYaxis()->SetTitle("theta (radians)");


  //
  for (int i=0;i<4;++i) {
    TString label1 = Form("hDistTrue%1d",i);
    hDistTrue[i] = tfs->make<TH1F>(label1,label1,100,0.,100.);
    TString label2 = Form("hDistWrong%1d",i);
    hDistWrong[i]= tfs->make<TH1F>(label2,label2,100,0.,100.);    
  }
  //
  hDistTrueAll = tfs->make<TH1F>("hDistTrueAll","hDistTrueAll",100,0.,100.);
  hDistWrongAll= tfs->make<TH1F>("hDistWrongAll","hDistWrongAll",100,0.,100.);    
  hDistNone= tfs->make<TH1F>("hDistNone","hDistNone",100,0.,100.);    
  //
  hDistTrueA = tfs->make<TH1F>("hDistTrueA","hDistTrueA",100,0.,100.);
  hDistWrongA =  tfs->make<TH1F>("hDistWrongA","hDistWrongA",100,0.,100.);    
  hDistNoneA = tfs->make<TH1F>("hDistNoneA","hDistNoneA",100,0.,100.);    
  //
  hPlaneClosest = tfs->make<TH1F>("PlaneClosest","PlaneClosest",4,-0.5,3.5);
  hPlaneCorr = tfs->make<TH1F>("PlaneCorr","PlaneCorr",4,-0.5,3.5);
  hPlaneWrong = tfs->make<TH1F>("PlaneWrong","PlaneWrong",4,-0.5,3.5);
  //
  hDistMistake = tfs->make<TH1F>("hDistMistake","hDistMistake",100,0.,10000.);
  //
  hTimeDiffCorr = tfs->make<TH1F>("hTimeDiffCorr","hTimeDiffCorr",500,-25.,25.);
  hTimeDiffWrong = tfs->make<TH1F>("hTimeDiffWrong","hTimeDiffWrong",500,-25.,25.);
  hTimeDiffNone = tfs->make<TH1F>("hTimeDiffNone","hTimeDiffNone",500,-25.,25.);
  */

    /*  
  hFlashTimeDis = tfs->make<TH1F>("hFlashTimDis","hFlashTimDis",2000,-5,25);
  hFlashTimeDis->GetXaxis()->SetTitle("Flash Time w.r.t. trigger (us)");
  hFlashTimeDis->GetYaxis()->SetTitle("Entries/bin");  

  hFlashTimeDis_b0 = tfs->make<TH1F>("hFlashTimDis_b0","hFlashTimDis_b0",2000,-5,25);
  hFlashTimeDis_b0->GetXaxis()->SetTitle("Flash_bo Time w.r.t. trigger (us)");
  hFlashTimeDis_b0->GetYaxis()->SetTitle("Entries/bin");

  hTFvsTH_t1 = tfs->make<TH1F>("hBeamMatching","hBeamMatching",500,-1000,1000);
  hTFvsTH_t1->GetXaxis()->SetTitle("Flash Time w.r.t. trigger - CRTHit Time_t1 (ns)");
  hTFvsTH_t1->GetYaxis()->SetTitle("Entries/bin");

  hTFvsTH_t1_2d = tfs->make<TH2F>("hBeamMatching2","hBeamMatching2",6,-3,3,500,0,1000);
  hTFvsTH_t1_2d->GetXaxis()->SetTitle("Flash Time - CRTHit Time (s)");
  hTFvsTH_t1_2d->GetYaxis()->SetTitle("Flash Time w.r.t Trigger - CRTHit_Time_t1 (ns)");
  hTFvsTH_t1_2d->SetOption("COLZ"); 

  hTFvsTH_t0 = tfs->make<TH1F>("hGPSMatching","GPSMatching",2000,0,2000000);
  hTFvsTH_t0->GetXaxis()->SetTitle("Flash_Time_GPS - CRTHit_Time_T0 (ns)");
  hTFvsTH_t0->GetYaxis()->SetTitle("Entries/bin");

  hTFvsTH_t0_2d = tfs->make<TH2F>("hGPSMatching2","hGPSMatching2",6,-3,3,2000,0,2000000);
  hTFvsTH_t0_2d->GetXaxis()->SetTitle("Flash Time - CRTHit Time (s)");
  hTFvsTH_t0_2d->GetYaxis()->SetTitle("Flasf_Time_GPS - CRTHit_Time_T0 (ns)");
  hTFvsTH_t0_2d->SetOption("COLZ"); 

  hTFvsTH_t0_t1 = tfs->make<TH2F>("hGPSBeamMatching","hGPSBeamMatching",2000,0,2000000,500,0,1000);
  hTFvsTH_t0_t1->GetXaxis()->SetTitle("Flash_Time_GPS - CRTHit_Time_T0 (ns)");
  hTFvsTH_t0_t1->GetYaxis()->SetTitle("Flash Time w.r.t Trigger - CRTHit_Time_t1 (ns)");
  hTFvsTH_t0_t1->SetOption("COLZ"); 

  hTFvsTH_plane_t0 = tfs->make<TH2F>("hGPSBeamMatchingPlane","hGPSBeamMatchingPlane",4,0,4, 4000,0,2000000);
  hTFvsTH_plane_t0->GetXaxis()->SetTitle("CRT plane (0=bottom, 1=FT, 2=Pipe, 3=Top))");
  hTFvsTH_plane_t0->GetYaxis()->SetTitle("Flash Time_GPS - CRTHit Time_t0 (ns)");
  hTFvsTH_plane_t0->SetOption("COLZ"); 


  hNFlavsNHit = tfs->make<TH2F>("hNFlavsNHit","hNFlavsNHit",30,0,30,100,0,300);
  hNFlavsNHit->GetXaxis()->SetTitle("Number of Flashes per event");
  hNFlavsNHit->GetYaxis()->SetTitle("Number of CRT Hits per event");
  hNFlavsNHit->GetZaxis()->SetTitle("Entries/bin");
  hNFlavsNHit->SetOption("COLZ");

  hNHitperFla = tfs->make<TH1F>("hNHitperFla","hNHitperFla",205,-5,200);
  hNHitperFla->GetXaxis()->SetTitle("N^{o} of CRTHits per Flash");
  hNHitperFla->GetYaxis()->SetTitle("Entries/bin");

  hNHitperFla0 = tfs->make<TH1F>("hNHitperFlaBot","hNHitperFlaBot",205,-5,200);
  hNHitperFla0->GetXaxis()->SetTitle("N^{o} of CRTHits per Flash in Bottom");
  hNHitperFla0->GetYaxis()->SetTitle("Entries/bin");

  hNHitperFla1 = tfs->make<TH1F>("hNHitperFlaFT","hNHitperFlaFT",205,-5,200);
  hNHitperFla1->GetXaxis()->SetTitle("N^{o} of CRTHits per Flash in FT");
  hNHitperFla1->GetYaxis()->SetTitle("Entries/bin");

  hNHitperFla2 = tfs->make<TH1F>("hNHitperFlaPipe","hNHitperFlaPipe",205,-5,200);
  hNHitperFla2->GetXaxis()->SetTitle("N^{o} of CRTHits per Flash in Pipe");
  hNHitperFla2->GetYaxis()->SetTitle("Entries/bin");

  hNHitperFla3 = tfs->make<TH1F>("hNHitperFlaTop","hNHitperFlaTop",205,-5,200);
  hNHitperFla3->GetXaxis()->SetTitle("N^{o} of CRTHits per Flash in Top");
  hNHitperFla3->GetYaxis()->SetTitle("Entries/bin");
	
  hNHitperFla2D = tfs->make<TH2F>("hNHitperEvtPlane","hNHitperEvtPlane",4,0,4,205,-5,200);
  hNHitperFla2D->GetXaxis()->SetTitle("CRT plane (0=bottom, 1=FT, 2=Pipe, 3=Top))");
  hNHitperFla2D->GetYaxis()->SetTitle("N^{o} of CRTHits in event");
  hNHitperFla2D->SetOption("COLZ"); 


  hNTraperFla = tfs->make<TH1F>("hNTrackperFla","hNTrackperFla",30,-5,25);
  hNTraperFla->GetXaxis()->SetTitle("N^{o} of CRTTrack per Flash");
  hNTraperFla->GetYaxis()->SetTitle("Entries/bin");

  hTra_tl_len = tfs->make<TH2F>("hTra_tl_len","hTra_tl_len",120, 0, 1200, 120, 0, 120);
  hTra_tl_len->GetXaxis()->SetTitle("Track lenght (cm)");
  hTra_tl_len->GetYaxis()->SetTitle("Track time (ns)");
  hTra_tl_len->SetOption("COLZ"); 

  
  hZdiff = tfs->make<TH1F>("hZdiff","hZdiff",100,-500,500);
  hZdiff->GetXaxis()->SetTitle("ZTrack - ZFlash (cm)");
  hZdiff->GetYaxis()->SetTitle("Entries/bin");

  hYdiff = tfs->make<TH1F>("hYdiff","hYdiff",100,-500,500);
  hYdiff->GetXaxis()->SetTitle("YTrack - YFlash (cm)");
  hYdiff->GetYaxis()->SetTitle("Entries/bin");
    */ 

  double inch =2.54; //inch in cm
  hBot = tfs->make<TH2F>("hBottom","Bottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  hBot->GetXaxis()->SetTitle("Length along the beam (cm)");
  hBot->GetYaxis()->SetTitle("Length along the drift (cm)");
  hBot->GetZaxis()->SetTitle("Entries/bin");
  hBot->SetOption("COLZ");

  hFT = tfs->make<TH2F>("hFeedthroughSide","Feedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
  hFT->GetXaxis()->SetTitle("Length along the beam (cm)");
  hFT->GetYaxis()->SetTitle("Height (cm)");
  hFT->GetZaxis()->SetTitle("Entries/bin");
  hFT->SetOption("COLZ");

  hPipe = tfs->make<TH2F>("hPipeSide","Pipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  hPipe->GetXaxis()->SetTitle("Length along the beam (cm)");
  hPipe->GetYaxis()->SetTitle("Height (cm)");
  hPipe->GetZaxis()->SetTitle("Entries/bin");
  hPipe->SetOption("COLZ");

  hTop = tfs->make<TH2F>("hTop","Top",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
  hTop->GetXaxis()->SetTitle("Length along the beam (cm)");
  hTop->GetYaxis()->SetTitle("Length along the drift (cm)"); 
  hTop->GetZaxis()->SetTitle("Entries/bin"); 
  hTop->SetOption("COLZ");

  /*

  hTFvsTT = tfs->make<TH1F>("hTFvsTT","hTFvsTT",1000000,0,10000000);//1ms max
  hTFvsTT->GetXaxis()->SetTitle("Track time - Flash time (ns)");
  hTFvsTT->GetYaxis()->SetTitle("Entries/bin");

  hMulFT = tfs->make<TH1F>("hMulFT","hMulFT",50,0,50);//
  hMulFT->GetXaxis()->SetTitle("Multiplicity (Tracks per Flash)");
  hMulFT->GetYaxis()->SetTitle("Entries/bin");


  hMulFTvsTdis = tfs->make<TH2F>("hMulFTvsTdis","hMulFTvsTdis",50,0,50,1000000,0,10000000);
  hMulFTvsTdis->GetXaxis()->SetTitle("Multiplicity (Tracks per Flash)");
  hMulFTvsTdis->GetYaxis()->SetTitle("Track time - Flash time (ns)");
  hMulFTvsTdis->GetZaxis()->SetTitle("Entries/bin");
  hMulFTvsTdis->SetOption("COLZ");
  */
}

void T0recoCRTHitAna2::endJob()
{
  // Implementation of optional member function here.
  
  
  /*	  
  //OLD
  //uint32_t Hit_sec = hitlist[ah]->ts0_s;
  //uint32_t Flash_sec = evt_timeGPS_sec;
  
  uint32_t Hit_nsec = hitlist[ah]->ts1_ns + fHardDelay_;
  //uint32_t Flash_nsec = Timeflash * 1000;
  
  int dif_sec = Flash_sec - Hit_sec;
  int dif_nsec = Flash_nsec - Hit_nsec;
  int dif_secABS = std::abs(dif_sec);
  int dif_nsecABS = std::abs(dif_nsec);
  //OLD
  
  if( (dif_secABS<3)  &&  (dif_nsecABS<1000 )  ){//E
  
  hTFvsTH->Fill(dif_nsec);
  hTFvsTH_2d->Fill(dif_sec , dif_nsecABS);
  
  hTFvsTH_t0->Fill(Timeflash_ns_GPS - hitlist[ah]->ts0_ns);
  hTFvsTH_t0_2d->Fill(Timeflash_ns_GPS - hitlist[ah]->ts0_ns, dif_nsec);
  hTFvsTH_t0_plane->Fill(hitlist[ah]->plane, Timeflash_ns_GPS - hitlist[ah]->ts0_ns);
  
  if(fverbose==1){
  std::cout<<"Flash_sec - Hit_sec: "<<Flash_sec - Hit_sec<<std::endl;
  std::cout<<"Flash_nsec - Hit_nsec: "<<Flash_nsec - Hit_nsec<<std::endl;
  std::cout<<"Flash_nsec - Hit_nsec: "<<dif_secABS<<std::endl;
  getchar();
  }
  
  }//E
  //OLD
  
  */
  
  
}

DEFINE_ART_MODULE(T0recoCRTHitAna2)


