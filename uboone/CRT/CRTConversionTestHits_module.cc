////////////////////////////////////////////////////////////////////////
// Class:       CRTConversionTestHits
// Module Type: producer
// File:        CRTConversionTestHits_module.cc
//
// Generated at Fri Nov  3 06:04:25 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "bernfebdaq-core/Overlays/BernZMQFragment.hh"
#include "bernfebdaq-core/Overlays/FragmentType.hh"
#include "artdaq-core/Data/Fragment.hh"

#include "art/Framework/Services/Optional/TFileService.h"

#include <string>
#include <memory>
#include <initializer_list>

// ROOT includes                                                                                                                                                
#include "TTree.h"
#include "TFile.h"
#include <stdint.h>

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <memory>

namespace crt {
  class CRTConversionTestHits;
}

class crt::CRTConversionTestHits : public art::EDProducer {
public:
  explicit CRTConversionTestHits(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTConversionTestHits(CRTConversionTestHits const &) = delete;
  CRTConversionTestHits(CRTConversionTestHits &&) = delete;
  CRTConversionTestHits & operator = (CRTConversionTestHits const &) = delete;
  CRTConversionTestHits & operator = (CRTConversionTestHits &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  // Declare member data here.
  std::string fInputFile_;      ///< File containing crt trees                                                                                                
  // std::string fOutputFile_; ///< output file name                                                                                                            
  std::string fTreeName_;       ///< Name of the TTree in the input file                                                       
  int verbose_;

  //stuff                                                                                                                                                       
  uint32_t counter_sec     = 0;
  uint32_t counter_msec    = 0;

  uint32_t counter_evt     = 0;

  uint32_t total_sec       = 0;
  uint32_t total_events    = 0;

  UInt_t min_sec = INT32_MAX;
  UInt_t max_sec = 1;

  
  std::map<std::pair<UInt_t,UInt_t>, crt::CRTHit> CRTHitCol_map;
  
  //stuff   
};


crt::CRTConversionTestHits::CRTConversionTestHits(fhicl::ParameterSet const & p)
 :
// Initialize member data here.
//feb_ids_(p.get<std::vector<int> >("feb_ids")),
  verbose_(p.get<int>("verbose"))
{
  // Call appropriate produces<>() functions here.
  produces< std::vector<crt::CRTHit>   >();
  
  fInputFile_ = p.get<std::string>("InputFileName");
  //fOutputFile_ = p.get<std::string>("OutputFileName");
  fTreeName_ = p.get<std::string>("TreeName");
}

void crt::CRTConversionTestHits::beginJob()
{
  // Implementation of optional member function here.
  
  // get the input file and the tree from it                                                                                                                    
  std::unique_ptr<TFile> tf(new TFile(fInputFile_.c_str()));
  tf->ls();
  
  TTree *tr = dynamic_cast<TTree*>(tf->Get(fTreeName_.c_str()));
  
  //std::vector<uint8_t> feb_id;
  int16_t adc_1[32];
  int16_t adc_2[32];
  UInt_t ts0_s = 0;
  UShort_t ts0_s_err = 0;
  UInt_t ts0_ns = 0;
  UShort_t ts0_ns_err = 0;
  Int_t ts1_ns = 0;
  UShort_t ts1_ns_err = 0;
  int plane = -1;
  double x_pos = -9999;
  double x_err = -9999;
  double y_pos = -9999;
  double y_err = -9999;
  double z_pos = -9999;
  double z_err = -9999;

  
  // Set the branch addresses                                                                                                                                                
  // tr->SetBranchAddress("feb_id",           &feb_id);
  tr->SetBranchAddress("adc_1",           &adc_1);
  tr->SetBranchAddress("adc_2",           &adc_2);
  tr->SetBranchAddress("ts0_s",           &ts0_s);
  tr->SetBranchAddress("ts0_s_err",           &ts0_s_err);
  tr->SetBranchAddress("ts0_ns",           &ts0_ns);
  tr->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
  tr->SetBranchAddress("ts1_ns",           &ts1_ns);
  tr->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
  tr->SetBranchAddress("plane",           &plane);
  tr->SetBranchAddress("x_pos",           &x_pos);
  tr->SetBranchAddress("x_err",           &x_err);
  tr->SetBranchAddress("y_pos",           &y_pos);
  tr->SetBranchAddress("y_err",           &y_err);
  tr->SetBranchAddress("z_pos",           &z_pos);
  tr->SetBranchAddress("z_err",           &z_err);

  int nentries= tr->GetEntries();
  std::cout<<"Entries in Tree: "<<nentries<<std::endl;
  for (Long64_t i=0;i<nentries;i++) {
    //   for (Long64_t i=50000;i<100000;i++) {
    tr->GetEntry(i);
    
    if((ts0_s!=0) && (ts0_s<min_sec) ) min_sec = ts0_s;
    if((ts0_s!=0) && (ts0_s>max_sec) ) max_sec = ts0_s;
    

    //---New

    crt::CRTHit CRTHitevent;
    //CRTHitevent.feb_id = feb_id;                                                                                                                   
    //CRTHitevent.pesmap = pesmap;//define                                                                                                           
    //CRTHitevent.peshit = peshit;//define                                                                                                           
    CRTHitevent.ts0_s = ts0_s;
    CRTHitevent.ts0_s_err = ts0_s_err;		\
    
    CRTHitevent.ts0_ns = ts0_ns;
    CRTHitevent.ts0_ns_err = ts0_ns_err;	\
    
    CRTHitevent.ts1_ns = ts1_ns;
    CRTHitevent.ts1_ns_err = ts1_ns_err;
    CRTHitevent.plane = plane;
    CRTHitevent.x_pos = x_pos;
    CRTHitevent.x_err = x_err;
    CRTHitevent.y_pos = y_pos;
    CRTHitevent.y_err = y_err;
    CRTHitevent.z_pos = z_pos;
    CRTHitevent.z_err = z_err;
    
    std::pair<UInt_t,UInt_t> timepair;
    timepair = std::make_pair(ts0_s,ts0_ns);
    CRTHitCol_map[timepair]=CRTHitevent;
    
    //New----
    // if(CRTHitevent.ts1_ns<0){
    //std::cout<<"CRTHitevent.ts1_ns: "<<CRTHitevent.ts1_ns<<std::endl;
    //getchar();
    //}

  }
  
  //  min_sec =  1496553014;
  //max_sec =  1496553135;
  min_sec =  min_sec+1;
  

  total_sec = max_sec - min_sec; //numero maximo de segundos del run                                                                                            
  total_events = total_sec * 200; //numero maximo de eventos es 200 veces el numero de segundos, donde cada evento son 5ms                                      
  
  if(verbose_==1){
    std::cout<<"Min sec in run: "<<min_sec<<std::endl;
    std::cout<<"Max sec in run: "<<max_sec<<std::endl;
    std::cout<<"Total sec in run: "<<total_sec<<std::endl;
    std::cout<<"Total events in run: "<<total_events<<std::endl;
    //    getchar();
  }
  
}


void crt::CRTConversionTestHits::produce(art::Event & evt)
{
  // Implementation of required member function here.
  
  if ( (counter_evt==total_events) || (counter_evt>total_events)  ){
    return;
  }
  if(counter_evt<total_events){//A-1                                                                                                                               
    
    //un evento son 5 ms, y luego incremento el contador de eventos y de ms. si el de ms == 200, aumento el de segundos.                                              
    // 5ms per event.                                                                                                                                                 
    UInt_t this_sec = min_sec + counter_sec ;
    UInt_t this_msec_min = counter_msec * 5e6;
    UInt_t this_msec_max = counter_msec * 5e6 + 5e6;
    if(verbose_==1){
      std::cout<<"Generating event: "<<counter_evt<<std::endl;
      std::cout<<"this_sec: "<<this_sec<<std::endl;
      std::cout<<"this_msec_min: "<<this_msec_min<<std::endl;
      std::cout<<"this_msec_max: "<<this_msec_max<<std::endl;
    }
    std::unique_ptr<std::vector<crt::CRTHit> > CRTHiteventCol(new std::vector<crt::CRTHit>); //collection of CRTHits for these 5ms  
    
    // get the input file and the tree from it                                                                                                              
    /*    
	  std::unique_ptr<TFile> tf(new TFile(fInputFile_.c_str()));
	  tf->ls();
	  
	  TTree *tr = dynamic_cast<TTree*>(tf->Get(fTreeName_.c_str()));
	  
	  //std::vector<uint8_t> feb_id;
	  int16_t adc_1[32];
	  int16_t adc_2[32];
	  UInt_t ts0_s = 0;
	  UShort_t ts0_s_err = 0;
	  UInt_t ts0_ns = 0;
	  UShort_t ts0_ns_err = 0;
	  UInt_t ts1_ns = 0;
	  UShort_t ts1_ns_err = 0;
	  int plane = -1;
	  double x_pos = -9999;
	  double x_err = -9999;
	  double y_pos = -9999;
	  double y_err = -9999;
	  double z_pos = -9999;
	  double z_err = -9999;
	  //    tr->SetBranchAddress("feb_id",           &feb_id);
	  tr->SetBranchAddress("adc_1",           &adc_1);
	  tr->SetBranchAddress("adc_2",           &adc_2);
	  tr->SetBranchAddress("ts0_s",           &ts0_s);
	  tr->SetBranchAddress("ts0_s_err",           &ts0_s_err);
	  tr->SetBranchAddress("ts0_ns",           &ts0_ns);
	  tr->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
	  tr->SetBranchAddress("ts1_ns",           &ts1_ns);
	  tr->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
	  tr->SetBranchAddress("plane",           &plane);
	  tr->SetBranchAddress("x_pos",           &x_pos);
	  tr->SetBranchAddress("x_err",           &x_err);
	  tr->SetBranchAddress("y_pos",           &y_pos);
	  tr->SetBranchAddress("y_err",           &y_err);
	  tr->SetBranchAddress("z_pos",           &z_pos);
	  tr->SetBranchAddress("z_err",           &z_err);
	  
	  int cHits=0;
	  int nentries= tr->GetEntries();
	  if(verbose_==1) {
	  std::cout<<"Entries in Tree: "<<nentries<<std::endl;
	  std::cout<<"Running event: "<<counter_evt<<std::endl;
	  }
	  for (Long64_t i=0;i<nentries;i++) {//B
	  //for (Long64_t i=50000;i<100000;i++) {                                                                                                     
	  tr->GetEntry(i);
	      
	  std::cout<<"ts0_s: "<<ts0_s<<std::endl;      
	  std::cout<<"ts0_ns: "<<ts0_ns<<std::endl;    
	  std::cout<<"plane: "<<plane<<std::endl;      
	  std::cout<<"x_pos: "<<x_pos<<std::endl;        
	  getchar();
    */

    //--NEW
    int cHits=0;
    for(auto itA = begin(CRTHitCol_map); itA != end(CRTHitCol_map); ++itA){//B

      //  std::pair<UInt_t,UInt_t> timepair = (*itA).first;
      crt::CRTHit CRTHitevent = (*itA).second;
      // std::map<std::pair<UInt_t,UInt_t>, crt::CRTHit> CRTHitCol_map;
      //----NEW
      
      if( (CRTHitevent.ts0_s == this_sec) && (CRTHitevent.ts0_ns>this_msec_min)  && (CRTHitevent.ts0_ns<this_msec_max) ){//C

      /*
       if( (ts0_s == this_sec) && (ts0_ns>this_msec_min)  && (ts0_ns<this_msec_max) ){//C
       crt::CRTHit CRTHitevent; 
       //CRTHitevent.feb_id = feb_id;
       //CRTHitevent.pesmap = pesmap;//define
       //CRTHitevent.peshit = peshit;//define
       CRTHitevent.ts0_s = ts0_s;                                                                                                                    
       CRTHitevent.ts0_s_err = ts0_s_err;                                                                                                             
       CRTHitevent.ts0_ns = ts0_ns;                                                                                                                   
       CRTHitevent.ts0_ns_err = ts0_ns_err;                                                                                                            
       CRTHitevent.ts1_ns = ts1_ns;                                                                                   
       CRTHitevent.ts1_ns_err = ts1_ns_err;                                                                                   
       CRTHitevent.plane = plane;
       CRTHitevent.x_pos = x_pos;
       CRTHitevent.x_err = x_err;
       CRTHitevent.y_pos = y_pos;
       CRTHitevent.y_err = y_err;
       CRTHitevent.z_pos = z_pos;
       CRTHitevent.z_err = z_err;
      */	
	
	CRTHiteventCol->emplace_back(CRTHitevent);
	cHits++;
      }//C
      
    }//B
    
    
    evt.put(std::move(CRTHiteventCol));

    if(verbose_==1){
      std::cout<<"CRTHits in this event: "<<cHits<<std::endl;
    }
    //increase counters, for next event.                                                                                                                    
    counter_msec++;
    
    if(counter_msec==200){//D 
      counter_msec=0;
      counter_sec++;
    }//D                                                                                                                                                                 
    
    counter_evt++;
    //incrementar los contadores       
    
  }//A-1
 

  if(verbose_==1){
    std::cout<<"next event"<<std::endl;
    //getchar();
  }
}



 void crt::CRTConversionTestHits::endJob()
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(crt::CRTConversionTestHits)
