////////////////////////////////////////////////////////////////////////
// Class:       mergeCRTHits
// Module Type: producer
// File:        mergeCRTHits_module.cc
//
// Generated at Mon Nov 13 10:08:43 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "art/Framework/Services/Optional/TFileService.h"

#include <string>
#include <memory>
#include <initializer_list>

// ROOT includes                                                                                                                                                  
#include "TTree.h"
#include "TFile.h"
#include <stdint.h>

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"
#include "uboone/RawData/utils/DAQHeaderTimeUBooNE.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>

namespace crt {
  class mergeCRTHits;
}

class crt::mergeCRTHits : public art::EDProducer {
public:
  explicit mergeCRTHits(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  mergeCRTHits(mergeCRTHits const &) = delete;
  mergeCRTHits(mergeCRTHits &&) = delete;
  mergeCRTHits & operator = (mergeCRTHits const &) = delete;
  mergeCRTHits & operator = (mergeCRTHits &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  // Declare member data here.
  std::string fInputFile1_;      ///< File containing crt trees 
  std::string fInputFile2_;      ///< File containing crt trees 
  std::string fInputFile3_;      ///< File containing crt trees 
  std::string fInputFile4_;      ///< File containing crt trees 
  std::string fInputFile5_;      ///< File containing crt trees 
  std::string fTreeName_;       ///< Name of the TTree in the input file
  int verbose_;
  //std::string  data_label_flash_;
  std::string  data_label_DAQHeader_;
  
  uint32_t fEvtNum; //Number of current event                                                                                                                       
  uint32_t frunNum;                //Run Number taken from event                                                                                                   
  uint32_t fsubRunNum;             //Subrun Number taken from event                                                                                                 
  UInt_t min_sec = INT32_MAX;
  UInt_t max_sec = 1;  

  std::map<std::pair<UInt_t,UInt_t>, crt::CRTHit> CRTHitCol_map;


};


crt::mergeCRTHits::mergeCRTHits(fhicl::ParameterSet const & p)
 :
  // Initialize member data here.
  verbose_(p.get<int>("verbose")),
  //data_label_flash_(p.get<std::string>("data_label_flash_")),
  data_label_DAQHeader_(p.get<std::string>("data_label_DAQHeader_"))
{
  // Call appropriate produces<>() functions here.
  produces< std::vector<crt::CRTHit>   >();
  fInputFile1_ = p.get<std::string>("InputFileName1");
  fInputFile2_ = p.get<std::string>("InputFileName2");
  fInputFile3_ = p.get<std::string>("InputFileName3");
  fInputFile4_ = p.get<std::string>("InputFileName4");
  fInputFile5_ = p.get<std::string>("InputFileName5");
  fTreeName_ = p.get<std::string>("TreeName");
}

void crt::mergeCRTHits::beginJob()
{
  // Implementation of optional member function here.
  
  //std::vector<uint8_t> feb_id;                                                                                                                                 
  int16_t adc_1[32];
  int16_t adc_2[32];
  UInt_t ts0_s = 0;
  UShort_t ts0_s_err = 0;
  UInt_t ts0_ns = 0;
  UShort_t ts0_ns_err = 0;
  Int_t ts1_ns = 0;
  UShort_t ts1_ns_err = 0;
  int plane = -1;
  double x_pos = -9999;
  double x_err = -9999;
  double y_pos = -9999;
  double y_err = -9999;
  double z_pos = -9999;
  double z_err = -9999;
  

  // get the input file and the tree from it file1                                                                                                                
  std::unique_ptr<TFile> tf1(new TFile(fInputFile1_.c_str()));
  tf1->ls();
  
  TTree *tr1 = dynamic_cast<TTree*>(tf1->Get(fTreeName_.c_str()));

  
  // Set the branch addresses                                                                                                                                                                                                                                                                                      
  // tr->SetBranchAddress("feb_id",           &feb_id);                                                                                                          
  tr1->SetBranchAddress("adc_1",           &adc_1);
  tr1->SetBranchAddress("adc_2",           &adc_2);
  tr1->SetBranchAddress("ts0_s",           &ts0_s);
  tr1->SetBranchAddress("ts0_s_err",           &ts0_s_err);
  tr1->SetBranchAddress("ts0_ns",           &ts0_ns);
  tr1->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
  tr1->SetBranchAddress("ts1_ns",           &ts1_ns);
  tr1->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
  tr1->SetBranchAddress("plane",           &plane);
  tr1->SetBranchAddress("x_pos",           &x_pos);
  tr1->SetBranchAddress("x_err",           &x_err);
  tr1->SetBranchAddress("y_pos",           &y_pos);
  tr1->SetBranchAddress("y_err",           &y_err);
  tr1->SetBranchAddress("z_pos",           &z_pos);
  tr1->SetBranchAddress("z_err",           &z_err);


  int nentries= tr1->GetEntries();
  std::cout<<"Entries in Tree1: "<<nentries<<std::endl;
  for (Long64_t i=0;i<nentries;i++) {
    
    tr1->GetEntry(i);
  
    if((ts0_s!=0) && (ts0_s<min_sec) ) min_sec = ts0_s;
    if((ts0_s!=0) && (ts0_s>max_sec) ) max_sec = ts0_s;
  
    crt::CRTHit CRTHitevent;
    //CRTHitevent.feb_id = feb_id;                                                                                                           
    //CRTHitevent.pesmap = pesmap;//define                                                                                                      
    //CRTHitevent.peshit = peshit;//define                                                                                                      
    CRTHitevent.ts0_s = ts0_s;
    CRTHitevent.ts0_s_err = ts0_s_err;
    CRTHitevent.ts0_ns = ts0_ns;
    CRTHitevent.ts0_ns_err = ts0_ns_err;   
    CRTHitevent.ts1_ns = ts1_ns;
    CRTHitevent.ts1_ns_err = ts1_ns_err;
    CRTHitevent.plane = plane;
    CRTHitevent.x_pos = x_pos;
    CRTHitevent.x_err = x_err;
    CRTHitevent.y_pos = y_pos;
    CRTHitevent.y_err = y_err;
    CRTHitevent.z_pos = z_pos;
    CRTHitevent.z_err = z_err;

    std::pair<UInt_t,UInt_t> timepair;
    timepair = std::make_pair(ts0_s,ts0_ns);
    CRTHitCol_map[timepair]=CRTHitevent;

  }
 

  if(verbose_==1){
    std::cout<<"Min sec in file1: "<<min_sec<<std::endl;
    std::cout<<"Max sec in file1: "<<max_sec<<std::endl;
    //getchar();                                                                                                                                                 
  }
  //File 1


  // get the input file and the tree from it file2                                                                                                                  
  std::unique_ptr<TFile> tf2(new TFile(fInputFile2_.c_str()));
  tf2->ls();
  
  TTree *tr2 = dynamic_cast<TTree*>(tf2->Get(fTreeName_.c_str()));

  // Set the branch addresses                                                                                                                                                                                                                               
  // tr->SetBranchAddress("feb_id",           &feb_id);                                                                                                          
  tr2->SetBranchAddress("adc_1",           &adc_1);
  tr2->SetBranchAddress("adc_2",           &adc_2);
  tr2->SetBranchAddress("ts0_s",           &ts0_s);
  tr2->SetBranchAddress("ts0_s_err",           &ts0_s_err);
  tr2->SetBranchAddress("ts0_ns",           &ts0_ns);
  tr2->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
  tr2->SetBranchAddress("ts1_ns",           &ts1_ns);
  tr2->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
  tr2->SetBranchAddress("plane",           &plane);
  tr2->SetBranchAddress("x_pos",           &x_pos);
  tr2->SetBranchAddress("x_err",           &x_err);
  tr2->SetBranchAddress("y_pos",           &y_pos);
  tr2->SetBranchAddress("y_err",           &y_err);
  tr2->SetBranchAddress("z_pos",           &z_pos);
  tr2->SetBranchAddress("z_err",           &z_err);


  nentries= tr2->GetEntries();
  std::cout<<"Entries in file 2: "<<nentries<<std::endl;
  for (Long64_t i=0;i<nentries;i++) {
    
    tr2->GetEntry(i);
  
    if((ts0_s!=0) && (ts0_s<min_sec) ) min_sec = ts0_s;
    if((ts0_s!=0) && (ts0_s>max_sec) ) max_sec = ts0_s;
  
    crt::CRTHit CRTHitevent;
    //CRTHitevent.feb_id = feb_id;                                                                                                           
    //CRTHitevent.pesmap = pesmap;//define                                                                                                      
    //CRTHitevent.peshit = peshit;//define                                                                                                      
    CRTHitevent.ts0_s = ts0_s;
    CRTHitevent.ts0_s_err = ts0_s_err;
    CRTHitevent.ts0_ns = ts0_ns;
    CRTHitevent.ts0_ns_err = ts0_ns_err;   
    CRTHitevent.ts1_ns = ts1_ns;
    CRTHitevent.ts1_ns_err = ts1_ns_err;
    CRTHitevent.plane = plane;
    CRTHitevent.x_pos = x_pos;
    CRTHitevent.x_err = x_err;
    CRTHitevent.y_pos = y_pos;
    CRTHitevent.y_err = y_err;
    CRTHitevent.z_pos = z_pos;
    CRTHitevent.z_err = z_err;

    std::pair<UInt_t,UInt_t> timepair;
    timepair = std::make_pair(ts0_s,ts0_ns);
    CRTHitCol_map[timepair]=CRTHitevent;

  }

  if(verbose_==1){
    std::cout<<"Min sec in file2: "<<min_sec<<std::endl;
    std::cout<<"Max sec in file2: "<<max_sec<<std::endl;
    //getchar();                                                                                                                                                 
  }
  //File 2

  //File 3

  // get the input file and the tree from it file2                                                                                                                  
  std::unique_ptr<TFile> tf3(new TFile(fInputFile3_.c_str()));
  tf3->ls();
  
  TTree *tr3 = dynamic_cast<TTree*>(tf3->Get(fTreeName_.c_str()));
  
  // Set the branch addresses                                                                                                                                                                                                                               
  // tr->SetBranchAddress("feb_id",           &feb_id);                                                                                                          
  tr3->SetBranchAddress("adc_1",           &adc_1);
  tr3->SetBranchAddress("adc_2",           &adc_2);
  tr3->SetBranchAddress("ts0_s",           &ts0_s);
  tr3->SetBranchAddress("ts0_s_err",           &ts0_s_err);
  tr3->SetBranchAddress("ts0_ns",           &ts0_ns);
  tr3->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
  tr3->SetBranchAddress("ts1_ns",           &ts1_ns);
  tr3->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
  tr3->SetBranchAddress("plane",           &plane);
  tr3->SetBranchAddress("x_pos",           &x_pos);
  tr3->SetBranchAddress("x_err",           &x_err);
  tr3->SetBranchAddress("y_pos",           &y_pos);
  tr3->SetBranchAddress("y_err",           &y_err);
  tr3->SetBranchAddress("z_pos",           &z_pos);
  tr3->SetBranchAddress("z_err",           &z_err);


  nentries= tr3->GetEntries();
  std::cout<<"Entries in file 3: "<<nentries<<std::endl;
  for (Long64_t i=0;i<nentries;i++) {
    
    tr2->GetEntry(i);
  
    if((ts0_s!=0) && (ts0_s<min_sec) ) min_sec = ts0_s;
    if((ts0_s!=0) && (ts0_s>max_sec) ) max_sec = ts0_s;
  
    crt::CRTHit CRTHitevent;
    //CRTHitevent.feb_id = feb_id;                                                                                                           
    //CRTHitevent.pesmap = pesmap;//define                                                                                                      
    //CRTHitevent.peshit = peshit;//define                                                                                                      
    CRTHitevent.ts0_s = ts0_s;
    CRTHitevent.ts0_s_err = ts0_s_err;
    CRTHitevent.ts0_ns = ts0_ns;
    CRTHitevent.ts0_ns_err = ts0_ns_err;   
    CRTHitevent.ts1_ns = ts1_ns;
    CRTHitevent.ts1_ns_err = ts1_ns_err;
    CRTHitevent.plane = plane;
    CRTHitevent.x_pos = x_pos;
    CRTHitevent.x_err = x_err;
    CRTHitevent.y_pos = y_pos;
    CRTHitevent.y_err = y_err;
    CRTHitevent.z_pos = z_pos;
    CRTHitevent.z_err = z_err;

    std::pair<UInt_t,UInt_t> timepair;
    timepair = std::make_pair(ts0_s,ts0_ns);
    CRTHitCol_map[timepair]=CRTHitevent;

  }

  if(verbose_==1){
    std::cout<<"Min sec in file 3: "<<min_sec<<std::endl;
    std::cout<<"Max sec in file 3: "<<max_sec<<std::endl;
    //getchar();                                                                                                                                                 
  }
  
  //File 3

  //File 4
  // get the input file and the tree from it file2                                                                                                                  
  std::unique_ptr<TFile> tf4(new TFile(fInputFile4_.c_str()));
  tf4->ls();
  
  TTree *tr4 = dynamic_cast<TTree*>(tf4->Get(fTreeName_.c_str()));

  // Set the branch addresses                                                                                                                                                                                                                               
  // tr->SetBranchAddress("feb_id",           &feb_id);                                                                                                          
  tr4->SetBranchAddress("adc_1",           &adc_1);
  tr4->SetBranchAddress("adc_2",           &adc_2);
  tr4->SetBranchAddress("ts0_s",           &ts0_s);
  tr4->SetBranchAddress("ts0_s_err",           &ts0_s_err);
  tr4->SetBranchAddress("ts0_ns",           &ts0_ns);
  tr4->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
  tr4->SetBranchAddress("ts1_ns",           &ts1_ns);
  tr4->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
  tr4->SetBranchAddress("plane",           &plane);
  tr4->SetBranchAddress("x_pos",           &x_pos);
  tr4->SetBranchAddress("x_err",           &x_err);
  tr4->SetBranchAddress("y_pos",           &y_pos);
  tr4->SetBranchAddress("y_err",           &y_err);
  tr4->SetBranchAddress("z_pos",           &z_pos);
  tr4->SetBranchAddress("z_err",           &z_err);


  nentries= tr4->GetEntries();
  std::cout<<"Entries in file 4: "<<nentries<<std::endl;
  for (Long64_t i=0;i<nentries;i++) {
    
    tr4->GetEntry(i);
    
    if((ts0_s!=0) && (ts0_s<min_sec) ) min_sec = ts0_s;
    if((ts0_s!=0) && (ts0_s>max_sec) ) max_sec = ts0_s;
    
    crt::CRTHit CRTHitevent;
    //CRTHitevent.feb_id = feb_id;                                                                                                           
    //CRTHitevent.pesmap = pesmap;//define                                                                                                      
    //CRTHitevent.peshit = peshit;//define                                                                                                      
    CRTHitevent.ts0_s = ts0_s;
    CRTHitevent.ts0_s_err = ts0_s_err;
    CRTHitevent.ts0_ns = ts0_ns;
    CRTHitevent.ts0_ns_err = ts0_ns_err;   
    CRTHitevent.ts1_ns = ts1_ns;
    CRTHitevent.ts1_ns_err = ts1_ns_err;
    CRTHitevent.plane = plane;
    CRTHitevent.x_pos = x_pos;
    CRTHitevent.x_err = x_err;
    CRTHitevent.y_pos = y_pos;
    CRTHitevent.y_err = y_err;
    CRTHitevent.z_pos = z_pos;
    CRTHitevent.z_err = z_err;

    std::pair<UInt_t,UInt_t> timepair;
    timepair = std::make_pair(ts0_s,ts0_ns);
    CRTHitCol_map[timepair]=CRTHitevent;

  }

  if(verbose_==1){
    std::cout<<"Min sec in file 4: "<<min_sec<<std::endl;
    std::cout<<"Max sec in file 4: "<<max_sec<<std::endl;
    //getchar();                                                                                                                                                 
  }
  //File 4

  //File 5
  // get the input file and the tree from it file2                                                                                                                  
  std::unique_ptr<TFile> tf5(new TFile(fInputFile5_.c_str()));
  tf5->ls();
  
  TTree *tr5 = dynamic_cast<TTree*>(tf5->Get(fTreeName_.c_str()));

  // Set the branch addresses                                                                                                                                                                                                                               
  // tr->SetBranchAddress("feb_id",           &feb_id);                                                                                                          
  tr5->SetBranchAddress("adc_1",           &adc_1);
  tr5->SetBranchAddress("adc_2",           &adc_2);
  tr5->SetBranchAddress("ts0_s",           &ts0_s);
  tr5->SetBranchAddress("ts0_s_err",           &ts0_s_err);
  tr5->SetBranchAddress("ts0_ns",           &ts0_ns);
  tr5->SetBranchAddress("ts0_ns_err",           &ts0_ns_err);
  tr5->SetBranchAddress("ts1_ns",           &ts1_ns);
  tr5->SetBranchAddress("ts1_ns_err",           &ts1_ns_err);
  tr5->SetBranchAddress("plane",           &plane);
  tr5->SetBranchAddress("x_pos",           &x_pos);
  tr5->SetBranchAddress("x_err",           &x_err);
  tr5->SetBranchAddress("y_pos",           &y_pos);
  tr5->SetBranchAddress("y_err",           &y_err);
  tr5->SetBranchAddress("z_pos",           &z_pos);
  tr5->SetBranchAddress("z_err",           &z_err);


  nentries= tr5->GetEntries();
  std::cout<<"Entries in file 5: "<<nentries<<std::endl;
  for (Long64_t i=0;i<nentries;i++) {
    
    tr5->GetEntry(i);
  
    if((ts0_s!=0) && (ts0_s<min_sec) ) min_sec = ts0_s;
    if((ts0_s!=0) && (ts0_s>max_sec) ) max_sec = ts0_s;
  
    crt::CRTHit CRTHitevent;
    //CRTHitevent.feb_id = feb_id;                                                                                                           
    //CRTHitevent.pesmap = pesmap;//define                                                                                                      
    //CRTHitevent.peshit = peshit;//define                                                                                                      
    CRTHitevent.ts0_s = ts0_s;
    CRTHitevent.ts0_s_err = ts0_s_err;
    CRTHitevent.ts0_ns = ts0_ns;
    CRTHitevent.ts0_ns_err = ts0_ns_err;   
    CRTHitevent.ts1_ns = ts1_ns;
    CRTHitevent.ts1_ns_err = ts1_ns_err;
    CRTHitevent.plane = plane;
    CRTHitevent.x_pos = x_pos;
    CRTHitevent.x_err = x_err;
    CRTHitevent.y_pos = y_pos;
    CRTHitevent.y_err = y_err;
    CRTHitevent.z_pos = z_pos;
    CRTHitevent.z_err = z_err;

    std::pair<UInt_t,UInt_t> timepair;
    timepair = std::make_pair(ts0_s,ts0_ns);
    CRTHitCol_map[timepair]=CRTHitevent;

  }

  if(verbose_==1){
    std::cout<<"Min sec in file5: "<<min_sec<<std::endl;
    std::cout<<"Max sec in file5: "<<max_sec<<std::endl;
    //getchar();                                                                                                                                                 
  }
  //File 5

}


void crt::mergeCRTHits::produce(art::Event & evt)
{
  // Implementation of required member function here.
  
  //get DAQ Header                                                                                                                                                  
  art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;
  evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);
  
  //check to make sure the data we asked for is valid                                                                                                              
  if(!rawHandle_DAQHeader.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;
    return;
  }
  
  raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);
  
  art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();
  double evt_timeGPS_sec = evtTimeGPS.timeHigh();
  // double evt_timeGPS_nsec = evtTimeGPS.timeLow();
  
  if(verbose_==1){
    std::cout.precision(19);
    std::cout<<"Event time:: "<<evt_timeGPS_sec<<std::endl;
  }
  
  std::unique_ptr<std::vector<crt::CRTHit> > CRTHiteventCol(new std::vector<crt::CRTHit>); //collection of CRTHits for this event
  
  int cHits=0;
  for(auto itA = begin(CRTHitCol_map); itA != end(CRTHitCol_map); ++itA){//A

    crt::CRTHit CRTHitevent = (*itA).second;
    
    if( std::abs(CRTHitevent.ts0_s - evt_timeGPS_sec)<5 ){//B
      
      CRTHiteventCol->emplace_back(CRTHitevent);
      cHits++;
      
      if(verbose_==1){
	std::cout<<"Adding CRTHit from second:: "<<CRTHitevent.ts0_s<<std::endl;
      }


    }//B
    
  }//A
  
  evt.put(std::move(CRTHiteventCol));
  
  if(verbose_==1){
    std::cout<<"CRTHits in this event: "<<cHits<<std::endl;
    getchar();
  }
  
}


void crt::mergeCRTHits::endJob()
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(crt::mergeCRTHits)
