////////////////////////////////////////////////////////////////////////
// Class:       MergeTest
// Module Type: analyzer
// File:        MergeTest_module.cc
//
// Generated at Mon Jul  3 03:51:03 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardata/Utilities/AssociationUtil.h"

//#include "bernfebdaq-core/Overlays/BernZMQFragment.hh"
#include "artdaq-core/Data/Fragments.hh"

#include "art/Framework/Services/Optional/TFileService.h"

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"
#include "uboone/RawData/utils/DAQHeaderTimeUBooNE.h"

#include "TTree.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <typeinfo>


namespace crt {
  class MergeTest;
}

class crt::MergeTest : public art::EDAnalyzer {
public:
  explicit MergeTest(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MergeTest(MergeTest const &) = delete;
  MergeTest(MergeTest &&) = delete;
  MergeTest & operator = (MergeTest const &) = delete;
  MergeTest & operator = (MergeTest &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  art::ServiceHandle<art::TFileService> tfs;
  // Declare member data here.
  
  uint32_t fEvtNum; //Number of current event                       
  uint32_t frunNum;                //Run Number taken from event  
  uint32_t fsubRunNum;             //Subrun Number taken from event         
  //  std::string  data_labeltrack_;
  std::string  data_labelhit_;
  std::string  data_label_flash_;
  std::string  data_label_DAQHeader_;
  int fHardDelay_;
  int verbose_;
  // int diff_tra_flaMAX_;


  //art::InputTag opFlashTag("opflashSat");
  
  //TTree*       fTree;
  TH1F* hFlashTimeDis;
  TH1F* hTFvsTH;
  TH2F* hTFvsTH_2d;
  TH2F* hNFlavsNHit;

  //TH1F* hYdiff;
  //TH1F* hZdiff;

  //TH1F* hTFvsTT;
  //TH1F* hMulFT;
  //TH2F* hMulFTvsTdis;

  

  /* //for Tree
  uint32_t fTriTim_sec;
  uint32_t fTriTim_nsec;
  double fY;
  double fZ;
  double fTimFla;
  double fAbsTimFla;
  
  //for Tree*/

  
};


crt::MergeTest::MergeTest(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
    //  data_labeltrack_(p.get<std::string>("data_labeltrack")),
    data_labelhit_(p.get<std::string>("data_labelhit")),
    data_label_flash_(p.get<std::string>("data_label_flash_")),
    data_label_DAQHeader_(p.get<std::string>("data_label_DAQHeader_")),
    fHardDelay_(p.get<int>("fHardDelay",40000)),
    verbose_(p.get<int>("verbose"))
    // More initializers here.
{
}

void crt::MergeTest::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  
  frunNum    = evt.run();
  fsubRunNum = evt.subRun();
  fEvtNum = evt.event();
  
  art::Timestamp evtTime = evt.time();
  auto evt_time_sec = evtTime.timeHigh();
  auto evt_time_nsec = evtTime.timeLow();

  double  evt_timeGPS_sec = evt_time_sec;
  double  evt_timeGPS_nsec = evt_time_nsec;
  /*
  //get DAQ Header                                                                                                                                                       
   //Commentar para old swizzler, sin DAQ Header
  art::Handle< raw::DAQHeaderTimeUBooNE > rawHandle_DAQHeader;                                                                                                            
  evt.getByLabel(data_label_DAQHeader_, rawHandle_DAQHeader);                                                                                                               
  
  //check to make sure the data we asked for is valid                                                                                                               
  if(!rawHandle_DAQHeader.isValid()){                                                                                                                                        std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()														   << ", event " << evt.event() << " has zero"											  					       << " DAQHeaderTimeUBooNE  " << " in with label " << data_label_DAQHeader_ << std::endl;  
    return;               
  }                                                                                                                                                                  
  
  raw::DAQHeaderTimeUBooNE const& my_DAQHeader(*rawHandle_DAQHeader);                                                                                                     
  
  art::Timestamp evtTimeGPS = my_DAQHeader.gps_time();                                                                                                                    
  double evt_timeGPS_sec = evtTimeGPS.timeHigh();                                                                                                                         
  double evt_timeGPS_nsec = evtTimeGPS.timeLow();                                                                                                                         
  //fTriTim_sec = evtTimeGPS.timeHigh();                                                                                                                               
  //fTriTim_nsec = evtTimeGPS.timeLow();                                                                                                                                     
  
  art::Timestamp evtTimeNTP = my_DAQHeader.ntp_time();                                                                                                                     
  double evt_timeNTP_sec = evtTimeNTP.timeHigh();                                                                                                                         
  double evt_timeNTP_nsec = evtTimeNTP.timeLow();                                                                                                                                                                                                                                                                                       
  double timstp_diff = std::abs(evt_timeGPS_nsec - evt_timeNTP_nsec);                                                                                                      

  if(verbose_==1){                                                                                                                                                        
    std::cout<< "Run:  "<<frunNum << "   subRun: " <<fsubRunNum<<std::endl;
    std::cout<<"event: "<<fEvtNum <<std::endl;    
    std::cout.precision(19);    
    std::cout<<"  GPS time second:  "<<evt_timeGPS_sec<<std::endl;                                                                                                        
    std::cout<<"  GPS time nano_second:  "<<evt_timeGPS_nsec<<std::endl;                                                                                                  
    std::cout<<"  NTP time second:  "<<evt_timeNTP_sec<<std::endl;                                                                                                        
    std::cout<<"  NTP time nano_second:  "<<evt_timeNTP_nsec<<std::endl;                                                                                                  
    std::cout<<"  event time second:  "<<evt_time_sec<<std::endl;                                                                                                         
    std::cout<<"  event time nano_second:  "<<evt_time_nsec<<std::endl;                                                                                                   
    std::cout<<"  difference between GPS and NTP:  "<<evt_timeGPS_nsec - evt_timeNTP_nsec<<" ns"<<std::endl;                                                              
    std::cout<<"  ABS difference between GPS and NTP:  "<<timstp_diff<<" ns"<<std::endl;                                                                                  
    
    if( (evt_time_sec==evt_timeGPS_sec) && (evt_time_nsec==evt_timeGPS_nsec))  std::cout<<" Event time type is: GPS  "<<std::endl;                                        
    if( (evt_time_sec==evt_timeNTP_sec) && (evt_time_nsec==evt_timeNTP_nsec))  std::cout<<" Event time type is: NTP  "<<std::endl;                                                                                                                                                       
    getchar();                                                                                                                                                            
  }  
  */
  //Comentar para old swizzle sin header

  
  //get Optical Flash
  art::Handle< std::vector<recob::OpFlash> > rawHandle_OpFlash;
  evt.getByLabel(data_label_flash_, rawHandle_OpFlash);
  
  std::vector<recob::OpFlash> const& OpFlashCollection(*rawHandle_OpFlash);
  
  if(verbose_==1){ 
    std::cout<<"  OpFlashCollection.size()  "<<OpFlashCollection.size()<<std::endl; 
  }
  
  //get Optical Flash
  
  /*
  //get CRTTracks
  art::Handle< std::vector<crt::CRTTrack> > rawHandle;
  evt.getByLabel(data_label_, rawHandle); 
  
  //check to make sure the data we asked for is valid
  if(!rawHandle.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " CRTTracks " << " in module " << data_label_ << std::endl;
    std::cout << std::endl;
    return;
  }
  
  //get better access to the data    //CRTTrack collection on this event                                                
  std::vector<crt::CRTTrack> const& CRTTrackCollection(*rawHandle);
  
  if(verbose_==1){ 
    std::cout<<"  CRTTrackCollection.size()  "<<CRTTrackCollection.size()<<std::endl; 
    //getchar();   
  }
  //get CRTTracks
  */
  
  //get CRTHits
  art::Handle< std::vector<crt::CRTHit> > rawHandle_hit;
  evt.getByLabel(data_labelhit_, rawHandle_hit); //
  
  //check to make sure the data we asked for is valid
  if(!rawHandle_hit.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " CRTHits " << " in module " << data_labelhit_ << std::endl;
    std::cout << std::endl;
    return;
  }
  
  //get better access to the data    //CRTHit collection on this event                                                
  std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_hit);
  
  if(verbose_==1){ 
    std::cout<<"  CRTHitCollection.size()  "<<CRTHitCollection.size()<<std::endl; 
    getchar();   
  }
  //get CRTHits
  
  if(CRTHitCollection.size()>0){//A
    
    hNFlavsNHit->Fill(OpFlashCollection.size(),CRTHitCollection.size());
    
    for(std::vector<int>::size_type i = 0; i != OpFlashCollection.size(); i++) {//B
      
      recob::OpFlash my_OpFlash = OpFlashCollection[i];
      
      auto Yflash = my_OpFlash.YCenter();
      auto Zflash = my_OpFlash.ZCenter();
      auto PEflash = my_OpFlash.TotalPE();
      auto Timeflash = my_OpFlash.Time(); //in us from trigger time
      int fbeam = my_OpFlash.OnBeamTime();
      hFlashTimeDis->Fill(Timeflash);
      
      if(verbose_==1){ 
	std::cout<<"event: "<<fEvtNum<<std::endl;
	std::cout<<"Flash: "<<i<<std::endl;
	std::cout<<"Beam: "<<fbeam<<std::endl;
	std::cout<<"Zflash: "<<Zflash<<std::endl;
	std::cout<<"Yflash: "<<Yflash<<std::endl;
	std::cout<<"PEflash: "<<PEflash<<std::endl;
	std::cout<<"Flash time: "<<Timeflash<< "  us w.r.t to trigger"<<std::endl;
	std::cout.precision(19);
      }
      
      int flash_time_GPS_ns = evt_timeGPS_nsec + (Timeflash * 1000);  //do not trust on this
      
      if(verbose_==1){ 
	std::cout.precision(19);            
	std::cout<<"Flash["<<i<<"]::Time_us: "<<Timeflash<<"   us w.r.t. trigger time"<<std::endl;  
	std::cout<<"Flash["<<i<<"]::Time_ns: "<<Timeflash * 1000<<"   ns w.r.t. trigger time"<<std::endl;        
	std::cout<<"Flash time in GPS units: "<<flash_time_GPS_ns <<" nanoseconds DO NOT TRUST THIS INFO"<<std::endl;	  
	getchar();
      }
      
      
      if(fbeam == 0){//C solo onbeam
	
	for(std::vector<int>::size_type j = 0; j != CRTHitCollection.size(); j++) {//D
	  
	  crt::CRTHit my_CRTHit = CRTHitCollection[j];
	  
	  uint32_t Hit_sec = my_CRTHit.ts0_s;
	  uint32_t Flash_sec = evt_timeGPS_sec;
	  
	  uint32_t Hit_nsec = my_CRTHit.ts1_ns + fHardDelay_;
	  uint32_t Flash_nsec = Timeflash * 1000;
	  
	  int dif_sec = Flash_sec - Hit_sec;
	  int dif_nsec = Flash_nsec - Hit_nsec;
	  int dif_secABS = std::abs(Flash_sec - Hit_sec);
	  int dif_nsecABS = std::abs(Flash_nsec - Hit_nsec);
	  
	  //	  abs(Flash_s-Hit_s )<3  && abs(Flash_ns-Hit_ns)<1000.	  
	  //if( (std::abs(Flash_sec - Hit_sec)<3)  &&  (std::abs(Flash_nsec - Hit_nsec)<1000 )  ){//E
	  if( (dif_secABS<3)  &&  (dif_nsecABS<1000 )  ){//E
	    
	  	    
	    hTFvsTH->Fill(dif_nsec);
	    hTFvsTH_2d->Fill(dif_sec , dif_nsecABS);
	    
	    if(verbose_==1){
	      std::cout<<"Flash_sec - Hit_sec: "<<Flash_sec - Hit_sec<<std::endl;
	      std::cout<<"Flash_nsec - Hit_nsec: "<<Flash_nsec - Hit_nsec<<std::endl;
	      getchar();
	    }
	    
	    }//E
	}//D
      }//C
    }//B  
  }//A
  
  
  
}

void crt::MergeTest::beginJob()
{
  // Implementation of optional member function here.


  
  hFlashTimeDis = tfs->make<TH1F>("hFlashTimDis","hFlashTimDis",6000,-10,50);
  hFlashTimeDis->GetXaxis()->SetTitle("Flash Time w.r.t. trigger (us)");
  hFlashTimeDis->GetYaxis()->SetTitle("Entries/bin");  
  
  hTFvsTH = tfs->make<TH1F>("hTFns_THns","hTFns_THns",2000,-1000,1000);
  hTFvsTH->GetXaxis()->SetTitle("Flash Time - CRTHit Time (ns)");
  hTFvsTH->GetYaxis()->SetTitle("Entries/bin");

  hTFvsTH_2d = tfs->make<TH2F>("hTF_TH","hTF_TH",6,-3,3,1000,0,1000);
  hTFvsTH_2d->GetXaxis()->SetTitle("Flash Time - CRTHit Time (s)");
  hTFvsTH_2d->GetYaxis()->SetTitle("Flash Time - CRTHit Time (ns)");
  hTFvsTH_2d->SetOption("COLZ"); 

  hNFlavsNHit = tfs->make<TH2F>("hNFlavsNTra","hNFlavsNTra",200,0,200,200,0,200);
  hNFlavsNHit->GetXaxis()->SetTitle("Number of Flash");
  hNFlavsNHit->GetYaxis()->SetTitle("Number of CRT Hits");
  hNFlavsNHit->GetZaxis()->SetTitle("Entries/bin");
  hNFlavsNHit->SetOption("COLZ");

  /*  
  hZdiff = tfs->make<TH1F>("hZdiff","hZdiff",1200,0,12000);
  hZdiff->GetXaxis()->SetTitle("ZTrack - ZFlash (cm)");
  hZdiff->GetYaxis()->SetTitle("Entries/bin");

  hYdiff = tfs->make<TH1F>("hYdiff","hYdiff",500,0,5000);
  hYdiff->GetXaxis()->SetTitle("YTrack - YFlash (cm)");
  hYdiff->GetYaxis()->SetTitle("Entries/bin");

  hTFvsTT = tfs->make<TH1F>("hTFvsTT","hTFvsTT",1000000,0,10000000);//1ms max
  hTFvsTT->GetXaxis()->SetTitle("Track time - Flash time (ns)");
  hTFvsTT->GetYaxis()->SetTitle("Entries/bin");

  hMulFT = tfs->make<TH1F>("hMulFT","hMulFT",50,0,50);//
  hMulFT->GetXaxis()->SetTitle("Multiplicity (Tracks per Flash)");
  hMulFT->GetYaxis()->SetTitle("Entries/bin");


  hMulFTvsTdis = tfs->make<TH2F>("hMulFTvsTdis","hMulFTvsTdis",50,0,50,1000000,0,10000000);
  hMulFTvsTdis->GetXaxis()->SetTitle("Multiplicity (Tracks per Flash)");
  hMulFTvsTdis->GetYaxis()->SetTitle("Track time - Flash time (ns)");
  hMulFTvsTdis->GetZaxis()->SetTitle("Entries/bin");
  hMulFTvsTdis->SetOption("COLZ");
  */
}

void crt::MergeTest::endJob()
{
  // Implementation of optional member function here.
  

}

DEFINE_ART_MODULE(crt::MergeTest)
