////////////////////////////////////////////////////////////////////////
// Class:       CRTHitProducer
// Module Type: producer
// File:        CRTHitProducer_module.cc
// Description: Module to obtain XY (ZY, XZ) coincidences within a plane.
// Generated at Thu Apr 27 08:11:58 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "bernfebdaq-core/Overlays/BernZMQFragment.hh"
#include "artdaq-core/Data/Fragments.hh"

#include "art/Framework/Services/Optional/TFileService.h"

#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TTree.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>

#include <memory>

namespace bernfebdaq {
  class CRTHitProducer;
}

class bernfebdaq::CRTHitProducer : public art::EDProducer {
public:
  explicit CRTHitProducer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTHitProducer(CRTHitProducer const &) = delete;
  CRTHitProducer(CRTHitProducer &&) = delete;
  CRTHitProducer & operator = (CRTHitProducer const &) = delete;
  CRTHitProducer & operator = (CRTHitProducer &&) = delete;

  // Required functions.
  void produce(art::Event & evt) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  // Declare member data here.

  art::ServiceHandle<art::TFileService> tfs;
  TTree*       my_tree_;

  std::string  raw_data_label_;
  std::string  SiPMpositions_;
  std::string  FEBDelays_;
  std::string  CRTGains_;
  std::string  CRTPedestals_;
 
  double max_time_difference_ ;//= 400;//max time for coincidence                                                                                                
  double Lbar_; // = 10.8;//Width for scintillator strip
  double Lbartop_; // = 11.2;//Width for scintillator strip_top
  double Emin_;// = 100;//Energy threshold for hit     

  std::map<std::pair<int,double>, BernZMQEvent const*> HitCollection;
  
  
  std::map <int, std::vector<double> > sensor_pos; //key = FEB*100+ch
  std::map <int, double > FEBDel; //key = FEB;
  std::map<int, std::pair<double,double> > SiPMgain; //key = FEB*100+ch
  std::map<int, std::pair<double,double> > SiPMpedestal; //key = FEB*100+ch
  
  //quallity plots
  TH2F* HitDistBot;
  TH2F* HitDistFT;
  TH2F* HitDistPipe;
  TH2F* HitDistTop;

  TH1F* hxtot;
  TH1F* hytot;
  TH1F* hztot;

  TH2F* FEBvsFEB;
  TH1F* TimeDiff;
  //quallity plots




};


bernfebdaq::CRTHitProducer::CRTHitProducer(fhicl::ParameterSet const & p)
  : //EDProducer(p),
    raw_data_label_(p.get<std::string>("raw_data_label")),
    SiPMpositions_(p.get<std::string>("CRTpositions_file")),
    FEBDelays_(p.get<std::string>("FEBDelays_file")),
    CRTGains_(p.get<std::string>("CRTgains_file")),
    CRTPedestals_(p.get<std::string>("CRTpedestals_file")),
    max_time_difference_(p.get<double>("max_time_difference")),
    Lbar_(p.get<double>("Lbar")),
    Lbartop_(p.get<double>("Lbartop")),
    Emin_(p.get<double>("Emin"))//,
{
  // Call appropriate produces<>() functions here.
}

void bernfebdaq::CRTHitProducer::produce(art::Event & evt)
{
  // Implementation of required member function here.

  art::Handle< std::vector<artdaq::Fragment> > rawHandle;
  evt.getByLabel(raw_data_label_, "BernZMQ", rawHandle);
  
  //check to make sure the data we asked for is valid                                                                                                  
  if(!rawHandle.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has zero"
              << " BernFEB fragments " << " in module " << raw_data_label_ << std::endl;
    std::cout << std::endl;
    return;
  }

  //get better access to the data                                                                                                                       
  std::vector<artdaq::Fragment> const& rawFragments(*rawHandle);

  //loop over the raw data fragments                                                                                                                     
  //There should be one fragment per FEB in each event.                                                                                                  
  for(auto const& frag : rawFragments){//A
    
    //overlay this so it's in the "BernFragment" format. Same data!                                                                                      
    BernZMQFragment bfrag(frag);
    
    //Grab the metadata.                                                                                                                                 
    //See bernfebdaq-core/bernfebdaq-core/Overlays/BernFEBFragment.hh                                                                                    
    auto bfrag_metadata = bfrag.metadata();
    size_t   nevents    = bfrag_metadata->n_events();   //number of BernFEBEvents in this packet                                                         
    auto time_start_ns = bfrag_metadata->time_start_nanosec();     //last second.                                                                        
    auto time_start_seconds = bfrag_metadata->time_start_seconds();     //last second.                                                                   
    //auto time_end_ns = bfrag_metadata->time_end_nanosec();     //last second + 1s.                                                                  
    auto FEB_MAC =  bfrag_metadata->feb_id();     //mac addresss of this packet                                                                           
    auto FEB_ID = crt::auxfunctions::getFEBN(FEB_MAC); //FEB ID  
    auto feb_tevt = FEB_ID;
    double FEB_del = crt::auxfunctions::getFEBDel(FEB_ID,FEBDel); //cable_legth FEB delay in ns.         
    time_start_ns = time_start_ns + FEB_del; // time corrected by cable delay
    //time_end_ns = time_end_ns + FEB_del; //    


    for(size_t i_e=0; i_e<nevents; ++i_e){//B
      BernZMQEvent const* this_event = bfrag.eventdata(i_e); //get the single hit/event                                                                    
      auto time_ts0 = this_event->Time_TS0();         //grab the event time from last second                                                              

      double corrected_time = GetCorrectedTime(time_ts0,*bfrag_metadata);      //correct this time                                                         
      double time_tevt = time_start_seconds+(corrected_time*1e-9); ///CHECK THIS TIME!!!!!
      //double time_tevt = corrected_time; 

      std::pair<int,double> keypair_tevt;
      keypair_tevt = std::make_pair(feb_tevt,time_tevt);
      HitCollection[keypair_tevt]=this_event;


      for(auto itA = begin(HitCollection); itA != end(HitCollection); ++itA){//C

	std::pair<int,double> keypair_st = (*itA).first;
	BernZMQEvent const* event_st = (*itA).second;

	auto feb_st = keypair_st.first;
	auto time_st = keypair_st.second;

	auto time_diff = abs(time_tevt - time_st);

	if( (time_diff<max_time_difference_) && (feb_st !=  feb_tevt) ){//D //COINCIDENCE 
	  
	  std::vector<std::pair<int,double> > pes_tevt;//to be store                                                                                       

	  double max_temp1_tevt = -1;
	  unsigned int maxSipm1_tevt = -1;
	  double max_temp2_tevt = -1;
	  unsigned int maxSipm2_tevt = -1;

	  for(size_t i_chan=0; i_chan<32; ++i_chan){ //1st max                                                                                             
	    if(this_event->adc[i_chan]>max_temp1_tevt){
	      max_temp1_tevt=this_event->adc[i_chan];
	      maxSipm1_tevt=i_chan;
	    }
	  }//1st max                                                                                                                                       

	  if (maxSipm1_tevt % 2 == 0){//2nd mac                                                                                                            
	    maxSipm2_tevt = maxSipm1_tevt+1;
	  } else if(maxSipm1_tevt % 2 == 1) {
	    maxSipm2_tevt = maxSipm1_tevt-1;
	  }
	  max_temp2_tevt=this_event->adc[maxSipm2_tevt];
	  //2ndmax 
	  
	  if(maxSipm2_tevt < maxSipm1_tevt){//swap                                                                                                         
	    unsigned int temp = maxSipm1_tevt;
	    maxSipm1_tevt=maxSipm2_tevt;
	    maxSipm2_tevt=temp;
	    double maxtemp = max_temp1_tevt;
	    max_temp1_tevt = max_temp2_tevt;
	    max_temp2_tevt =maxtemp;
	  }//swap                                                                                                                                          
	  
	  int key_tevt1 = feb_tevt*100+maxSipm1_tevt;
	  int key_tevt2 = feb_tevt*100+maxSipm2_tevt;
	  
	  std::pair<double,double> gain_tevt1 = crt::auxfunctions::getGain(key_tevt1, SiPMgain);
	  std::pair<double,double> pedestal_tevt1 = crt::auxfunctions::getGain(key_tevt1, SiPMpedestal);
	  double pesmax_tevt1 = (max_temp1_tevt - pedestal_tevt1.first) / gain_tevt1.first;
	  std::pair<int,double> max1_tevt = std::make_pair(maxSipm1_tevt,pesmax_tevt1);
	  pes_tevt.push_back(max1_tevt);
	  std::vector<double> pos_tevt1 = crt::auxfunctions::getPos(key_tevt1, sensor_pos);

	  std::pair<double,double> gain_tevt2 = crt::auxfunctions::getGain(key_tevt2, SiPMgain);
	  std::pair<double,double> pedestal_tevt2 = crt::auxfunctions::getGain(key_tevt2, SiPMpedestal);
	  double pesmax_tevt2 = (max_temp2_tevt - pedestal_tevt2.first) / gain_tevt2.first;
	  std::pair<int,double> max2_tevt = std::make_pair(maxSipm2_tevt,pesmax_tevt2);
	  pes_tevt.push_back(max2_tevt);
	  std::vector<double> pos_tevt2 = crt::auxfunctions::getPos(key_tevt2, sensor_pos);
	  
	  std::vector<double> interpos_tevt = crt::auxfunctions::inter_X(pesmax_tevt1, pos_tevt1, pesmax_tevt2, pos_tevt2);
	  double interpos_tevt_err = crt::auxfunctions::inter_X_error(pesmax_tevt1, pesmax_tevt2, Lbar_);//CHECK for TOP


	  std::vector<std::pair<int,double> > pes_st;//to be store                                                                                               

	  double max_temp1_st = -1;
	  unsigned int maxSipm1_st = -1;
	  double max_temp2_st = -1;
	  unsigned int maxSipm2_st = -1;

	  for(size_t i_chan=0; i_chan<32; ++i_chan){ //1st max                                                                                                   
	    if(event_st->adc[i_chan]>max_temp1_st){
	      max_temp1_st=event_st->adc[i_chan];
	      maxSipm1_st=i_chan;
	    }
	  }//1st max                                                                                                                                             

	  if (maxSipm1_st % 2 == 0){//2nd max                                                                                                                    
	    maxSipm2_st = maxSipm1_st+1;
	  } else if(maxSipm1_st % 2 == 1) {
	    maxSipm2_st = maxSipm1_st-1;
	  }
	  max_temp2_st=event_st->adc[maxSipm1_st];
	  //2nd max                                                                                                                                              

	  if(maxSipm2_st < maxSipm1_st){//swap                                                                                                                   
	    unsigned int temp = maxSipm1_st;
	    maxSipm1_st=maxSipm2_st;
	    maxSipm2_st=temp;
	    double maxtemp = max_temp1_st;
	    max_temp1_st = max_temp2_st;
	    max_temp2_st =maxtemp;
	  }//swap                                                                                                                                                

	  int key_st1 = feb_st*100+maxSipm1_st;
	  int key_st2 = feb_st*100+maxSipm2_st;

	  std::pair<double,double> gain_st1 = crt::auxfunctions::getGain(key_st1, SiPMgain);
	  std::pair<double,double> pedestal_st1 = crt::auxfunctions::getGain(key_st1, SiPMpedestal);
	  double pesmax_st1 = (max_temp1_st - pedestal_st1.first) / gain_st1.first;                                                                             \

	  std::pair<int,double> max1_st = std::make_pair(maxSipm1_st,pesmax_st1);
	  pes_st.push_back(max1_st);
	  std::vector<double> pos_st1 = crt::auxfunctions::getPos(key_st1, sensor_pos);


	  std::pair<double,double> gain_st2 = crt::auxfunctions::getGain(key_st2, SiPMgain);
	  std::pair<double,double> pedestal_st2 = crt::auxfunctions::getGain(key_st2, SiPMpedestal);
	  double pesmax_st2 = (max_temp2_st - pedestal_st2.first) / gain_st2.first;
	  std::pair<int,double> max2_st = std::make_pair(maxSipm2_st,pesmax_st2);
	  pes_st.push_back(max2_st);
	  std::vector<double> pos_st2 = crt::auxfunctions::getPos(key_st2, sensor_pos);

	  std::vector<double> interpos_st = crt::auxfunctions::inter_X(pesmax_st1, pos_st1, pesmax_st2, pos_st2);
	  double interpos_st_err = crt::auxfunctions::inter_X_error(pesmax_st1, pesmax_st2, Lbar_);//CHECH for TOP



	  //pos vector/ 0=x 1=y 2=z 3=plane 4=layer 5=orientation;                                                                                               
	  if((pos_tevt1[3]==pos_st1[3]) && (pos_tevt1[4]!=pos_st1[4]) && (abs(pos_tevt1[4]-pos_st1[4])<2)  && (pos_tevt1[5]!=pos_st1[5]) && (max_temp1_tevt>500)\
	     && (max_temp2_tevt>500) && (max_temp1_st>500) && (max_temp1_st>500) && (max_temp1_tevt<4000) && (max_temp2_tevt<4000) && (max_temp1_st<4000) && (max_temp1_st<4000)){//E

	    //quality plots
	    FEBvsFEB->Fill(feb_tevt,feb_st);
	    TimeDiff->Fill(time_diff);
	    //quality plots

	    double xtot=-10000., ytot=-10000., ztot=-10000.;

	    if( (interpos_tevt[6]==1) && (interpos_st[6] != 1) ){xtot=interpos_tevt[0];} //CHECK for TOP
	    if( (interpos_tevt[6]==2) && (interpos_st[6] != 2) ){ytot=interpos_tevt[1];}
	    if( (interpos_tevt[6]==3) && (interpos_st[6] != 3) ){ztot=interpos_tevt[2];}
	    
	    if( (interpos_st[6]==1) && (interpos_tevt[6] != 1) ){xtot=interpos_st[0];} //CHECK for TOP
	    if( (interpos_st[6]==2) && (interpos_tevt[6] != 2) ){ytot=interpos_st[1];}
	    if( (interpos_st[6]==3) && (interpos_tevt[6] != 3) ){ztot=interpos_st[2];}

	    if( (interpos_st[6] !=1) && (interpos_tevt[6] != 1) ){xtot=(interpos_tevt[0] + interpos_st[0])/2;} //CHECK for TOP
	    if( (interpos_st[6] !=2) && (interpos_tevt[6] != 2) ){ytot=(interpos_tevt[1] + interpos_st[1])/2;}
	    if( (interpos_st[6] !=3) && (interpos_tevt[6] != 3) ){ztot=(interpos_tevt[2] + interpos_st[2])/2;}

	    hxtot->Fill(xtot);
	    hytot->Fill(ytot);
	    hztot->Fill(ztot);

	    double hit_time = (time_tevt + time_st)/2; //errors!! calculate error

	    crt::CRTData::CRTHit CRTevent;

	    CRTevent.x_pos= xtot;    //light atenuation missing                                                                                                               
	    CRTevent.x_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
	    CRTevent.y_pos= ytot;
	    CRTevent.y_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
	    CRTevent.z_pos= ztot;
	    CRTevent.z_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );

	    CRTevent.ts0_ns = hit_time; //errors!!  
	    
	    std::vector<uint8_t> ids;
	    ids.push_back(feb_tevt);
	    ids.push_back(feb_st);
	    CRTevent.feb_id = ids;
	    
	    
	    std::map< uint8_t, std::vector<std::pair<int,double> > > pesmap;
	    pesmap[feb_tevt] = pes_tevt;
	    pesmap[feb_st] = pes_st;
	    CRTevent.pesmap = pesmap;

	    //WRITE THE CRTHit SOMEWHERE!!!!!!!



	    //WRITE THE CRTHit SOMEWHERE!!!!!!!

	    //quality plot
	    if(pos_tevt1[3]==0){
	      HitDistBot->Fill(ztot,xtot);
	    }                                               
	    if(pos_tevt1[3]==1){                                                                                                            
	      HitDistFT->Fill(ztot, ytot);
	    }
	    if(pos_tevt1[3]==2){              
	      HitDistPipe->Fill( ztot, ytot);
	    }
	    if(pos_tevt1[3]==3){
	      HitDistTop->Fill(ztot,xtot);
	    }                                                                              
	    //quality plot
	    
	  }//E
	}//D
      }//C
    }//B
  }//A
}

void bernfebdaq::CRTHitProducer::beginJob()
{
  my_tree_ = tfs->make<TTree>("my_tree","CRT Analysis Tree");

  crt::auxfunctions::FillPos(SiPMpositions_, sensor_pos); //key = FEB*100+ch  //fill sipm positions      
  crt::auxfunctions::FillFEBDel(FEBDelays_, FEBDel); //key = FEB  //fill FEB delays
  crt::auxfunctions::FillGain(CRTGains_, SiPMgain); //key = FEB*100+ch  //fill sipms gain
  crt::auxfunctions::FillGain(CRTPedestals_, SiPMpedestal); //key = FEB*100+ch  //same for pedestals 

  HitDistBot = tfs->make<TH2F>("Bottom","Bottom",350,200,900, 350, -200, 500);
  HitDistBot->GetXaxis()->SetTitle("Z (cm)");
  HitDistBot->GetYaxis()->SetTitle("X (cm)");

  HitDistFT = tfs->make<TH2F>("Feedthrough Side","Feedthrough Side",700,-200,1200, 250, -300, 200);
  HitDistFT->GetXaxis()->SetTitle("Z (cm)");
  HitDistFT->GetYaxis()->SetTitle("Y (cm)");

  HitDistPipe = tfs->make<TH2F>("Pipe Side","Pipe Side",700,-200,1200, 350, -300, 400);
  HitDistPipe->GetXaxis()->SetTitle("Z (cm)");
  HitDistPipe->GetYaxis()->SetTitle("Y (cm)");

  HitDistTop = tfs->make<TH2F>("Top","Top",700,-200,1200, 450, -300, 600);
  HitDistTop->GetXaxis()->SetTitle("Z (cm)");
  HitDistTop->GetYaxis()->SetTitle("X (cm)");

  FEBvsFEB = tfs->make<TH2F>("FEBvsFEB","FEBvsFEB",100,0,100,100,0,100);
  FEBvsFEB->GetXaxis()->SetTitle("FEB ID");
  FEBvsFEB->GetYaxis()->SetTitle("FEB ID");

  TimeDiff = tfs->make<TH1F>("Coincidence time difference","Coincidence time difference",400,0,400);
  TimeDiff->GetXaxis()->SetTitle("Time Difference (ns)");
  TimeDiff->GetYaxis()->SetTitle("Entries/bin");

  hxtot = tfs->make<TH1F>("xtot","xtot",70000,-200,500);
  hxtot->GetXaxis()->SetTitle("Reconstructed X (cm)");
  hxtot->GetYaxis()->SetTitle("Entries/bin");

  hytot = tfs->make<TH1F>("ytot","ytot",60000,-300,300);
  hytot->GetXaxis()->SetTitle("Reconstructed Y (cm)");
  hytot->GetYaxis()->SetTitle("Entries/bin");

  hztot = tfs->make<TH1F>("ztot","ztot",130000,-100,1200);
  hztot->GetXaxis()->SetTitle("Reconstructed Z (cm)");
  hztot->GetYaxis()->SetTitle("Entries/bin");


}

void bernfebdaq::CRTHitProducer::endJob()
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(bernfebdaq::CRTHitProducer)
